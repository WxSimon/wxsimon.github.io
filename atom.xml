<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simon</title>
  
  
  <link href="http://blog.simoncode.top/atom.xml" rel="self"/>
  
  <link href="http://blog.simoncode.top/"/>
  <updated>2025-01-13T06:23:47.008Z</updated>
  <id>http://blog.simoncode.top/</id>
  
  <author>
    <name>Simon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>年出行总结</title>
    <link href="http://blog.simoncode.top/2025/01/13/31-2024%20%E5%B9%B4%E5%87%BA%E8%A1%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2025/01/13/31-2024%20%E5%B9%B4%E5%87%BA%E8%A1%8C%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-13T05:08:01.000Z</published>
    <updated>2025-01-13T06:23:47.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024-年出行总结"><a href="#2024-年出行总结" class="headerlink" title="2024 年出行总结"></a>2024 年出行总结</h1><p>一晃一年又过去了，这一年里没有旅游过太多地方。没有了提车第一年的新鲜感，再加上附近的景点都去的大差不差了，所以 24 年的出行总结比较简单</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>老规矩，先上一下 teslamate 的出行地图</p><p><img src="http://static.simoncode.top/picgo/20250113131930392.png"></p><p>今年除去回老家，主要去了 连云港、舟山、常州、常熟和安徽</p><p><img src="http://static.simoncode.top/picgo/20250113132203644.png"></p><p><img src="http://static.simoncode.top/picgo/20250113132320547.png" alt="充电成本"></p><p>去年一共行驶了 <strong>22435公里</strong>，充电总花费了 1751.61 元，算下来每公里 0.068 元，算下来每个公里成本和去年一致。由于今年外出旅游的次数变少但是没有去年的免费超充额度，所以成本可以去初年持平。</p><h2 id="端午连云港行"><a href="#端午连云港行" class="headerlink" title="端午连云港行"></a>端午连云港行</h2><p>19 年的时候，那时候 kiko 还在培训机构上班。每到节假时都非常忙，所以我俩根本没有节假日出去游玩的机会。而那年中秋节，刚好那时的同事一起计划着去一趟连云港的自驾游，回来后就一直许诺带 kiko 去一次。刚好四月份的时候连云港没有禁海，是去连云港最好的时间了。</p><p>从南京出发不算太远，不堵车的情况下三个多小时可以到。但是节假日哪有不堵车的呢，我记得我们那边开了五六个小时才到。中间在高速上一动不动堵了小一个小时，我俩都差点在车上睡着了🥲。</p><p><img src="http://static.simoncode.top/picgo/20250113133819854.png"></p><p>好在四月份连云港的天气非常的不错，加上没有禁海的原因，海鲜的价格比较能接受。</p><img src="http://static.simoncode.top/picgo/20250113133807339.png" style="zoom:33%;" /><img src="http://static.simoncode.top/picgo/20250113133837883.png" style="zoom:33%;" /><p>连云港整体消费水平都比较低，前来旅游的游客也不多，好评。</p><p>临到了结束回来的时候，我俩一起开车去了渔民自己捕捞卖货的地方，以及其优惠的价格买个不少皮皮虾和生蚝回来。海鲜品质非常不错，在家吃的时候还后悔着买少了。</p><h2 id="五一舟山行"><a href="#五一舟山行" class="headerlink" title="五一舟山行"></a>五一舟山行</h2><p>18 年的时候，我俩有过高铁转大巴转轮船到东极岛的旅游经历。所以对东极岛十分的好感，但是那次只是去了岛上，对于登岛的舟山没有逛过，所以秉承着去人少的地方的原则，我们这次五一选择了去舟山。</p><p>去的路上一如既往的堵车，我们硬生生的开了一天才到达沈家门。到的时候天都黑了，办完住宿后我俩便在沈家门的路上闲逛。</p><p>沈家门登船去普陀山</p><img src="http://static.simoncode.top/picgo/20250113134855237.png"  /><p>南海观音</p><p><img src="http://static.simoncode.top/picgo/20250113134917938.png"></p><p>骑着租的电动车，绕着朱家尖跑了一圈</p><p><img src="http://static.simoncode.top/picgo/20250113134936544.png"></p><h2 id="国庆常州-amp-常熟行"><a href="#国庆常州-amp-常熟行" class="headerlink" title="国庆常州&amp;常熟行"></a>国庆常州&amp;常熟行</h2><p>常州比较有意思的是误打误撞地去了一个商场里面，然后商场里面在举办翻唱演唱会。坐在那里跟着唱了一个多小时的杰伦的歌。</p><p>常熟我们一起爬了一半的 “雄鹰线”，非常有趣刺激。由于线路没有被商业开发，所以走起来有那种原始探秘的体验。遗憾的就是由于当天到常熟的时间太晚，走不完全程。</p><p><img src="http://static.simoncode.top/picgo/IMG_1E0F138BA9D0-1.jpeg"></p><p>​    只有头的“雄鹰”</p><h2 id="十一月音乐节"><a href="#十一月音乐节" class="headerlink" title="十一月音乐节"></a>十一月音乐节</h2><p>每次想听歌音乐节都异常的艰难。本来七月份的时候买好了南京的一个 RAP 专场的音乐节门票，天公不作美，那天超大台风过境。主办方为了安全直接取消了演出。所以对于十一月份的这个音乐节我们便充满了期待。</p><p><video src="http://static.simoncode.top/picgo/t7UMrpWylx08jooO6vJu010412012fFU0E010.mp4" controls="controls" width="500" height="300"></video></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024-年出行总结&quot;&gt;&lt;a href=&quot;#2024-年出行总结&quot; class=&quot;headerlink&quot; title=&quot;2024 年出行总结&quot;&gt;&lt;/a&gt;2024 年出行总结&lt;/h1&gt;&lt;p&gt;一晃一年又过去了，这一年里没有旅游过太多地方。没有了提车第一年的新鲜感，再加</summary>
      
    
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="出行" scheme="http://blog.simoncode.top/tags/%E5%87%BA%E8%A1%8C/"/>
    
    <category term="特斯拉" scheme="http://blog.simoncode.top/tags/%E7%89%B9%E6%96%AF%E6%8B%89/"/>
    
  </entry>
  
  <entry>
    <title>2023 年出行总结</title>
    <link href="http://blog.simoncode.top/2024/01/19/30-2023%20%E5%B9%B4%E5%87%BA%E8%A1%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2024/01/19/30-2023%20%E5%B9%B4%E5%87%BA%E8%A1%8C%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-19T02:08:58.000Z</published>
    <updated>2024-02-20T00:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023-年出行总结"><a href="#2023-年出行总结" class="headerlink" title="2023 年出行总结"></a>2023 年出行总结</h1><p>早上开车上班的时候，发现车子的总里程已经 2 万多公里了。马上也到提车一年了，就趁着这个时间点总结一下2023 年的出行。</p><p>因为提车之后就部署了 <a href="https://github.com/teslamate-org/teslamate">teslamate</a>，所以每次出行都可以通过后台查看到。</p><span id="more"></span><h2 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h2><p>去年提车 23.02 到现在 24.01 共行驶了 <strong><strong>23818km</strong></strong></p><p>去过浙江安吉、江苏常熟、苏州、扬州、高邮、湖北孝感、黄冈。当然大部份时间还是在南京</p><p><img src="http://static.simoncode.top/picgo/Untitled1.png"></p><p><img src="http://static.simoncode.top/picgo/Untitled.png"></p><p>总共充了 <strong><strong>3.39k</strong></strong> 度电，大致消费了 <strong><strong>1499.11</strong></strong> 元，换算下来每公里成本 0.06 元。当然这里面大部份是因为在家使用谷电补能，还有前期 Tesla 送的超充里程解决了外出的出行成本。</p><p><img src="http://static.simoncode.top/picgo/Untitled2.png"></p><p>总得来说，购车之后大大的扩大出行距离，之前觉得远麻烦去的地方自从有车之后也变得方便起来了。印象比较深的就是几年好像已经去过好多次义乌小商品市场了。</p><h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><h3 id="江宁提车"><a href="#江宁提车" class="headerlink" title="江宁提车"></a>江宁提车</h3><p>二月是提车的第一个月，做为驾驶证已经到期更换但从未上路的“老”司机来说，开车上路还是有很大难度的。所以提车那天，叫上了之前的同事一起。印象中提车那天还挺顺利的，由于我们去的比较早，接待大厅稍微坐了一会工作人员就帮我们把相关的手续办好了。然后就是简单的提车拍照环节。</p><p><img src="http://static.simoncode.top/picgo/Untitled3.png"></p><p>在这里也非常感谢朱哥那天能够赶过来帮忙，指导我这个新手踉踉跄跄地将车开回家。</p><h3 id="公司-第一天上路"><a href="#公司-第一天上路" class="headerlink" title="公司-第一天上路"></a>公司-第一天上路</h3><p>地狱开局的难度。周一那天由于第一次上路不放心，kiko 坐在副驾驶陪我一起开车去公司。出发之前我俩商量着可以早点到公司一起吃顿早饭，谁能想到我的第一次上路就遇到了地狱开局。那天简直 Debuff 拉满，大雨 + 周一 + 开学。上面三个条件单拉一个出来就得让早高峰堵死，谁能想到我第一天就将三者集齐了。路上我小心翼翼地变道，时不时得让 kiko 帮我观察观察右边的车距，就这样短短 20km 的路径我们硬是开了两个小时才到公司。这里不得不吐槽一下特斯拉没有 360 有时候确实不太方便。</p><h3 id="六合挖雨花石"><a href="#六合挖雨花石" class="headerlink" title="六合挖雨花石"></a>六合挖雨花石</h3><p>有了车之后就总想着出去玩耍，再加上虽然在南京待了那么多年，但是依然很多区没有去过。所以二月周六的一个下午，kiko 就约着一起去捡雨花石。我俩在小红书、大众点评上各种搜索，最后定下来去六合的小天池。</p><p>本来去的路就不太好走，由于六合那边到处都在修高架，导致路面全部都是坑坑洼洼，然后那天还下着小雨就更难走了。我俩开了开了一个多小时才到。</p><p>到了之后我俩就傻眼了，这是啥小天池啊，这不就纯纯的小山堆嘛。路两边全部都被铁皮围起来了，只有一个小破石堆。但就这 kiko 依然挖的不亦乐乎。哈哈哈</p><p><img src="http://static.simoncode.top/picgo/Untitled.jpeg"></p><h3 id="汤山矿坑公园"><a href="#汤山矿坑公园" class="headerlink" title="汤山矿坑公园"></a>汤山矿坑公园</h3><p>记得那天出发的时候就已经两三点了。那时候天气非常舒服，公园里面露营的人不少，还有不少银行在哪推销办信用卡呢</p><p><img src="http://static.simoncode.top/picgo/Untitled1.jpeg"></p><p>远处看还是挺壮观的</p><p><img src="http://static.simoncode.top/picgo/Untitled2.jpeg"></p><p>刚出生没几个月的小狗狗，刚刚洗完澡身上可香了</p><h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><h3 id="常熟"><a href="#常熟" class="headerlink" title="常熟"></a>常熟</h3><p>三月我们去了一趟卡酷桑哪里，从南京出发大概 250 多公里。我们早上八点半多发的，差不多中午十一点出头就到了。那也是我第一次上高速，说到这里就不得不夸一下特斯拉的辅助驾驶了，高速跑起来确实挺省心的。全程两个半小时，到达目的地之后几乎没有那种长途驾驶的疲惫感。</p><p><img src="http://static.simoncode.top/picgo/Untitled3.jpeg"></p><p>常熟的樱花</p><p><img src="http://static.simoncode.top/picgo/Untitled4.jpeg"></p><p>苏州“大裤衩”</p><h3 id="”撞车”啦"><a href="#”撞车”啦" class="headerlink" title="”撞车”啦"></a>”撞车”啦</h3><p>三月底的时候，我就引来了车子的“一血”。早上从出车库的时候，大概是还没睡醒的原因，上车就直接往右拐了，直接就剐蹭到了旁边的车。撞上去之后大脑是懵的，kiko 在车库出口等我，听到声音后立马赶了过来。这里也非常感谢 kiko，第一时间没有说任何指责我的话，而是开始想解决问题的办法。</p><p>由于是第一次出险，我俩都没有任何经验，便求助身边的朋友。打电话报警、联系保险公司、联系车主。</p><p>被剐蹭的车主也是一个小伙子，见面之后我们也连忙道歉。换位思考一下，他人躺床上睡觉，车好好地停在车库，被交警电话吵醒告知车被撞了，换谁心里都不舒服。</p><p>后面的流程就是交警定责然后各自修各自的车了。该说不说特斯拉修车是真他妈贵啊！</p><p><img src="http://static.simoncode.top/picgo/Untitled5.jpeg"></p><p>被我撞的车，私密马赛</p><h3 id="马鞍山"><a href="#马鞍山" class="headerlink" title="马鞍山"></a>马鞍山</h3><p>三月的结尾，kiko 开始了将近半年的考试征程。撞车的那个周末，本来准备我这边开车带上她朋友一起去马鞍山的。好巧不巧就在这周五撞上了。</p><h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>四月份开始，kiko 就为考试到处奔波了</p><h3 id="江宁"><a href="#江宁" class="headerlink" title="江宁"></a>江宁</h3><p>江宁的那个考试是宿迁的一个中学招聘。面试地点是在晓庄学院江宁校区，由于面试时间非常早 7:30,我们住的地方离江宁又非常远，所以那天早上起来的非常早。好在早起没有白费，kiko 也以第一名拿到了那个 offer。</p><p><img src="http://static.simoncode.top/picgo/20240119181612.png"></p><p>考试那天我也是在附近到处转悠，竟然偶然地当了一回马拉松的观众。</p><p><img src="http://static.simoncode.top/picgo/IMG_3774.jpeg"></p><h3 id="长江潮音乐节"><a href="#长江潮音乐节" class="headerlink" title="长江潮音乐节"></a>长江潮音乐节</h3><p>整个四月份最期待的事情就是音乐节了。这个音乐节也是命途多舛，21 年开始因为疫情开票三次然后取消了三次。</p><p><img src="http://static.simoncode.top/picgo/IMG_3784.jpeg"></p><p>第一次见到许嵩</p><h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><h3 id="黄冈-回家"><a href="#黄冈-回家" class="headerlink" title="黄冈-回家"></a>黄冈-回家</h3><p>准确点来讲应该放在四月份，因为今年的五一假期比较特殊，四月末就假期就开始了。</p><p>五一回家那几天特别忙，参加了 kiko 表哥的婚礼、见了几个老朋友</p><h3 id="高邮"><a href="#高邮" class="headerlink" title="高邮"></a>高邮</h3><p>高邮也是为了去考试，记得那天是周五下班了赶过去的。高邮离南京并不远，差不多 100 多 km ，所以开了差不多一个多小时就到了。</p><p>住的酒店楼下就有一个早餐店，所以我们早上出门的时候很方便地来了一碗当地的特色鱼汤。有一说一有点东西。</p><p>当然，在高邮也收到了第一份扣分违章</p><p><img src="http://static.simoncode.top/picgo/IMG_4793.jpeg"></p><h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>六月的前部分时间，kiko 进行了一场毕业旅行。所以前半个月并没有出远门</p><h3 id="安吉"><a href="#安吉" class="headerlink" title="安吉"></a>安吉</h3><p>“大坑”的小杭坑。kiko 在小红书搜到的别人推荐，什么号称小伊犁。作为刚刚从真伊犁旅游回来的kiko，决定去好好看下做下对比。</p><p>非常不赶巧，当天是端午节。去小杭坑的路上有赛龙舟的比赛导致有一段路被封，好在高德地图非常给力，给我们导到了一个翻山的路。</p><p><img src="http://static.simoncode.top/picgo/IMG_3978.jpeg"></p><p>翻山的路上风景</p><p><img src="http://static.simoncode.top/picgo/IMG_4003.jpeg"></p><p>“小伊犁”</p><p><img src="http://static.simoncode.top/picgo/IMG_4011.jpeg"></p><p>茶山</p><h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>七月份的生活就略显无聊了，好像都没有出南京市。</p><h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><h3 id="高淳"><a href="#高淳" class="headerlink" title="高淳"></a>高淳</h3><p>这是八月份的唯一一次远门，主要是陪 kiko 练车。从家出发到石臼湖，大概 100km。kiko 开过去的，一路上没有多少高速都是城市道路，大概开了两个多小时。</p><p>八月份的石臼湖景色一般，传说中的龙猫海也木有看到</p><h3 id="同事婚礼"><a href="#同事婚礼" class="headerlink" title="同事婚礼"></a>同事婚礼</h3><p>八月还有一件大事，就是之前我和 kiko 介绍的两位前同事终于结婚了。</p><p>说起这二位也是不容易，中间分分合合，不过好在最终走向了婚姻的殿堂</p><p><img src="http://static.simoncode.top/picgo/IMG_4114.jpeg"></p><p>那天见到了很多之前的同事，也见证了他俩的爱情</p><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p>这个月也是 kiko 开始工作的第一个月，月底 kiko 和我讲她发工资的时候，我有一种老父亲看到女儿长大的欣慰感</p><h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><h3 id="黄冈-回家-1"><a href="#黄冈-回家-1" class="headerlink" title="黄冈-回家"></a>黄冈-回家</h3><p>今年应该工作之后少有的回家那么勤的一年。本来五一已经回过家了，十一就该出去旅游的。但是我两个好朋友都定在今年十一婚礼，所以不管咋样都得回家。</p><p>这次国庆回家也是人在囧途</p><p><strong>堵车</strong></p><p>考虑到国庆期间高速路上拥堵。我俩商量着早上两点出门，出门前看了一眼导航，发现离我们最近的高速两点还是一片红。头铁的我俩出了门，上了高速之后才发现傻眼了，高速路上全是车。凌晨两点啊，全是车。路上经过的服务区也都是爆满，进去都需要排长队。最终黄天不负有心人啊，原本五个小时的车程，我们开了十一个小时。回家最后的一段路，感觉都是在闭眼睛开车了。</p><p><strong>充电</strong></p><p>这就是回家做的第二件傻逼事情。22 年家里新装了一面镜子，之前的全身镜就闲置下来了。kiko 就说这次回家不如把这面镜子带回家。鉴于镜子的长度，便把后排打倒放置。然后为了加强稳定性，好巧不巧车子的后备箱有一根多出来绳子，我们便将镜子缠绕几层后和车上的绳子固定。</p><p>路上我们停在第一个服务区的时候，就想着趁着上卫生间的功夫冲一下电，试了两三个充电桩都冲不进去电。想着是充电站的问题加上当时电量足够，我们便继续上路。</p><p>开了三百多公里后，车子必须充电了。我们便找了一个就近的服务区停下来充电，这个时候车子还是无法冲进去电。此时我们已经开始着急了，因为如果不充的话车子无法开回家。我们便立马开始联系充电站管理人员、特斯拉的官方客服，最终都无果。因为出问题的都是国家电网的充电桩，所以我决定下高速找一个第三方的充电桩试试。</p><p>下了高速，我们来到一个特来电的充电桩，扫码、付钱、充电。车辆任然提示无法充电，这个时候电量不足的焦虑加上旅途的疲惫和几次的失败交杂在一起。我们又拨通了特斯拉客服的电话，接电话的是一位小哥哥，非常耐心的知道我们做各种检查，当他说到：“麻烦将充电口的锁复位一下呢”，我问：“怎么复位呢？”，他说：“拉一下充电口附近的小绳”。听完他说的话，我立马道歉+挂断电话。是的，导致我们无法充进电的原因就是我们将充电口的锁绳常开了。</p><p><img src="http://static.simoncode.top/picgo/20240119182112.png"></p><h3 id="孝感-接亲第一弹"><a href="#孝感-接亲第一弹" class="headerlink" title="孝感-接亲第一弹"></a>孝感-接亲第一弹</h3><p>由于女方那边的要求，接亲出门仪式需要在10.2 号凌晨进行，所以需要在10.1 日晚上到达女方家里。</p><p>浠水到孝感，全程 170多公里。1 号晚上七点多出门，一路上还下了点小雨，好在一路上比较顺利。最终准时到达女方家里。</p><p><img src="http://static.simoncode.top/picgo/IMG_4279.jpeg"></p><p>凌晨到达，准备接亲</p><p><img src="http://static.simoncode.top/picgo/5370e4ac30eba86a841f9b17bdff0970.jpeg"></p><p>婚礼现场</p><h3 id="团陂-接亲第二弹"><a href="#团陂-接亲第二弹" class="headerlink" title="团陂-接亲第二弹"></a>团陂-接亲第二弹</h3><p>第二场接亲就比较简单了，因为都是在浠水县内，根本不需要那么着急。而且当天晚上我们就住在男方家对面，接亲的路上也是车头全程带队，队伍也很庞大。</p><p><img src="http://static.simoncode.top/picgo/IMG_4290.jpeg"></p><p>女方家那边都是太阳能发电</p><p><img src="http://static.simoncode.top/picgo/IMG_4293.jpeg"></p><p>婚礼现场</p><h3 id="扬州"><a href="#扬州" class="headerlink" title="扬州"></a>扬州</h3><p>从年头就计划着去扬州，到十月末的时候，终于去到了。</p><p><strong>大运河博物馆</strong>，去扬州比较推荐的地方，重点是免费，而且停车场巨大。唯一的小插曲就是去的路上差点把车子的地盘剐蹭到。</p><p><img src="http://static.simoncode.top/picgo/IMG_4384.jpeg"></p><p>其他就是在关东街附近走走转转，喝了扬大的酸奶，早上起来去吃了扬州的早茶。整体感觉早茶和南京的早茶没啥区别。包子、馄饨、面条，作为一个湖北人没有很爱。</p><h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><h3 id="常熟-1"><a href="#常熟-1" class="headerlink" title="常熟"></a>常熟</h3><p>这次去常熟是为了参加卡酷桑的婚礼，同样我俩作为她和小吴的感情见证人，见证了他们的相识、相爱、离别和最终走向婚姻殿堂，结局是美好的。</p><p>小吴接亲时候的真情流露，确实感动到了当时在现场的我。</p><p>十一月剩下的日子就比较单调了，正常的上下班、周末打打乒乓球。</p><h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><h3 id="滁州"><a href="#滁州" class="headerlink" title="滁州"></a>滁州</h3><p>去滁州也是临时起意，家这边离滁州非常的近。周六下午就和kiko 简单商量之后就决定过去</p><p>到了之后才知道，原来欧阳修的《醉翁亭记》就是在滁州写的。</p><p><img src="http://static.simoncode.top/picgo/IMG_4650.jpeg"></p><p><img src="http://static.simoncode.top/picgo/IMG_4654.jpeg"></p><h3 id="马鞍山-1"><a href="#马鞍山-1" class="headerlink" title="马鞍山"></a>马鞍山</h3><p>和四月份去马鞍山的目的完全不同，这次去就纯粹是为了泡澡。</p><p>我们一行四人早上九点多便出了门，十点钟不到便到了马鞍山。</p><p>有一说一汤乐汇的那个现煮面条味道确实不错，小猫胃的 kiko 竟然都能吃得下一碗,amazing!!!</p><h3 id="新街口-跨年"><a href="#新街口-跨年" class="headerlink" title="新街口-跨年"></a>新街口-跨年</h3><p>作为从不凑热闹的我，竟然也跑到了新街口跨年。好在我们那天时间安排的都很巧妙。十一点四十多从珠江路地铁站出站，路上等了十几分钟就等到了倒计时。没有很拥挤也没有等很久，所以整体的体验还是非常好。</p><p><img src="https://static.simoncode.top/picgo/IMG_4678.jpeg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>2023 年是疫情放开之后的第一年，也终于有机会能够出去走走看看。</p><p>2023 年也是 kiko 研究生毕业的一年，学生到教师，你小子适应的还可以嘛。</p><p>2023 年我好像只有球技提供了一点点，其他都没啥进步。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2023-年出行总结&quot;&gt;&lt;a href=&quot;#2023-年出行总结&quot; class=&quot;headerlink&quot; title=&quot;2023 年出行总结&quot;&gt;&lt;/a&gt;2023 年出行总结&lt;/h1&gt;&lt;p&gt;早上开车上班的时候，发现车子的总里程已经 2 万多公里了。马上也到提车一年了，就趁着这个时间点总结一下2023 年的出行。&lt;/p&gt;
&lt;p&gt;因为提车之后就部署了 &lt;a href=&quot;https://github.com/teslamate-org/teslamate&quot;&gt;teslamate&lt;/a&gt;，所以每次出行都可以通过后台查看到。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="出行" scheme="http://blog.simoncode.top/tags/%E5%87%BA%E8%A1%8C/"/>
    
    <category term="特斯拉" scheme="http://blog.simoncode.top/tags/%E7%89%B9%E6%96%AF%E6%8B%89/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一个自己的 RPC 框架（三）</title>
    <link href="http://blog.simoncode.top/2023/12/13/29-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%89)/"/>
    <id>http://blog.simoncode.top/2023/12/13/29-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%89)/</id>
    <published>2023-12-13T07:07:51.000Z</published>
    <updated>2023-12-13T06:17:23.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何开发一个自己的-RPC-框架（三）"><a href="#如何开发一个自己的-RPC-框架（三）" class="headerlink" title="如何开发一个自己的 RPC 框架（三）"></a>如何开发一个自己的 RPC 框架（三）</h1><p>之前的两篇文章中，已经介绍了实现一个 RPC 框架所需要的客户端和注册中心逻辑，那么这一章，将主要介绍如何实现 RPC 框架中的服务端(服务提供方) 和完善框架的其他补充逻辑。</p><span id="more"></span><h2 id="RPC-服务端实现"><a href="#RPC-服务端实现" class="headerlink" title="RPC 服务端实现"></a>RPC 服务端实现</h2><h3 id="服务注解-RpcProducer"><a href="#服务注解-RpcProducer" class="headerlink" title="服务注解(RpcProducer)"></a>服务注解(RpcProducer)</h3><p>和客户端调用标识类似，服务提供方也需要设置服务标识，用来服务的注册和相关配置信息拓展</p><p><code>@RpcProducer</code> 服务提供方注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcProducer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口:用于注册在服务注册中心，服务调用端获取后缓存再本地用于发起服务调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; serviceItf() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务分组组名：可用于分组灰度发布，配置不同分组，可以让调用都路由到配置了相同分组的路由上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">groupName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间：控制服务端超时时间 ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供者权重：配置该机器在集群中的权重，用于某些负载均衡算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">weight</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端线程数：限制服务端改服务线程数，服务端限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">workThreads</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务提供方节点注册"><a href="#服务提供方节点注册" class="headerlink" title="服务提供方节点注册"></a>服务提供方节点注册</h3><p>为了实现所有被 <code>@RpcProducer</code> 注解的实现类都可以被注册到注册中心，在 Spring 中，需要实现 </p><ul><li>ApplicationListener： <code>onApplicationEvent</code> 监听应用程序事件</li><li>ApplicationContextAware： <code>setApplicationContext</code> 设置当前上下文</li><li>DisposableBean：<code>destroy</code> 方法，bean 被销毁时执行</li></ul><p>这三个接口，通过 <code>setApplicationContext</code> 设置当前上下文，通过 <code>onApplicationEvent</code> 监听服务实现类然后提交到注册中心</p><p>理清楚上面流程后，便可以创建实现类 <code>ProducerAnnotationBean</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAnnotationBean</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationContextEvent&gt;, ApplicationContextAware, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 销毁 */</span></span><br><span class="line">        log.debug(<span class="string">&quot;AnnotationServicesPublisher bean destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="number">1</span>️⃣ <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> &#123;<span class="number">2</span>️⃣&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣：设置当前上下文</p><p>2️⃣：监听 Spring Bean 的动作</p><p><code>onApplicationEvent</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> &#123;</span><br><span class="line">        <span class="number">1</span>️⃣ <span class="keyword">if</span> (event.getApplicationContext() != applicationContext) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Received a event from another application context &#123;&#125;, ignoring it&quot;</span>, event.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新事件</span></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; annotation = applicationContext.getBeansWithAnnotation(RpcProducer.class);</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(annotation)) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;no simple rpc exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                annotation.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;simple rpc beanName: &#123;&#125;, bean: &#123;&#125;&quot;</span>, beanName, bean);</span><br><span class="line">                   <span class="number">2</span>️⃣ <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcProducer.class)) &#123;</span><br><span class="line">                        <span class="comment">// 获取对象</span></span><br><span class="line">                    <span class="number">3</span>️⃣    List&lt;Producer&gt; producerList = <span class="built_in">this</span>.buildProviderService(bean);</span><br><span class="line">                        <span class="comment">// 1. 启动服务</span></span><br><span class="line">                    <span class="number">4</span>️⃣    NettyService.getInstance().startService(RpcPropertiesUtil.getServerPort());</span><br><span class="line">                        <span class="comment">// 2. 服务注册</span></span><br><span class="line">                     <span class="number">5</span>️⃣   IRegisterCenterZkImpl.getInstance().register(producerList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 销毁所有的服务</span></span><br><span class="line">           <span class="number">6</span>️⃣ IRegisterCenterZkImpl.getInstance().destroy(<span class="literal">null</span>);</span><br><span class="line">            log.info(<span class="string">&quot;simple rpc closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1️⃣：判断上下文和当前 Spring 上下文是否一致</p><p>2️⃣：判断当前实例对象是否被 <code>RpcProducer</code> 注解</p><p>3️⃣：根据当前 <code>bean</code> 构造 <code>Producer</code> 对象</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Producer&gt; <span class="title function_">buildProviderService</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="type">RpcProducer</span> <span class="variable">annotation</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcProducer.class);</span><br><span class="line">        Class&lt;?&gt; serviceItf = annotation.serviceItf();</span><br><span class="line">        <span class="keyword">if</span> (serviceItf == Object.class) &#123;</span><br><span class="line">            serviceItf = bean.getClass().getInterfaces()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NettyHandlerServer.PRODUCER_BEAN_MAP.put(serviceItf.getName(), bean);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注解信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> annotation.groupName();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> annotation.timeout();</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> annotation.weight();</span><br><span class="line">        <span class="type">int</span> <span class="variable">workThreads</span> <span class="operator">=</span> annotation.workThreads();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; finalServiceItf = serviceItf;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(bean.getClass().getDeclaredMethods())</span><br><span class="line"><span class="comment">// 过滤掉 Object.class 的 equals、notify 等方法</span></span><br><span class="line">                .filter(method -&gt; !method.getDeclaringClass().equals(Object.class))</span><br><span class="line">                .map(method -&gt; &#123;</span><br><span class="line">                    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> Producer.builder()</span><br><span class="line">                            .serviceItf(finalServiceItf)</span><br><span class="line">                            .serviceObject(bean)</span><br><span class="line">                            .ip(IpUtil.getLocalIP())</span><br><span class="line">                            .port(RpcPropertiesUtil.getServerPort())</span><br><span class="line">                            .timeout(timeout)</span><br><span class="line">                            .appKey(RpcPropertiesUtil.getAppKey())</span><br><span class="line">                            .groupName(groupName)</span><br><span class="line">                            .weight(weight)</span><br><span class="line">                            .workerThreads(workThreads)</span><br><span class="line">                            .method(method)</span><br><span class="line">                            .build();</span><br><span class="line">                    <span class="keyword">return</span> producer;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4️⃣：启动 Netty Server 服务，这一段比较重要，稍后讲解</p><p>5️⃣：向注册中心注册服务提供方的节点信息</p><p>6️⃣：服务关闭时，清除所有的节点注册信息</p><p>完成上述步骤后，所有被 <code>RpcProducer</code> 注解的 <code>class</code> 就都将被注册到注册中心中。</p><h3 id="服务提供方启动-Netty-服务"><a href="#服务提供方启动-Netty-服务" class="headerlink" title="服务提供方启动 Netty 服务"></a>服务提供方启动 Netty 服务</h3><p>上一步的步骤4️⃣中，在向服务中心注册节点时，同时根据注解的端口启动了 <code>Netty</code> 服务，那么这个 <code>Netty</code> 服务是如何启动的，然后启动的目的是什么呢？</p><p>在第一章中我们有讲到，客户端的接口在执行反射操作时，会连接服务端的 <code>Netty</code> 服务，然后发送 <code>NettyRequest</code> 请求。那么服务端接收到 <code>NettyRequest</code> 请求后会做那么事情呢？服务端又是如何根据 <code>NettyRequest</code>映射到具体的方法上，同时将方法执行的结果进行返回的呢？这一节我们一起弄清楚这一点。</p><pre class="mermaid">sequenceDiagram    客户端->>服务提供方: 1️⃣发送 NettyRequest 请求    服务提供方->>接口实现: 2️⃣通过反射执行 method    接口实现->>服务提供方: 3️⃣返回方法执行结果    服务提供方 -> 客户端: 4️⃣返回 NettyResponse 结果</pre><p>新建一个 <code>NettyService.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NettyService.class</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NettyService</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyService <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startService</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NettyService.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bossGroup != <span class="literal">null</span> || workGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;netty server is already start&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bossGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">            workGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 解码器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(NettyRequest.class));</span><br><span class="line">                            <span class="comment">// 编码器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>());</span><br><span class="line">                            <span class="comment">// 服务处理</span></span><br><span class="line">                            <span class="number">1</span>️⃣ socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyHandlerServer</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverBootstrap.bind(port).sync().channel();</span><br><span class="line">                log.info(<span class="string">&quot;NettyServer start &#123;&#125; start now!!!&quot;</span>, IpUtil.getLocalIP() + UrlConstants.COLON + port);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;NettyServer startServer error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣：设置消息处理器</p><p>上述代码都比较常规，主要是使用 <code>Netty</code> 根据传入的端口进行了服务的启动，其中最主要的代码是</p><p><code>socketChannel.pipeline().addLast(new NettyHandlerServer());</code> 设置了消息的处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NettyHandlerServer.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyHandlerServer</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;NettyRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name to bean map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_BEAN_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, NettyRequest nettyRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isWritable()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;channel closed!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">localProducer</span> <span class="operator">=</span> <span class="built_in">this</span>.getLocalProducer(nettyRequest);</span><br><span class="line">        <span class="keyword">if</span> (localProducer == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;service not found, request=&#123;&#125;&quot;</span>, nettyRequest);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.invockMethod(localProducer, nettyRequest);</span><br><span class="line">        <span class="type">NettyResponse</span> <span class="variable">response</span> <span class="operator">=</span> NettyResponse.builder()</span><br><span class="line">                .uniqueKey(nettyRequest.getUniqueKey())</span><br><span class="line">                .result(result)</span><br><span class="line">                .build();</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 methodname 获取 Producer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Producer <span class="title function_">getLocalProducer</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> request.getInvokeMethodName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getProducer().getServiceItf().getName();</span><br><span class="line">        List&lt;Producer&gt; producerList = IRegisterCenterZkImpl.getInstance().getProducersMap().get(name);</span><br><span class="line">        <span class="keyword">return</span> Collections2.filter(producerList, producer -&gt; &#123;</span><br><span class="line">            <span class="keyword">assert</span> producer != <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> producer.getMethod();</span><br><span class="line">            <span class="keyword">return</span> method != <span class="literal">null</span> &amp;&amp; method.getName().equals(methodName);</span><br><span class="line">        &#125;).iterator().next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法反射调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">invockMethod</span><span class="params">(Producer producer, NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2023/12/8 增加超时检测</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">serviceObject</span> <span class="operator">=</span> producer.getServiceObject();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> producer.getMethod();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是最重要的，服务端反射调用方法</span></span><br><span class="line">            result = method.invoke(serviceObject, request.getArgs());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            result = e;</span><br><span class="line">            log.error(<span class="string">&quot;NettyServerBizHandler invokeMethod error, provider=&#123;&#125;, request=&#123;&#125;&quot;</span>, producer, request, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.error(<span class="string">&quot;NettyServerBizHandler error, now ctx closed&quot;</span>, cause);</span><br><span class="line">        <span class="comment">// 发生异常，关闭链路</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息处理器中，在 <code>invockMethod</code> 方法中，根据传入的 <code>request</code> 的 <code>method</code> 参数进行了方法的反射获取执行结果，然后进行返回。反射执行完成后，将结果组装成 <code>NettyResponse</code> 结果进行返回。</p><p>那么到这里就完成了整个远程服务的执行。 </p><h2 id="Spring-注解服务扫描"><a href="#Spring-注解服务扫描" class="headerlink" title="Spring 注解服务扫描"></a>Spring 注解服务扫描</h2><p>定义 <code>@EnableRpc</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(&#123;RpcImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRpc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解中 <code>@Import</code> 了 <code>RpcImportSelector.class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.simon.spring.ProducerAnnotationBean&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.simon.spring.ConsumerAnnotaionBean&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RpcImportSelector</code> 对象实现了 <code>ImportSelector</code> 接口， <code>selectImports</code> 方法中返回了处理客户端和服务端注解的类。</p><p>客户端启动类 <code>ConsumerApplication.class</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务启动时，只需要加上 <code>@EnableRpc</code> 注解即可启动 RPC 服务</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><code>ConsumerApplication.class</code> 启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserController.class</code> 请求接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要远程调用的接口</span></span><br><span class="line">    <span class="meta">@RpcClient(remoteAppKey = &quot;test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><p><code>application.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8082</span></span><br></pre></td></tr></table></figure><p><code>rpc.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netty 配置</span><br><span class="line">rpc_app_key=test</span><br><span class="line"># ZK 配置</span><br><span class="line">zk_server=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span></span><br><span class="line">rpc_session_timeout=<span class="number">3000</span></span><br><span class="line">rpc_connection_timeout=<span class="number">3000</span></span><br><span class="line">rpc_channel_connect_size=<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>ProducerApplication.class</code> 启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserServiceImpl.class</code> 接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RpcProducer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;username &quot;</span> + username + <span class="string">&quot;服务信息: &quot;</span> + RpcPropertiesUtil.getServerPort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置信息</strong></p><p><code>application.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure><p><code>rpc.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># netty 配置</span><br><span class="line">rpc_app_key=test</span><br><span class="line">rpc_server_port=<span class="number">9999</span></span><br><span class="line"># ZK 配置</span><br><span class="line">zk_server=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span></span><br><span class="line">rpc_session_timeout=<span class="number">3000</span></span><br><span class="line">rpc_connection_timeout=<span class="number">3000</span></span><br><span class="line">rpc_channel_connect_size=<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p>分别启动服务端和客户端，然后请求 <a href="http://127.0.0.1:8082/user/getUser/testdemo">http://127.0.0.1:8082/user/getUser/</a>simon, 可以查看结果</p><p><img src="/../images/23.12.13/1.png" alt="Untitled"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<strong>如何开发一个自己的 RPC 框架</strong>就全部完成了，框架的内容非常粗糙，距离真正商用版本还差很多距离。但是通过参考别人的源码，可以理解一个基础的 RPC 框架的大体结构和所需要用到的知识，包括 Netty、Spring 、序列化、负载均衡策略、 zookeeper、 Java 的反射等等。但不管怎么说，有进步就是一件很快乐的事情！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何开发一个自己的-RPC-框架（三）&quot;&gt;&lt;a href=&quot;#如何开发一个自己的-RPC-框架（三）&quot; class=&quot;headerlink&quot; title=&quot;如何开发一个自己的 RPC 框架（三）&quot;&gt;&lt;/a&gt;如何开发一个自己的 RPC 框架（三）&lt;/h1&gt;&lt;p&gt;之前的两篇文章中，已经介绍了实现一个 RPC 框架所需要的客户端和注册中心逻辑，那么这一章，将主要介绍如何实现 RPC 框架中的服务端(服务提供方) 和完善框架的其他补充逻辑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://blog.simoncode.top/tags/Java/"/>
    
    <category term="框架" scheme="http://blog.simoncode.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Rpc" scheme="http://blog.simoncode.top/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一个自己的 RPC 框架 (二)</title>
    <link href="http://blog.simoncode.top/2023/12/12/28-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%BA%8C)/"/>
    <id>http://blog.simoncode.top/2023/12/12/28-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%BA%8C)/</id>
    <published>2023-12-12T07:07:51.000Z</published>
    <updated>2023-12-13T06:18:30.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何开发一个自己的-RPC-框架-二"><a href="#如何开发一个自己的-RPC-框架-二" class="headerlink" title="如何开发一个自己的 RPC 框架 (二)"></a>如何开发一个自己的 RPC 框架 (二)</h1><p>上篇文章中，从客户端的调用流程，详细的了解了各个环节的数据是如何串联起来的。那么本章内容，将主要从注册中心的角度出发，看看注册中心是如何维护客户端和服务端各自上报的信息。</p><span id="more"></span><p>能够作为注册中心的中间件非常多，常见的比如 <a href="https://zookeeper.apache.org/">ZooKeeper</a>、<a href="https://www.consul.io/">Consul</a>、<a href="https://nacos.io/en-us/">Nacos</a> 等，本项目中采用的是  Zookeeper 作为注册中心中间件</p><h2 id="功能梳理"><a href="#功能梳理" class="headerlink" title="功能梳理"></a>功能梳理</h2><p>同样，开始之前我们先来理一下注册中心主要实现那些功能</p><pre class="mermaid">flowchart TD    注册中心 --> 维护服务提供方节点信息    注册中心 --> 维护服务消费方节点信息    注册中心 --> 服务消费方服务信息订阅</pre><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>定义一个名为 <code>IRegisterCenter</code> 的接口，其中接口主要实现如下功能：</p><ol><li>服务提供方的节点上报</li><li>服务提供方节点信息更新</li><li>服务提供方的本地数据缓存和节点信息订阅</li><li>服务消费方根据服务名获取节点地址</li><li>服务消费方订阅服务节点信息</li><li>服务消费方信息注册</li></ol><p>有了上面 6 大需求，就可以知道接口接口中主要包含的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRegisterCenter.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRegisterCenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方节点注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(List&lt;Producer&gt; producerList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方获取节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, List&lt;Producer&gt;&gt; <span class="title function_">getProducersMap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方服务销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方初始化服务节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAppKey 服务提供者唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName    服务组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initProviderMap</span><span class="params">(String remoteAppKey, String groupName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方获取所有节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Producer&gt; <span class="title function_">getServiceNode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方获取节点信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName  服务方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Producer&gt; <span class="title function_">getServiceProducer</span><span class="params">(String serviceName, String methodName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务消费者信息 用于监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerConsumer</span><span class="params">(Consumer consumer)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h2><p>注册中心的接口定义完成之后，就需要使用 zookeeper 进行接口实现。但是在接口实现之前，需要实现一个帮助方法读取 RPC 框架的相关配置项。</p><p>根据前面的设计，可以大概罗列一下需要用到的配置参数</p><ol><li>appkey: 服务的唯一标识</li><li>groupName: 服务的分组名称</li><li>zookServer: zk 中间件服务地址</li><li>nettyIp: 服务提供方调用地址</li><li>nettyPort: 服务提供方调用端口</li></ol><p>当然还包含一些其他参数，比如服务调用超时时间、服务会话超时时间等</p><p>完成上面需求整理之后，就可以开始 <code>RpcPropertiesUtil</code> 方法的编写了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcPropertiesUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROPERTIES_FILE_NAME</span> <span class="operator">=</span> <span class="string">&quot;rpc.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PRODUCER_MAP = Maps.newConcurrentMap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadAllProperties(PROPERTIES_FILE_NAME);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                PRODUCER_MAP.put(entry.getKey().toString(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;读取配置文件异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Producer Load Properties Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从环境变量读取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Map&lt;String, Object&gt; map, String key, String defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">envKey</span> <span class="operator">=</span> System.getenv().get(key.toUpperCase());</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> envKey != <span class="literal">null</span> ? envKey : MapUtils.getString(map, key);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.isEmpty(result) ? defaultValue : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Map&lt;String, Object&gt; map, String key, Integer defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">envKey</span> <span class="operator">=</span> System.getenv().get(key.toUpperCase());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> envKey != <span class="literal">null</span> ? Integer.parseInt(envKey) : MapUtils.getInteger(map, key);</span><br><span class="line">        <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span>= <span class="literal">null</span> ? defaultValue : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义一个 <code>PRODUCER_MAP</code> 用来做配置文件缓存</li><li>static 静态方法中，读取 <code>[rpc.properties](http://rpc.properties)</code> 配置文件，转换成 Map</li><li>定义了两个 <code>getString</code> 和 <code>getInteger</code> 的方法，表示先从环境变量中读取配置，不存在时从配置文件中读取</li></ol><p>完成上述基础编写之后，实例一个 <code>rpc_app_key</code> 的读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAppKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getString(PRODUCER_MAP, <span class="string">&quot;rpc_app_key&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="zookeeper-接口实现"><a href="#zookeeper-接口实现" class="headerlink" title="zookeeper 接口实现"></a>zookeeper 接口实现</h2><p>由于接口的方法都已经定义完成，只需要根据接口的方法含义，进行对应的实现即可</p><p>定义一个类 <code>IRegisterCenterZkImpl</code> 实现 <code>IRegisterCenter</code> 接口</p><h3 id="成员变量介绍"><a href="#成员变量介绍" class="headerlink" title="成员变量介绍"></a>成员变量介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IRegisterCenterZkImpl</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IRegisterCenterZkImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ZkClient</span> <span class="variable">zkClient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK 相关信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ADDRESS</span> <span class="operator">=</span> RpcPropertiesUtil.getZkServers();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ZK_SESSION_TIMEOUT</span> <span class="operator">=</span> RpcPropertiesUtil.getSessionTimeout();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ZK_CONNECTION_TIMEOUT</span> <span class="operator">=</span> RpcPropertiesUtil.getConnectionTimeout();</span><br><span class="line">    <span class="comment">// 本地服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCAL_IP</span> <span class="operator">=</span> RpcPropertiesUtil.getServerIp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务缓存(服务端缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; PROVIDER_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 服务缓存(客户端缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; SERVICE_METADATA = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK 的服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/config_register&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROVIDER_TYPE</span> <span class="operator">=</span> <span class="string">&quot;/provider&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSUMER_TYPE</span> <span class="operator">=</span> <span class="string">&quot;/consumer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name to bean map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_BEAN_MAP = Maps.newConcurrentMap();</span><br></pre></td></tr></table></figure><h3 id="register-方法实现"><a href="#register-方法实现" class="headerlink" title="register 方法实现"></a>register 方法实现</h3><p><code>register</code> 应该是整个注册中心最重要的方法了，他主要目的是接收服务提供方的节点信息上报</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(List&lt;Producer&gt; producerList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(producerList)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;RegisterCenterImpl registerProvider providers is empty, ignore it, providers=&#123;&#125;&quot;</span>, producerList);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (IRegisterCenterZkImpl.class) &#123;</span><br><span class="line">            <span class="comment">// 初始化 zk 客户端</span></span><br><span class="line">            <span class="number">1</span>️⃣ <span class="built_in">this</span>.initZkClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地缓存</span></span><br><span class="line">            <span class="number">2</span>️⃣ <span class="built_in">this</span>.setLocalCache(producerList);</span><br><span class="line">            <span class="number">3</span>️⃣ <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Producer&gt;&gt; entry : PROVIDER_MAP.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                List&lt;Producer&gt; producers = entry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                <span class="type">Producer</span> <span class="variable">firstProducer</span> <span class="operator">=</span> producers.get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">appKey</span> <span class="operator">=</span> firstProducer.getAppKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">rootNode</span> <span class="operator">=</span> getRootPath(appKey);</span><br><span class="line">               <span class="number">4</span>️⃣ <span class="built_in">this</span>.createRootNode(rootNode);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务组名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> firstProducer.getGroupName();</span><br><span class="line">                <span class="comment">// 创建服务提供者节点</span></span><br><span class="line">              <span class="number">5</span>️⃣  <span class="type">String</span> <span class="variable">servicePath</span> <span class="operator">=</span> getProducerServicePath(appKey, groupName, serviceName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Producer producer : producers) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.createServiceNode(servicePath);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">producerMathodPath</span> <span class="operator">=</span> producerToPath(servicePath, producer);</span><br><span class="line">                <span class="number">6</span>️⃣  <span class="built_in">this</span>.createCurrentServiceIpNode(producerMathodPath);</span><br><span class="line">                    log.debug(<span class="string">&quot;create current service node success, node path = &#123;&#125; ,method path = &#123;&#125;&quot;</span>, servicePath, producerMathodPath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本地监听</span></span><br><span class="line">                <span class="number">7</span>️⃣ subscribeChildChanges(serviceName, servicePath, PROVIDER_MAP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣：本地初始化 zk 的请求客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initZkClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zkClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            zkClient = <span class="keyword">new</span> <span class="title class_">ZkClient</span>(ZK_ADDRESS, ZK_SESSION_TIMEOUT, ZK_CONNECTION_TIMEOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对象定义成员变量 <code>zkClient</code></p><p>2️⃣：设置本地节点缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setLocalCache</span><span class="params">(List&lt;Producer&gt; producerList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Producer producer : producerList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> producer.getServiceItf().getName();</span><br><span class="line">            List&lt;Producer&gt; producerListCache = PROVIDER_MAP.get(name);</span><br><span class="line">            <span class="keyword">if</span> (producerListCache == <span class="literal">null</span>) &#123;</span><br><span class="line">                producerListCache = Lists.newArrayList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producerListCache.add(producer);</span><br><span class="line">            PROVIDER_MAP.put(name, producerListCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>存在本地成员变量 <code>PROVIDER_MAP</code>，其中 Map 的 Key 为服务接口的类名</p><p>3️⃣：根据类名遍历节点信息</p><p>4️⃣：创建根节点信息，根节点地址为 <code>/config_register/&#123;appKey&#125;</code></p><p>5️⃣：根据服务名称创建服务节点信息，服务节点地址为: <code>/config_register/&#123;appKey&#125;/&#123;groupName&#125;/&#123;serviceName&#125;</code> 其中 <code>serviceName</code> 就是服务接口的类名</p><p>6️⃣：根据接口类名创建具体的方法节点信息,其中 <code>producerToPath</code> 方法，主要目的是将 <code>Producer</code> 对象转换成 Zk 的路径信息，其中主要实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">producerToPath</span><span class="params">(String servicePath, Producer producer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servicePath + <span class="string">&quot;/&quot;</span> + producer.getIp() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getPort() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getWeight() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getWorkerThreads() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getMethod().getName() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getGroupName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 返回的地址信息示例如下: <code>/config_register/&#123;appKey&#125;/&#123;groupName&#125;/&#123;serviceName&#125;/127.0.0.1|9999|1|10|get|defaut</code> </p><p><code>127.0.0.1|9999|1|10|get|defaut</code> 这段参数的含义就是：服务地址 + 服务端口 + 权重 + 工作线程数量 + 方法名称 + 服务组名称</p><p><code>createCurrentServiceIpNode</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createCurrentServiceIpNode</span><span class="params">(String currentServiceIpNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(currentServiceIpNode)) &#123;</span><br><span class="line">            <span class="comment">// 临时节点</span></span><br><span class="line">            zkClient.createEphemeral(currentServiceIpNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>7️⃣：服务地址监听</p><p><code>subscribeChildChanges</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribeChildChanges</span><span class="params">(String serviceName, String servicePath, Map&lt;String, List&lt;Producer&gt;&gt; dataMap)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从 zk 中读取路径</span></span><br><span class="line">        <span class="comment">// 2. 根据路径值 反序列化成 producer 对象</span></span><br><span class="line">        <span class="comment">// 3. 将 producer 对象放入 dataMap 中</span></span><br><span class="line">        zkClient.subscribeChildChanges(servicePath, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentChilds == <span class="literal">null</span>) &#123;</span><br><span class="line">                currentChilds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Producer&gt; producers = currentChilds.stream().map(currentChild -&gt; pathToProducer(serviceName, currentChild)).collect(Collectors.toList());</span><br><span class="line">            dataMap.put(serviceName, producers);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="initProviderMap-服务消费方节点获取"><a href="#initProviderMap-服务消费方节点获取" class="headerlink" title="initProviderMap 服务消费方节点获取"></a>initProviderMap 服务消费方节点获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initProviderMap</span><span class="params">(String remoteAppKey, String groupName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(SERVICE_METADATA)) &#123;</span><br><span class="line">            SERVICE_METADATA.putAll(<span class="built_in">this</span>.fetchOrUpdateServiceMetaData(remoteAppKey, groupName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Producer&gt;&gt; <span class="title function_">fetchOrUpdateServiceMetaData</span><span class="params">(String remoteAppKey, String groupName)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; providerServiceMap = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.initZkClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据分组获取服务提供方的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">providerNode</span> <span class="operator">=</span> getRootPath(remoteAppKey) + UrlConstants.SLASH + groupName;</span><br><span class="line">        <span class="comment">// 获取所有 serverName 地址</span></span><br><span class="line">       <span class="number">1</span>️⃣ List&lt;String&gt; producerServices = zkClient.getChildren(providerNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String serviceName : producerServices) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">servicePath</span> <span class="operator">=</span> getProducerServicePath(remoteAppKey, groupName, serviceName);</span><br><span class="line">            <span class="number">2</span>️⃣ List&lt;String&gt; producerPaths = zkClient.getChildren(servicePath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取所有 producer 地址(method)</span></span><br><span class="line">            <span class="keyword">for</span> (String producerPath : producerPaths) &#123;</span><br><span class="line">              <span class="number">3</span>️⃣  <span class="type">Producer</span> <span class="variable">pathToProducer</span> <span class="operator">=</span> pathToProducer(serviceName, producerPath);</span><br><span class="line">                List&lt;Producer&gt; providerList = providerServiceMap.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (providerList == <span class="literal">null</span>) &#123;</span><br><span class="line">                    providerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                providerList.add(pathToProducer);</span><br><span class="line">            <span class="number">4</span>️⃣     providerServiceMap.put(serviceName, providerList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="number">5</span>️⃣ subscribeChildChanges(serviceName, servicePath, SERVICE_METADATA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> providerServiceMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1️⃣：根据 <code>appKey</code> 和 <code>groupName</code> 从 zk 中查询注册的所有服务节点</p><p>2️⃣：根据 <code>serviceName</code> 获取该服务下的所有节点信息</p><p>3️⃣：使用 <code>pathToProducer</code> 将 zk 的 path 信息，转换成 <code>Producer</code> 对象</p><p>4️⃣：将节点信息缓存到本地</p><p>5️⃣：和服务提供方注册类似，订阅服务下方节点变化，然后刷新本地 <code>Map</code></p><h3 id="getServiceProducer-服务消费方获取服务节点"><a href="#getServiceProducer-服务消费方获取服务节点" class="headerlink" title="getServiceProducer 服务消费方获取服务节点"></a>getServiceProducer 服务消费方获取服务节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Producer&gt; <span class="title function_">getServiceProducer</span><span class="params">(String serviceName, String methodName)</span> &#123;</span><br><span class="line">        List&lt;Producer&gt; producers = SERVICE_METADATA.get(serviceName);</span><br><span class="line">        <span class="type">return</span> <span class="variable">producers</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="literal">null</span> :</span><br><span class="line">                producers.stream().filter(producer -&gt;</span><br><span class="line">                        producer.getMethod() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                producer.getMethod().getName().equals(methodName)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的实现代码就非常简单了，只需要遍历本地缓存的 SERVICE_METADATA 对象即可</p><p>由于其他方法的操作都是对本地缓存 <code>Map</code> 的操作，所以这里就不再详细展开了</p><p>到这里，已经完成了注册中心最重要方法编写，处理服务提供方的服务注册，和服务消费放的服务节点订阅。</p><p>下一章我们将完成服务提供方节点信息的注册和 <code>Netty</code> 消息的处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何开发一个自己的-RPC-框架-二&quot;&gt;&lt;a href=&quot;#如何开发一个自己的-RPC-框架-二&quot; class=&quot;headerlink&quot; title=&quot;如何开发一个自己的 RPC 框架 (二)&quot;&gt;&lt;/a&gt;如何开发一个自己的 RPC 框架 (二)&lt;/h1&gt;&lt;p&gt;上篇文章中，从客户端的调用流程，详细的了解了各个环节的数据是如何串联起来的。那么本章内容，将主要从注册中心的角度出发，看看注册中心是如何维护客户端和服务端各自上报的信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://blog.simoncode.top/tags/Java/"/>
    
    <category term="框架" scheme="http://blog.simoncode.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Rpc" scheme="http://blog.simoncode.top/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一个自己的 RPC 框架 (一)</title>
    <link href="http://blog.simoncode.top/2023/12/11/27-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%80)/"/>
    <id>http://blog.simoncode.top/2023/12/11/27-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%80)/</id>
    <published>2023-12-11T08:10:59.000Z</published>
    <updated>2024-01-19T03:22:08.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何开发一个自己的-RPC-框架-一"><a href="#如何开发一个自己的-RPC-框架-一" class="headerlink" title="如何开发一个自己的 RPC 框架 (一)"></a>如何开发一个自己的 RPC 框架 (一)</h1><p>写在前面：本文参考了开源项目 <a href="https://github.com/MIracleCczs/simple-rpc%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%A4%A7%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E4%BA%86%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BA%E5%8F%91%EF%BC%8C%E8%AE%B2%E8%AE%B2%E4%B8%80%E4%B8%AA">https://github.com/MIracleCczs/simple-rpc，其中大部分代码参考了该项目，本章主要从客户端的调用出发，讲讲一个</a> RPC 框架的实现在客户端测需要实现那些功能</p><span id="more"></span><h2 id="RPC-的定义"><a href="#RPC-的定义" class="headerlink" title="RPC 的定义"></a>RPC 的定义</h2><p>可以参考 wiki: <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">https://zh.wikipedia.org/wiki/遠程過程調用</a></p><h2 id="一个简单的-RPC-框架是如何组成的"><a href="#一个简单的-RPC-框架是如何组成的" class="headerlink" title="一个简单的 RPC 框架是如何组成的?"></a>一个简单的 RPC 框架是如何组成的?</h2><p>一个基础的 RPC 框架，需要包含三大部分：1. 注册中心 2.服务提供方 3.服务消费方</p><pre class="mermaid">graph LR注册中心 --> 服务提供方注册中心 --> 服务消费方</pre><p>从上图可以看出，服务提供方和消费方都需要和注册中心通信</p><h2 id="一个远程方法的调用是如何实现的？"><a href="#一个远程方法的调用是如何实现的？" class="headerlink" title="一个远程方法的调用是如何实现的？"></a>一个远程方法的调用是如何实现的？</h2><pre class="mermaid">stateDiagram-v2    [*] --> 客户端发起服务调用    客户端发起服务调用 --> 根据类名+方法名查询服务节点(Producer)    根据类名+方法名查询服务节点(Producer) --> 根据节点获取本地Netty连接(channel)    根据节点获取本地Netty连接(channel) --> 向服务方发送调用请求(NettyRequest)    向服务方发送调用请求(NettyRequest) --> 服务方接收请求根据类名进行反射调用    服务方接收请求根据类名进行反射调用 --> 根据方法返回值构造返回结果(NettyResponse)    根据方法返回值构造返回结果(NettyResponse) --> 客户端获取返回结果(调用结束)    客户端获取返回结果(调用结束) --> [*]</pre><p>下面，我们将根据上面流程图，一步步进行讲解。为了方便更加清楚的讲清整个逻辑，我们从实际的业务需求出发。</p><p><strong>需求：</strong></p><p>存在服务提供方 Producer(后面统称服务端)，提供方法 <code>get</code>   </p><p>存在服务消费方 Consumer(后面统称客户端),需要调用 Producer 中的 <code>get</code> 方法</p><pre class="mermaid">sequenceDiagram    客户端 ->>服务端: get 方法调用    服务端 ->>客户端: 返回 get 方法执行结果</pre><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p><code>pom.xml</code> 依赖</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--spring--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.2</span><span class="number">.9</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- zookeeper --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.7</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- zkclient --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">0.11</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.18</span><span class="number">.18</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--guava--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">24.1</span><span class="number">.1</span>-jre&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- common --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.2</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><p><code>zookeeper</code> 安装 <code>Docker</code> 安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -p <span class="number">2181</span>:<span class="number">2181</span> -v $PWD/data:/data --name zookeeper  zookeeper</span><br></pre></td></tr></table></figure><h2 id="基础接口定义"><a href="#基础接口定义" class="headerlink" title="基础接口定义"></a>基础接口定义</h2><p>定义 <code>UserService</code> 接口，接口内包含 <code>get</code>  方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    String <span class="title function_">get</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端发起服务调用"><a href="#客户端发起服务调用" class="headerlink" title="客户端发起服务调用"></a>客户端发起服务调用</h2><h3 id="客户端注解定义"><a href="#客户端注解定义" class="headerlink" title="客户端注解定义"></a>客户端注解定义</h3><p>客户端如何才能够像调用本地方法一样调用远程服务呢？RPC 框架就是用来解决这个问题。我们一般本地方法的调用都是采用 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>通过 <code>Spring</code> 依赖注入的方式，将需要用到的方法注入到调用对象中，那么我们 RPC 调用能不能也采用这种形式呢？答案当然是可以的。那么为了实现上面的需求，我们最简单的办法就是自定义一个注解 <code>RpcClient</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcClient &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解定义完成后，我们就应该考虑注解中需要设置那些属性呢？</p><p>那么冒出来的第一个问题就是：客户端如何知道是调用的那个远程服务呢？这时我们就需要设置第一个属性 <code>remoteAppKey</code> 服务的唯一标识，通过 <code>remoteAppKey</code> 客户端可以轻松地在注册中心找到目标服务。</p><p>这个时候又会有第二个疑问，如果一个服务多个版本如何处理呢？比如进行灰度升级等操作的时，那么这个时候就需要第二个参数 <code>groupName</code> 找到具体服务下的具体分组</p><p>剩余的参数就比较简单了，完成的参数配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务接口:匹配从注册中心获取到本地的服务提供者，得到服务提供者列表，再根据负载均衡策略选取一个发起服务调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Class&lt;?&gt; targetItf() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 超时时间：服务调用超时时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">long</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3000</span> * <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 调用者线程数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">consumeThreads</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务提供者唯一标识</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> String <span class="title function_">remoteAppKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务分组组名</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> String <span class="title function_">groupName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h3><p>为了实现类似 <code>@Autowired</code> 的功能，框架需要在 <code>Bean</code> 初始化之时，将所有被 <code>RpcClient</code> 注解的对象进行依赖注入，那么如何实现这个功能呢？ <code>Spring</code> 的 <strong><code>InstantiationAwareBeanPostProcessor</code></strong> 接口，可以在 Bean 的实例化的各个阶段执行自定义逻辑。定义一个 <code>ConsumerAnnotaionBean</code> 方法，实现 <code>InstantiationAwareBeanPostProcessor</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAnnotaionBean</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line">...其他方法省略</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要实现接口的 <code>postProcessProperties</code> 方法，设置 Bean 对象的属性值</p><p>进行具体代码编写之前，我们需要先理清楚这里需要实现那些目的：</p><ol><li>客户端服务注册(监控目的)</li><li>对象依赖的注入</li><li>查询服务节点，预创建 Netty 连接</li></ol><p>好了，理清楚完需求之后，我们便开始对应的逻辑编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">        <span class="comment">// 依赖注入的服务</span></span><br><span class="line">        Field[] fields = beanClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="type">RpcClient</span> <span class="variable">rpcClient</span> <span class="operator">=</span> field.getAnnotation(RpcClient.class);</span><br><span class="line">            <span class="keyword">if</span> (rpcClient == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 根据初始化的 <code>bean</code> 获取对象中的所有参数，然后使用 <code>getAnnotation(RpcClient.class);</code> 判断参数是否被 <code>RpcClient</code> 所注解</p><h3 id="客户端服务注册"><a href="#客户端服务注册" class="headerlink" title="客户端服务注册"></a>客户端服务注册</h3><p>这一步的目的是为了在注册中心中记录消费者信息，方便后续监控，所以这一步相对来说非常简单，只需要构造客户端信息然后提交到注册中心即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造消费者对象</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> Consumer</span><br><span class="line">                    .builder()</span><br><span class="line">                    .groupName(rpcClient.groupName())</span><br><span class="line">                    .remoteAppKey(rpcClient.remoteAppKey())</span><br><span class="line">                    .targetItf(targetItf)</span><br><span class="line">                    .build();</span><br><span class="line"><span class="comment">// 注册中心注册消费者</span></span><br><span class="line">registerCenter.registerConsumer(consumer);</span><br></pre></td></tr></table></figure><h3 id="对象依赖的注入"><a href="#对象依赖的注入" class="headerlink" title="对象依赖的注入"></a>对象依赖的注入</h3><p>同样的，我们先梳理一下这里的需求。我们需要实现一个动态代理，在方法调用时，根据方法调用名+类名获取远程服务提供方的节点信息，然后构造一个 <code>NettyRequest</code> 信息，发送到服务方，最后需要接收服务放返回的 <code>NettyResponse</code> 解析成方法的返回值进行返回</p><pre class="mermaid">stateDiagram-v2    [*] --> 根据类名+方法名获取节点_涉及节点负载均衡    根据类名+方法名获取节点_涉及节点负载均衡 --> 根据节点Ip和端口获取Netty的Channel    根据节点Ip和端口获取Netty的Channel --> 发送NettyRequest请求携带方法参数    发送NettyRequest请求携带方法参数 --> 获取服务端详情结果(NettyResponse)    获取服务端详情结果(NettyResponse) --> 反序列化成方法的出参    反序列化成方法的出参 --> 方法反射/远程调用完成    方法反射/远程调用完成 --> [*]</pre><p>好了，我们已经理清楚了上面整体流程，那么就开始具体的代码编写吧</p><p>首先，定义一个对象 <code>ClientProxyBeanFactory</code> 实现 <code>InvocationHandler</code> 接口</p><p>主要是实现接口的 <code>invoke</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>invoke</code> 方法中，需要根据类名+方法名从注册中心中获取可用的节点，那么具体代理的类这个时候就需要从对象实例化中传入，所以我们在定义 <code>ClientProxyBeanFactory</code> 时，需要定义几个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientProxyBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用连接池(Netty 请求)</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标代理类</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetItf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> consumeThreads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象初始化的时候，需要设置成员变量的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ClientProxyBeanFactory instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientProxyBeanFactory</span><span class="params">(Class&lt;?&gt; targetItf, <span class="type">long</span> timeout, <span class="type">int</span> consumeThreads)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(consumeThreads, consumeThreads,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;simple-rpc-%d&quot;</span>).build(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.targetItf = targetItf;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.consumeThreads = consumeThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;targetItf&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientProxyBeanFactory <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; targetItf, <span class="type">long</span> timeout, <span class="type">int</span> consumeThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ClientProxyBeanFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">ClientProxyBeanFactory</span>(targetItf, timeout, consumeThreads);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完成上述成员变量赋值后，便可以开始从注册中心中获取服务节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerAnnotaionBean.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 代理 className</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> targetItf.getName();</span><br><span class="line"><span class="comment">// 注册中心服务</span></span><br><span class="line">        <span class="type">IRegisterCenter</span> <span class="variable">registerCenter</span> <span class="operator">=</span> IRegisterCenterZkImpl.getInstance();</span><br><span class="line"><span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">        List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到服务节点后，这里可以根据设置的负载均衡策略获取本次使用的节点信息，假设这里采用随机获取的方法获取得到节点 <code>Producer</code></p><p><strong>开启 Netty 连接，进行消息收发送</strong></p><p>拿到了 <code>Producer</code> 就意味着我们可以获取到远程服务 Netty 的 ip + port 信息了，这个时候就可以建立远程服务连接了。但是这里存在一个优化逻辑，就是如果我们每次都是方法调用时再去建立链接，那么建立连接将会是一个非常耗时的操作，但是如果我们提前根据 ip + port 建立一个 <code>Channel</code> 池，方法调用时只需要从连接池中获取 <code>Channel</code> ，那么服务的效率是不是会大大提高了？</p><pre class="mermaid">flowchart TD    A[(Ip+port获取本地缓存Channel)] --> B{是否存在 Channel?}    B -->|存在缓存信息| C[队列获取 Channel]    B ---->|不存在缓存信息| D[建立连接缓存到本地]    D --> B    C --> E[消息发送结束后将 Channel 返回到队列]</pre><p>基于上面的逻辑，我们需要实现一个 <code>NettyChannelPoolFactory</code> 用来缓存客户端的 <code>Netty</code> 的请求缓存，同时对外提供两个方法: <code>acquire</code> 获取 Channel 信息 <code>release</code> 释放 Channel 信息</p><p>具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyChannelPoolFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NettyChannelPoolFactory</span> <span class="variable">CHANNEL_POOL_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyChannelPoolFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池缓存 key 为服务提供者地址，value为Netty Channel阻塞队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;InetSocketAddress, ArrayBlockingQueue&lt;Channel&gt;&gt; CHANNEL_POOL_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Netty Channel阻塞队列的长度，该值为可配置信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">CHANNEL_CONNECT_SIZE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyChannelPoolFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNEL_POOL_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 netty 连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannelFactory</span><span class="params">(List&lt;Producer&gt; producerNodeList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Producer producer : producerNodeList) &#123;</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(producer.getIp(), producer.getPort());</span><br><span class="line">            <span class="keyword">while</span> (CHANNEL_POOL_MAP.get(address) == <span class="literal">null</span> || CHANNEL_POOL_MAP.get(address).size() &lt; CHANNEL_CONNECT_SIZE) &#123;</span><br><span class="line">                ArrayBlockingQueue&lt;Channel&gt; channels = CHANNEL_POOL_MAP.get(address);</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="literal">null</span> || channels.size() &lt; CHANNEL_CONNECT_SIZE) &#123;</span><br><span class="line">                    <span class="comment">// 初始化 Netty Channel 阻塞队列</span></span><br><span class="line">                    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                        channel = registerChannel(address);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (channels == <span class="literal">null</span>) &#123;</span><br><span class="line">                        channels = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(CHANNEL_CONNECT_SIZE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">offer</span> <span class="operator">=</span> channels.offer(channel);</span><br><span class="line">                    <span class="keyword">if</span> (!offer) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;channelArrayBlockingQueue fail&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        CHANNEL_POOL_MAP.put(address, channels);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 address 获取客户端队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayBlockingQueue&lt;Channel&gt; <span class="title function_">acquire</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNEL_POOL_MAP.get(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用完成之后，将 channel 放回到 阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(ArrayBlockingQueue&lt;Channel&gt; queue, Channel channel, InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收之前判断channel 是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span> || !channel.isOpen() || !channel.isActive() || !channel.isWritable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">                channel.deregister().syncUninterruptibly().awaitUninterruptibly();</span><br><span class="line">                channel.closeFuture().syncUninterruptibly().awaitUninterruptibly();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                    channel = registerChannel(address);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.offer(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 netty 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">registerChannel</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.remoteAddress(address);</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 注册Netty编码器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>());</span><br><span class="line">                            <span class="comment">// 注册Netty解码器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(NettyResponse.class));</span><br><span class="line">                            <span class="comment">// 注册客户端业务处理逻辑Handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyHandlerClient</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect().sync();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> List&lt;Boolean&gt; isSuccessHolder = Lists.newArrayListWithCapacity(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 监听channel是否建立成功</span></span><br><span class="line">            channelFuture.addListener(future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    isSuccessHolder.add(Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果建立失败，保存建立失败标记</span></span><br><span class="line">                    log.error(<span class="string">&quot;registerChannel fail , &#123;&#125;&quot;</span>, future.cause().getMessage());</span><br><span class="line">                    isSuccessHolder.add(Boolean.FALSE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 如果Channel建立成功，返回新建的Channel</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(isSuccessHolder.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;registerChannel fail&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NettyChannelPoolFactory</code> 对象中还定义了一个方法 <code>registerChannel</code> 接收 <code>InetSocketAddress</code> 的入参，返回值为 <code>Channel</code> 。方法中主要根据传入的 <code>address</code> 信息，创建了 <code>Netty</code> 连接，设置了序列化和反序列化的编解码器，然后增加了一个 <code>NettyHandlerClient</code> 的客户端消息处理器。最后将初始化好的 <code>Channel</code> 连接进行返回</p><p>有了上面的 <code>NettyChannelPoolFactory</code> ，便可以将从注册中心获得到的 <code>Producer</code> 信息，根据 ip + port 获取 <code>Channel</code> ，从而进行 <code>NettyRequest</code> 消息的发送</p><p><code>**NettyRequest</code> 消息的构造**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">    <span class="comment">// 直接取第0 个，这里可以采用负载均衡策略进行获取</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">providerCopy</span> <span class="operator">=</span>producerList.get(<span class="number">0</span>) ;</span><br><span class="line"><span class="comment">// NettyRequest 构造</span></span><br><span class="line"><span class="type">NettyRequest</span> <span class="variable">request</span> <span class="operator">=</span> NettyRequest.builder()</span><br><span class="line"><span class="comment">// 服务节点信息</span></span><br><span class="line">                .producer(providerCopy)</span><br><span class="line"><span class="comment">// 本次请求的唯一编号</span></span><br><span class="line">                .uniqueKey(UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId())</span><br><span class="line"><span class="comment">// 请求超时时间</span></span><br><span class="line">                .invokeTimeout(timeout)</span><br><span class="line"><span class="comment">// 请求方法名称</span></span><br><span class="line">                .invokeMethodName(method.getName())</span><br><span class="line"><span class="comment">// 请求参数</span></span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在 <code>NettyRequest</code>  和发送消息的 <code>Channel</code> 都已经有了，只需要将消息发送出去，然后接收消息然后序列成方法的出参即可。</p><p>这里可以采用线程池的方式，进行 <code>Netty</code> 消息的发送和返回值的解码</p><p>定义一个 <code>ClientServiceCallable</code> 集成自 <code>Callable&lt;NettyResponse&gt;</code> 带返回值的任务的接口</p><p><code>Callable</code> 只有一个需要实现的方法 <code>call()</code> ,在该方法中，需要完成 1. 获取 <code>Channel</code> 对象 2. 发送请求 3. 结果值返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientServiceCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;NettyResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 通信管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NettyRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientServiceCallable <span class="title function_">of</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientServiceCallable</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientServiceCallable</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> NettyResponse <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(request.getProducer().getIp(), request.getProducer().getPort());</span><br><span class="line">    <span class="comment">// 获取本地缓存 Channel 队列</span></span><br><span class="line">    ArrayBlockingQueue&lt;Channel&gt; blockingQueue = NettyChannelPoolFactory.getInstance().acquire(inetSocketAddress);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从队列中获取 Channel</span></span><br><span class="line">            channel = blockingQueue.take();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can&#x27;t find channel to resolve this request&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;client send request error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 请求结束，队列归还 Channel</span></span><br><span class="line">        NettyChannelPoolFactory.getInstance().release(blockingQueue, channel, inetSocketAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的 <code>call</code> 方法中，首先从本地缓存中获取到了 <code>Channel</code> 队列，然后在 <code>finally</code> 中将 <code>Channel</code> 归还到队列中。那么方法中剩下的逻辑就是发送 <code>NettyRequest</code> 请求，然后返回结果了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                channel = blockingQueue.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can&#x27;t find channel to resolve this request&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="number">1</span>️⃣ ClientResponseHolder.initResponseData(request.getUniqueKey());</span><br><span class="line"></span><br><span class="line">                <span class="number">2</span>️⃣<span class="keyword">while</span> (!channel.isOpen() || !channel.isActive() || !channel.isWritable()) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;retry get new channel&quot;</span>);</span><br><span class="line">                    channel = blockingQueue.poll(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 若队列中没有可用的Channel，则重新注册一个Channel</span></span><br><span class="line">                        channel = NettyChannelPoolFactory.getInstance().registerChannel(inetSocketAddress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将本次调用的信息写入Netty通道，发起异步调用</span></span><br><span class="line">                <span class="number">3</span>️⃣ <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> channel.writeAndFlush(request);</span><br><span class="line">                channelFuture.syncUninterruptibly();</span><br><span class="line">                <span class="comment">// 从返回结果容器中获取返回结果，同时设置等待超时时间为invokeTimeout</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">invokeTimeout</span> <span class="operator">=</span> request.getInvokeTimeout();</span><br><span class="line">                <span class="number">4</span>️⃣ <span class="keyword">return</span> ClientResponseHolder.getValue(request.getUniqueKey(), invokeTimeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client send request error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannelPoolFactory.getInstance().release(blockingQueue, channel, inetSocketAddress);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>1️⃣ <strong>ClientResponseHolder 类</strong></p><p><code>ClientResponseHolder.initResponseData(request.getUniqueKey());</code> 这里又增加了一个新的类<code>ClientResponseHolder</code>,那么这个类是干嘛的呢？</p><p>由于消息的发送都是异步的形式，这里使用了 <code>Map&lt;String,NettyResponseWrapper&gt;</code> 进行本地数据缓存, <code>Map</code> 的 KEY 是 <code>NeettyRequest</code> 的 <code>uniqueKey</code> ，而 <code>Value</code> 就是 <code>Netty</code> 的返回结果，即是服务端执行之后的返回值</p><p><code>ClientResponseHolder</code> 的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientResponseHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, NettyResponseWrapper&gt; RESPONSE_WRAPPER_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">RemoveExpireThreadFactory</span>(<span class="string">&quot;simple-rpc&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 删除过期的数据</span></span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, NettyResponseWrapper&gt; entry : RESPONSE_WRAPPER_MAP.entrySet()) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">expire</span> <span class="operator">=</span> entry.getValue().isExpire();</span><br><span class="line">                <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">                    RESPONSE_WRAPPER_MAP.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">20</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化返回结果容器，requestUniqueKey唯一标识本次调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initResponseData</span><span class="params">(String requestUniqueKey)</span> &#123;</span><br><span class="line">        RESPONSE_WRAPPER_MAP.put(requestUniqueKey, NettyResponseWrapper.of());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Netty调用异步返回结果放入阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putResultValue</span><span class="params">(NettyResponse response)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">NettyResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> RESPONSE_WRAPPER_MAP.get(response.getUniqueKey());</span><br><span class="line">        responseWrapper.setResponseTime(currentTimeMillis);</span><br><span class="line">        responseWrapper.getResponseBlockingQueue().add(response);</span><br><span class="line">        RESPONSE_WRAPPER_MAP.put(response.getUniqueKey(), responseWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从阻塞队列中获取异步返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyResponse <span class="title function_">getValue</span><span class="params">(String requestUniqueKey, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">NettyResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> RESPONSE_WRAPPER_MAP.get(requestUniqueKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> responseWrapper.getResponseBlockingQueue().poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;get value error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RESPONSE_WRAPPER_MAP.remove(requestUniqueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>initResponseData: 根据 <code>uniqueKey</code> 初始化 <code>Map</code></li><li>putResultValue: 插入 <code>NettyResponse</code> 返回结果</li><li>getValue: 根据 <code>uniqueKey</code> 获取结果</li></ul><p>同时定义了一个定时执行的队列，队列中根据 <code>responseTime</code> 判断消息是否过期进行内存数据清洗</p><p>2️⃣ Channel 状态判断</p><p>判断当前 <code>Netty</code> 通道状态，如果当前 <code>Channel</code> 不可用，则需要重新申请通道</p><p>3️⃣ Netty 消息发送</p><p>4️⃣ 从本地缓存中获取 Netty 返回结果</p><p><strong>异步调用 Netty 服务，使用 <code>Future</code> 获取返回结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">    <span class="comment">// 直接取第0 个，这里可以采用负载均衡策略进行获取</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">providerCopy</span> <span class="operator">=</span>producerList.get(<span class="number">0</span>) ;</span><br><span class="line"><span class="comment">// NettyRequest 构造</span></span><br><span class="line"><span class="type">NettyRequest</span> <span class="variable">request</span> <span class="operator">=</span> NettyRequest.builder()</span><br><span class="line"><span class="comment">// 服务节点信息</span></span><br><span class="line">                .producer(providerCopy)</span><br><span class="line"><span class="comment">// 本次请求的唯一编号</span></span><br><span class="line">                .uniqueKey(UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId())</span><br><span class="line"><span class="comment">// 请求超时时间</span></span><br><span class="line">                .invokeTimeout(timeout)</span><br><span class="line"><span class="comment">// 请求方法名称</span></span><br><span class="line">                .invokeMethodName(method.getName())</span><br><span class="line"><span class="comment">// 请求参数</span></span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 发起异步调用,通过 NettyClient 发送请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;NettyResponse&gt; responseFuture = executorService.submit(ClientServiceCallable.of(request));</span><br><span class="line">            <span class="type">NettyResponse</span> <span class="variable">response</span> <span class="operator">=</span> responseFuture.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.getResult();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;send request error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就完成了 <code>ClientProxyBeanFactory</code> 代理对象的完整编写，现在就需要将初始化好的代理对象进行依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerAnnotaionBean.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 代理 className</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> targetItf.getName();</span><br><span class="line"><span class="comment">// 注册中心服务</span></span><br><span class="line">        <span class="type">IRegisterCenter</span> <span class="variable">registerCenter</span> <span class="operator">=</span> IRegisterCenterZkImpl.getInstance();</span><br><span class="line"><span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">        List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line"><span class="comment">// 3.获取服务代理对象</span></span><br><span class="line">            Class&lt;?&gt; targetItf = rpcClient.targetItf();</span><br><span class="line">            <span class="keyword">if</span> (targetItf == Object.class) &#123;</span><br><span class="line">                targetItf = field.getType();</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 初始化代理对象</span></span><br><span class="line"><span class="type">ClientProxyBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> ClientProxyBeanFactory.getInstance(targetItf, rpcClient.timeout(), rpcClient.consumeThreads());</span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置代理对象</span></span><br><span class="line">                field.set(bean, factory.getProxy());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;ReferenceBeanPostProcessor post process properties error, beanName=&#123;&#125;&quot;</span>, beanName, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ReferenceBeanPostProcessor post process properties error, beanName=&quot;</span> + beanName, e);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>ClientProxyBeanFactory.getInstance</code> 获取到代理对象后，使用 <code>field.set</code> 方法进行执行赋值</p><p>完成上述操作之后，当客户端执行 <code>get</code> 方法时，便会 <code>invoke</code> 到 <code>ClientProxyBeanFactory</code> 的 <code>invoke</code> 方法上，随后执行 <strong>开启 Netty 连接，进行消息收发送</strong> 内容，随后将服务方结果进行返回</p><h3 id="查询服务节点，预创建-Netty-连接"><a href="#查询服务节点，预创建-Netty-连接" class="headerlink" title="查询服务节点，预创建 Netty 连接"></a>查询服务节点，预创建 Netty 连接</h3><p>这部分内容和第二步有所重叠，其核心逻辑如下：</p><pre class="mermaid">sequenceDiagram    客户端->>注册中心: 1️⃣查询所有用到的服务    客户端->>服务提供方: 2️⃣预建立 Netty 请求，建立通道池</pre><p>到这里，客户端的所有流程就都编写完成了。但是为了理清楚主要思路，文章中对负载均衡策略、序列化和反序列化等都只是一笔带过。这些也是一个 RPC 框架非常很重要的一部分。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何开发一个自己的-RPC-框架-一&quot;&gt;&lt;a href=&quot;#如何开发一个自己的-RPC-框架-一&quot; class=&quot;headerlink&quot; title=&quot;如何开发一个自己的 RPC 框架 (一)&quot;&gt;&lt;/a&gt;如何开发一个自己的 RPC 框架 (一)&lt;/h1&gt;&lt;p&gt;写在前面：本文参考了开源项目 &lt;a href=&quot;https://github.com/MIracleCczs/simple-rpc%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%A4%A7%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E4%BA%86%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BA%E5%8F%91%EF%BC%8C%E8%AE%B2%E8%AE%B2%E4%B8%80%E4%B8%AA&quot;&gt;https://github.com/MIracleCczs/simple-rpc，其中大部分代码参考了该项目，本章主要从客户端的调用出发，讲讲一个&lt;/a&gt; RPC 框架的实现在客户端测需要实现那些功能&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://blog.simoncode.top/tags/Java/"/>
    
    <category term="框架" scheme="http://blog.simoncode.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Rpc" scheme="http://blog.simoncode.top/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>2021总结</title>
    <link href="http://blog.simoncode.top/2022/02/07/26-2021%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2022/02/07/26-2021%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-07T01:30:30.000Z</published>
    <updated>2022-02-07T04:10:49.512Z</updated>
    
    <content type="html"><![CDATA[<p> 今天是 2022 年的第一个工作日，趁着上班的时间，总结一下过去的一年。</p> <span id="more"></span><p> 2021 年总体来说是比较顺利的一年，这年间我也完成了人生中的一件大事-买房，也算是给kiko和自己在南京有了个交代。其实就我个人来说对于买房的欲望没有那么强烈，我觉得在武汉买房可能是一个更好的选择，但是生活就是妥协的艺术，既然选择了后面在南京发展，在南京买房也不是一个坏事。能够在南京买房也只能说是机缘凑巧，三月份的时候朋友推荐了一个数字货币，东拼西凑买了5k试试，没想到人生第一次中这么大的运气，后面这个数字货币涨了很多倍，这部分赚的钱也作为了买房的启动资金。</p><p> <img src="https://static.simoncode.top/static/20220207/IMG_1681.jpg"></p><p> 年中的时候，疫情好像还没有那么严重，感觉那时候只要想出去旅游就都可以去，所以和kiko约着五一乘着回家的功夫去一趟长沙，其实说起长沙我也是一直都想去的，大学的时候就想着去一趟，但时候那时候经济条件有限没去成。这次的长沙之旅也是比较圆满的，大部分有名的景点都去过了，也拍了不少照片，当然茶颜悦色也是每天一杯（甚至两倍），唯一比较遗憾的可能就会没怎么吃到湘菜(五一的人实在是太多了)。</p><p> <img src="https://static.simoncode.top/static/20220207/IMG_1107.jpg"><br> <img src="https://static.simoncode.top/static/20220207/IMG_1017.jpg"></p><p> 2021年的后半段就比较中规中矩了，安安静静的上班，当然这中间也接了两个私活，总体感觉也不错，都是我之前未曾涉及的领域，挣钱的同时也学习了很多新的知识。</p><p>总的来说，这一年还是好的事情比坏的事情要多，和kiko的关系还是感觉和热恋一样，芙芙也是越吃越肥(当然我也是)。</p><p><img src="https://static.simoncode.top/static/20220207/IMG_0455.jpg"><br><img src="https://static.simoncode.top/static/20220207/IMG_2428.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 今天是 2022 年的第一个工作日，趁着上班的时间，总结一下过去的一年。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2021" scheme="http://blog.simoncode.top/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 GitHub 的 Actions 实现项目的 CI/CD</title>
    <link href="http://blog.simoncode.top/2020/06/21/25-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-GitHub-%E7%9A%84-Actions-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84-CI-CD/"/>
    <id>http://blog.simoncode.top/2020/06/21/25-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-GitHub-%E7%9A%84-Actions-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84-CI-CD/</id>
    <published>2020-06-21T10:07:43.000Z</published>
    <updated>2023-12-12T06:27:12.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD"><a href="#如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD" class="headerlink" title="如何使用 GitHub 的 Actions 实现项目的 CI&#x2F;CD"></a>如何使用 GitHub 的 Actions 实现项目的 CI&#x2F;CD</h1><p>GitHub 的 actions，提供了一整套的任务流，能够帮助我们实现项目的自动自动测试和自动部署。本篇主要是将我使用 github 的 actions 实现项目的自动部署，其中项目主要是 java + vue</p><span id="more"></span><h2 id="Java-项目部署"><a href="#Java-项目部署" class="headerlink" title="Java 项目部署"></a>Java 项目部署</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>1、jdk<br>2、maven<br>3、ssh</p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="1-创建项目-省略"><a href="#1-创建项目-省略" class="headerlink" title="1 创建项目(省略)"></a>1 创建项目(省略)</h4><h4 id="2-添加-workflow-文件"><a href="#2-添加-workflow-文件" class="headerlink" title="2 添加 workflow 文件"></a>2 添加 workflow 文件</h4><p>在项目的根目录下，创建 .github&#x2F;workflows 文件夹<br>新建 build.yml 文件</p><h4 id="3、编写服务流程"><a href="#3、编写服务流程" class="headerlink" title="3、编写服务流程"></a>3、编写服务流程</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This workflow will build a Java project with Maven</span></span><br><span class="line"><span class="comment"># For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">Ci</span> <span class="comment"># 流名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ] <span class="comment"># 目标分支</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span>  <span class="comment"># JDK 环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">1.8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">Maven</span> <span class="string">packages</span> <span class="comment"># maven 缓存</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">~/.m2</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-m2-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/pom.xml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-m2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Maven</span> <span class="string">Build</span> <span class="comment"># build 打包</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">package</span>   <span class="string">-DskipTests</span> <span class="string">--file</span> <span class="string">pom.xml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">server</span> <span class="comment"># 发布到服务器上</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.1.2</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&quot;-avz --delete&quot;</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">target/wkserver-0.0.1-SNAPSHOT.jar</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">/home/yiliaofeiwu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">server</span>  <span class="comment"># 执行部署后的命令</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">nohup</span> <span class="string">sh</span> <span class="string">/home/yiliaofeiwu/reload.sh</span></span><br></pre></td></tr></table></figure><p>其中 <code>REMOTE_HOST</code>、<code>REMOTE_USER</code>、<code>SSH_PRIVATE_KEY</code> 为服务器相关配置，使用 github 的secrets 配置。[项目]-&gt;[setting]-&gt;[secrets] 进行配置</p><h2 id="Vue-项目部署"><a href="#Vue-项目部署" class="headerlink" title="Vue 项目部署"></a>Vue 项目部署</h2><h3 id="环境依赖-1"><a href="#环境依赖-1" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>1、nodejs<br>2、ssh</p><h3 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="1-创建项目-省略-1"><a href="#1-创建项目-省略-1" class="headerlink" title="1 创建项目(省略)"></a>1 创建项目(省略)</h4><h4 id="2-添加-workflow-文件-1"><a href="#2-添加-workflow-文件-1" class="headerlink" title="2 添加 workflow 文件"></a>2 添加 workflow 文件</h4><p>在项目的根目录下，创建 .github&#x2F;workflows 文件夹<br>新建 build.yml 文件</p><h4 id="3、编写服务流程-1"><a href="#3、编写服务流程-1" class="headerlink" title="3、编写服务流程"></a>3、编写服务流程</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span> <span class="string">web</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span> </span><br><span class="line">  <span class="attr">build:</span> </span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">Node.js</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">10</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 部署到腾讯云服务器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.0.7</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">            <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">ARGS:</span> <span class="string">&quot;-avz --delete&quot;</span></span><br><span class="line">            <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">SOURCE:</span> <span class="string">dist/</span></span><br><span class="line">            <span class="attr">TARGET:</span> <span class="string">/home/wuyuan</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD&quot;&gt;&lt;a href=&quot;#如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD&quot; class=&quot;headerlink&quot; title=&quot;如何使用 GitHub 的 Actions 实现项目的 CI&amp;#x2F;CD&quot;&gt;&lt;/a&gt;如何使用 GitHub 的 Actions 实现项目的 CI&amp;#x2F;CD&lt;/h1&gt;&lt;p&gt;GitHub 的 actions，提供了一整套的任务流，能够帮助我们实现项目的自动自动测试和自动部署。本篇主要是将我使用 github 的 actions 实现项目的自动部署，其中项目主要是 java + vue&lt;/p&gt;</summary>
    
    
    
    
    <category term="GitHub" scheme="http://blog.simoncode.top/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://blog.simoncode.top/2020/03/31/24-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.simoncode.top/2020/03/31/24-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-31T07:18:37.000Z</published>
    <updated>2020-06-21T09:49:22.915Z</updated>
    
    <content type="html"><![CDATA[<p>常用开发设计模式：单例模式、工厂模式、观察者模式、装饰者模式，列举</p><span id="more"></span><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类只有一个实例，提供一个全局访问的点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonClass singletonClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass  <span class="title function_">newInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonClass==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonClass.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonClass==<span class="literal">null</span>)&#123;</span><br><span class="line">                    singletonClass = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>不会对客户端暴露创建对象的逻辑，并且通过同一个接口来指定新创建的对象</p><p>图解:</p><p><img src="https://github.com/aalansehaiyang/technology-talk/raw/master/basic-knowledge/img/10.jpg"></p><p>1、创建一个公共接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 定义具体的对象</p><p>画圆形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Circle <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画矩形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、创建工厂，生成基于给定信息的实体类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、调用具体的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者模式-发布订阅模式"><a href="#观察者模式-发布订阅模式" class="headerlink" title="观察者模式(发布订阅模式)"></a>观察者模式(发布订阅模式)</h2><p>观察者模式又名发布订阅模式，通俗点可以理解为如下图：</p><p><img src="http://static.simoncode.top/15856472742874.jpg"></p><p>实例代码：</p><p><strong>抽象观察者(用户)</strong></p><p>&#x2F;&#x2F;定义一个更新方法，即发布文章之后的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体观察者(关注公众号用户)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被观察者(公众号)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的别观察者(公众号具体方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户1&quot;</span>);</span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户2&quot;</span>);</span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;文章更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态的给对象添加一些额外的属性或行为。</p><p>举例子：<br>存在一个蛋糕，我们需要计算蛋糕装饰上蜡烛和水果之后的价格</p><p>1、定义组件类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;Sweet&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义被装饰者「蛋糕」类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cake</span> <span class="keyword">extends</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一个蛋糕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义装饰器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、定义装饰者水果和蜡烛类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    Sweet sweet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FruitDecorator</span><span class="params">(Sweet sweet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sweet = sweet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.getDescription() + <span class="string">&quot;，水果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.cost() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//蜡烛</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CandleDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    Sweet sweet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CandleDecorator</span><span class="params">(Sweet sweet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sweet = sweet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.getDescription() + <span class="string">&quot;，蜡烛&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.cost() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Cake</span> <span class="variable">cake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cake</span>();</span><br><span class="line">    System.out.println(cake.getDescription() + <span class="string">&quot;总共花费&quot;</span> + cake.cost());</span><br><span class="line"></span><br><span class="line">    <span class="type">FruitDecorator</span> <span class="variable">fruitDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDecorator</span>(cake);</span><br><span class="line">    System.out.println(fruitDecorator.getDescription() + <span class="string">&quot;总共花费&quot;</span> + fruitDecorator.cost());</span><br><span class="line"></span><br><span class="line">    <span class="type">CandleDecorator</span> <span class="variable">candleDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CandleDecorator</span>(fruitDecorator);</span><br><span class="line">    System.out.println(candleDecorator.getDescription() + <span class="string">&quot;总共花费&quot;</span> + candleDecorator.cost());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个蛋糕，总共花费66.0</span><br><span class="line">一个蛋糕，水果，总共花费76.0</span><br><span class="line">一个蛋糕，水果，一根蜡烛，总共花费86.0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用开发设计模式：单例模式、工厂模式、观察者模式、装饰者模式，列举&lt;/p&gt;</summary>
    
    
    
    <category term="基础" scheme="http://blog.simoncode.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="http://blog.simoncode.top/tags/Java/"/>
    
    <category term="基础" scheme="http://blog.simoncode.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计" scheme="http://blog.simoncode.top/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 生产环境用到的技术</title>
    <link href="http://blog.simoncode.top/2020/03/28/23-Mysql-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://blog.simoncode.top/2020/03/28/23-Mysql-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF/</id>
    <published>2020-03-27T19:58:17.000Z</published>
    <updated>2020-06-21T09:49:22.912Z</updated>
    
    <content type="html"><![CDATA[<p>现在是 03-28 早上四点，刚刚结束了一波线上环境的数据库迁移，趁着热乎，把用到的技术做一个总结</p><span id="more"></span><h2 id="设置-Mysql-数据目录"><a href="#设置-Mysql-数据目录" class="headerlink" title="设置 Mysql 数据目录"></a>设置 Mysql 数据目录</h2><p>前言：<br>由于之前服务都是采用 AWS 的 RDS 服务，RDS 好是好，但是服务的成本过于的高，大概 1c1g 的机器一个月需要 500~1000 人民币，公司为了削减成本所以将 RDS 数据迁移到本地服务器。但是由于存储的数据有30多G，机器的 <code>/root</code> 目录不足以存储这么大的数据，所以需要进行 mysql 的 data 数据目录更改。</p><p>条件：<br>服务器：ubuntu 16.04<br>mysql：5.7.1</p><p>迁移步骤：<br>1、查看 data 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">select @@datadir;</span></span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output</span><br><span class="line">+-----------------+</span><br><span class="line">| @@datadir       |</span><br><span class="line">+-----------------+</span><br><span class="line">| /var/lib/mysql/ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2、迁移现有数据</p><p>停掉当前 mysql 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>复制 mysql data 数据(实例中，将数据复制到 &#x2F;root&#x2F;.mysql 目录下)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /var/lib/mysql /root/.mysql</span><br></pre></td></tr></table></figure><p>备份原有数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/lib/mysql /var/lib/mysql.bak</span><br></pre></td></tr></table></figure><p>3、修改 mysql 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>将 <code>datadir</code> 修改为目标地址 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">datadir=/root/.mysql/mysql</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>4、修改别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apparmor.d/tunables/alias</span><br></pre></td></tr></table></figure><p>修改为如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias /var/lib/mysql/ -&gt; /root/.mysql/mysql/,</span><br></pre></td></tr></table></figure><p>重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart apparmor</span><br></pre></td></tr></table></figure><p>5、重置 data 目录&amp;重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/lib/mysql/mysql -p</span><br><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></table></figure><p>至上，我们就完成了 mysql data 数据的目录迁移，再也不会因为 <code>/root</code> 磁盘空间而担心了。</p><h2 id="设置-Mysql-主从"><a href="#设置-Mysql-主从" class="headerlink" title="设置 Mysql 主从"></a>设置 Mysql 主从</h2><p>前言：<br>为了方便演示，咱们这里采用 docker 为 mysql 环境</p><p>1、安装 mysql </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker run --name master-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:latest //主mysql</span><br><span class="line">docker run --name slave-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3308:3306 -d mysql:latest //从mysql</span><br></pre></td></tr></table></figure><p>为了方便本机演示，我们使用 3307 端口表示主服务器，3308 端口表示从服务器</p><p>2、设置主服务器</p><blockquote><p>由于 docker 里没有vim，所以需要安装 vim <code>apt update;apt install vim -y</code></p></blockquote><p>2、1 设置服务 id 和开启日志<br>进入 docker 容器内 <code>docker exec -it xxx /bin/bash</code></p><p>vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=100  # server 的id</span><br><span class="line">log-bin=mysql-bin # log 文件名</span><br></pre></td></tr></table></figure><p>修改完成后重启 mysql 服务，docker 容器可以直接重启容器服务即可 <code>docker restart master-mysql</code></p><p>2、2 配置同步账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>上述命令中，新建了一个 slave 账号，同时允许所有ip访问</p><p>2、设置从服务器</p><p>2、1 设置从服务器配置</p><p>vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=101  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=mysql-slave-bin   </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin </span><br></pre></td></tr></table></figure><p>上述配置中还可以设置需要同步的数据库、表，或忽略的数据库、表。</p><p>2、2 设置从数据账号</p><p>master-mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure><p>返回值中有 <code>Position</code> 需要将该值记下</p><p>获取 master 的ip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master-mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">172.17.0.2</span></span><br></pre></td></tr></table></figure><p>slave-mysql：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;123456&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos= <span class="string">&quot;此处填写在 master 中的 Position 值&quot;</span>, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure><p>2、3 开启同步&amp;查看同步状态</p><p>开启同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">start slave;</span></span><br></pre></td></tr></table></figure><p>查看同步状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">show slave status \G;</span></span><br></pre></td></tr></table></figure><p>主要看：<code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code>，当出现问题时，可看 <code>Slave_SQL_Running_State</code> 具体错误解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">slave stop;</span></span><br></pre></td></tr></table></figure><p>参考地址：<br><a href="https://www.cnblogs.com/songwenjie/p/9371422.html">基于Docker的Mysql主从复制搭建</a><br><a href="https://www.jianshu.com/p/bfca0cdfb169">mysql设置主从同步</a></p><p>可能遇到问题：<br><a href="https://www.cnblogs.com/huligong1234/p/7998514.html">MySQL主从同步异常问题解决Client requested master to start replication from position &gt; file size</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在是 03-28 早上四点，刚刚结束了一波线上环境的数据库迁移，趁着热乎，把用到的技术做一个总结&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="http://blog.simoncode.top/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql 的两种引擎</title>
    <link href="http://blog.simoncode.top/2020/03/23/22-Mysql-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E/"/>
    <id>http://blog.simoncode.top/2020/03/23/22-Mysql-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E/</id>
    <published>2020-03-23T08:41:46.000Z</published>
    <updated>2020-06-21T09:49:22.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql 的数据存储主要存在两种引擎，即：MyISAM 和 InnoDb,我们常用的为 InnoDb,那么两种存在哪些差异和优缺点呢？</p></blockquote><span id="more"></span><h2 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h2><p>1、不支持事务，每次查询操作都是原子级别的</p><p>2、支持表级锁，即每次操作都是对整个表进行加锁操作</p><p>3、存储表的总行数</p><p>4、一张表包含三个文件:索引文件、表结构文件、表数据文件</p><p>5、索引文件的数据域存储指向数据文件的指针</p><h3 id="InnoDb-存储引擎"><a href="#InnoDb-存储引擎" class="headerlink" title="InnoDb 存储引擎"></a>InnoDb 存储引擎</h3><p>1、支持ACID的事务，支持食物的四种隔离级别</p><ul><li>Read uncommitted 读未提交：即一个事务可以读取另一个未提交事务的数据</li><li>Read committed 读提交：即一个事务要等另一个事务提交后才能读取数据</li><li>Repeatable read 重复度：即事务开启时，不再允许修改操作(但允许插入操作)</li><li>Serializable 序列化：最高级别的事务隔离，事务串行操作，但是效率底下</li></ul><p>2、支持行级锁以及外键约束，支持写并发</p><p>3、不存储表的总行数</p><p>4、一个InnoDb引擎存储在一个文件空间</p><p>5、主键索引采用聚集索引，</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mysql 的数据存储主要存在两种引擎，即：MyISAM 和 InnoDb,我们常用的为 InnoDb,那么两种存在哪些差异和优缺点呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mysql" scheme="http://blog.simoncode.top/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 自旋锁</title>
    <link href="http://blog.simoncode.top/2020/03/19/21-Java-%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://blog.simoncode.top/2020/03/19/21-Java-%E8%87%AA%E6%97%8B%E9%94%81/</id>
    <published>2020-03-19T13:14:13.000Z</published>
    <updated>2020-06-21T09:49:22.911Z</updated>
    
    <content type="html"><![CDATA[<p>最近看视频刚好看到关于 Java 自旋锁相关内容，结合实例代码做一个记录</p><span id="more"></span><blockquote><p>本文参考地址：<a href="https://segmentfault.com/a/1190000015795906">面试必备之深入理解自旋锁</a></p></blockquote><h2 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h2><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><h2 id="如何实现自旋锁"><a href="#如何实现自旋锁" class="headerlink" title="如何实现自旋锁"></a>如何实现自旋锁</h2><h3 id="简单例子-🌰"><a href="#简单例子-🌰" class="headerlink" title="简单例子 🌰"></a>简单例子 🌰</h3><p>下面代码是一个简单的自旋锁例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// 等待获取线程锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题：<br>1、某个线程持有锁时间过长时，会导致其他线程一直处于等到状态，导致徒增 CPU 消耗<br>2、存在不公平情况，即等待时间长的线程不一定能优先获得锁</p><h3 id="可重入锁🔐-和-不可重入锁🔐"><a href="#可重入锁🔐-和-不可重入锁🔐" class="headerlink" title="可重入锁🔐 和 不可重入锁🔐"></a>可重入锁🔐 和 不可重入锁🔐</h3><p>上述代码存在的问题：当线程 A 持有锁时，在线程 A 释放锁之前不可再次获得锁。而可重入锁需要保证线程 A 再次获取锁时，也有机会获得锁对象。</p><p>优化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cas</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == cas.get()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cas.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 等待获取线程锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == cas.get() &amp;&amp; count &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//当前线程重入数量为0，释放锁资源</span></span><br><span class="line">            cas.compareAndSet(currentThread, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个线程「锁」计数器，当 A 线程的重入数量为0时，释放当前锁资源。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看视频刚好看到关于 Java 自旋锁相关内容，结合实例代码做一个记录&lt;/p&gt;</summary>
    
    
    
    <category term="基础" scheme="http://blog.simoncode.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="http://blog.simoncode.top/tags/Java/"/>
    
    <category term="基础" scheme="http://blog.simoncode.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Io流" scheme="http://blog.simoncode.top/tags/Io%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>EOS 同步相关</title>
    <link href="http://blog.simoncode.top/2019/01/17/20-EOS%20%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.simoncode.top/2019/01/17/20-EOS%20%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3/</id>
    <published>2019-01-17T06:11:39.000Z</published>
    <updated>2020-06-21T09:49:22.911Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直都在处理 EOS 同步相关的事情,刚好今天有空,就将最近整理的资料发布出来。</p><span id="more"></span><h1 id="使用-nodeos-快速做一个-EOS-RPC-节点"><a href="#使用-nodeos-快速做一个-EOS-RPC-节点" class="headerlink" title="使用 nodeos 快速做一个 EOS RPC 节点"></a>使用 nodeos 快速做一个 EOS RPC 节点</h1><h2 id="1-下载-nodeos"><a href="#1-下载-nodeos" class="headerlink" title="1.下载 nodeos"></a>1.下载 nodeos</h2><ul><li><p>EOS 提供 Release 下载,下载地址 <a href="https://github.com/EOSIO/eos/releases">https://github.com/EOSIO/eos/releases</a>;选择适当的版本下载。</p></li><li><p>下载:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/EOSIO/eos/releases/download/v1.5.3/eosio_1.5.3-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure><ul><li>安装:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ./eosio_1.5.3-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeos -v</span><br></pre></td></tr></table></figure><p>查看当前 nodeos 版本</p><h2 id="2-下载logs文件"><a href="#2-下载logs文件" class="headerlink" title="2.下载logs文件"></a>2.下载logs文件</h2><ul><li>地址:<br>日志备份地址:<a href="https://eosnode.tools/blocks">BLOCKS ARCHIVE</a>;</li><li>下载:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget $(wget --quiet &quot;https://eosnode.tools/api/blocks?limit=1&quot; -O- | jq -r &#x27;.data[0].s3&#x27;) -O blocks_backup.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf blocks_backup.tar.gz</span><br></pre></td></tr></table></figure><h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h2><ul><li>config.ini</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">agent-name = EOSNODE</span><br><span class="line"></span><br><span class="line">chain-state-db-size-mb = 10240</span><br><span class="line">reversible-blocks-db-size-mb = 340</span><br><span class="line"></span><br><span class="line">http-server-address = 0.0.0.0:8870</span><br><span class="line"></span><br><span class="line">http-validate-host = false</span><br><span class="line">verbose-http-errors = true</span><br><span class="line">abi-serializer-max-time-ms = 2000</span><br><span class="line"></span><br><span class="line">access-control-allow-origin = *</span><br><span class="line">allowed-connection = any</span><br><span class="line"></span><br><span class="line">max-clients = 2</span><br><span class="line">connection-cleanup-period = 30</span><br><span class="line">network-version-match = 1</span><br><span class="line">sync-fetch-span = 2000</span><br><span class="line">enable-stale-production = true</span><br><span class="line"></span><br><span class="line">max-implicit-request = 1500</span><br><span class="line">pause-on-startup = false</span><br><span class="line">max-transaction-time = 30</span><br><span class="line">max-irreversible-block-age = -1</span><br><span class="line">txn-reference-block-lag = 0</span><br><span class="line"></span><br><span class="line">plugin = eosio::chain_api_plugin</span><br><span class="line">plugin = eosio::chain_plugin</span><br></pre></td></tr></table></figure><ul><li>p2p 地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">p2p-peer-address = 185.253.188.1:19876</span><br><span class="line">p2p-peer-address = bp.cryptolions.io:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eospace.io:88</span><br><span class="line">p2p-peer-address = eu-west-nl.eosamsterdam.net:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eosgermany.online:9876</span><br><span class="line">p2p-peer-address = 35.197.190.234:19878</span><br><span class="line">p2p-peer-address = mainnet.genereos.io:9876</span><br><span class="line">p2p-peer-address = mainnet.eospay.host:19876</span><br><span class="line">p2p-peer-address = 130.211.59.178:9876</span><br><span class="line">p2p-peer-address = 54.153.59.31:9999</span><br><span class="line">p2p-peer-address = 94.130.250.22:9806</span><br><span class="line">p2p-peer-address = peer.main.alohaeos.com:9876</span><br><span class="line">p2p-peer-address = peer.eosn.io:9876</span><br><span class="line">p2p-peer-address = prod.mainnet.eos.cybex.io:9888</span><br><span class="line">p2p-peer-address = p2p-1.eosnetwork.io:9876</span><br><span class="line">p2p-peer-address = p.jeda.one:3322</span><br><span class="line">p2p-peer-address = eosbattles.com:9877</span><br><span class="line">p2p-peer-address = 34.226.76.22:9876</span><br><span class="line">p2p-peer-address = mainnet.eosoasis.io:9876</span><br><span class="line">p2p-peer-address = node.eosflare.io:1883</span><br><span class="line">p2p-peer-address = mainnet.eoscalgary.io:5222</span><br><span class="line">p2p-peer-address = eos-p2p.worbli.io:33981</span><br><span class="line">p2p-peer-address = 18.188.38.175:9876</span><br><span class="line">p2p-peer-address = 18.221.255.38:9876</span><br><span class="line">p2p-peer-address = eos.staked.us:9870</span><br><span class="line">p2p-peer-address = peering.dutcheos.io:9876</span><br><span class="line">p2p-peer-address = 18.188.4.97:9876</span><br><span class="line">p2p-peer-address = 18.191.125.105:9876</span><br><span class="line">p2p-peer-address = boot.eostitan.com:9876</span><br><span class="line">p2p-peer-address = eosboot.chainrift.com:9876</span><br><span class="line">p2p-peer-address = dc1.eosemerge.io:9876</span><br><span class="line">p2p-peer-address = m.eosvibes.io:9876</span><br><span class="line">p2p-peer-address = node1.eosphere.io:9876</span><br><span class="line">p2p-peer-address = node2.eosphere.io:9876</span><br><span class="line">p2p-peer-address = 45.33.60.65:9820</span><br><span class="line">p2p-peer-address = peering.eosio.cr:1976</span><br><span class="line">p2p-peer-address = peering.eosio.cr:5418</span><br><span class="line">p2p-peer-address = 54.203.121.17:19866</span><br><span class="line">p2p-peer-address = eosnode.fi:9888</span><br><span class="line">p2p-peer-address = api.eosuk.io:12000</span><br><span class="line">p2p-peer-address = fullnode.eoslaomao.com:443</span><br><span class="line">p2p-peer-address = new.eoshenzhen.io:10034</span><br><span class="line">p2p-peer-address = peer.eosio.sg:9876</span><br><span class="line">p2p-peer-address = eos.nodepacific.com:9876</span><br><span class="line">p2p-peer-address = 18.234.6.119:80</span><br><span class="line">p2p-peer-address = eu1.eosdac.io:49876</span><br><span class="line">p2p-peer-address = br.eosrio.io:9876</span><br><span class="line">p2p-peer-address = p2p-public.hkeos.com:19875</span><br><span class="line">p2p-peer-address = node.eosmeso.io:9876</span><br><span class="line">p2p-peer-address = pub1.eostheworld.io:9876</span><br><span class="line">p2p-peer-address = 807534da.eosnodeone.io:19872</span><br><span class="line">p2p-peer-address = mainnet.eoseco.com:10010</span><br></pre></td></tr></table></figure><h2 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h2><p>执行以下命令,进行 EOS 同步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeos --data-dir /blockData/blocks --config-dir /blockData --hard-replay --wasm-runtime wabt</span><br></pre></td></tr></table></figure><p>执行完命令后,数据将进行replay。replay 结束后,节点将正常进行同步。</p><p>后期启动节点时,只需要执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeos --data-dir /blockData/blocks --config-dir /blockData </span><br></pre></td></tr></table></figure><h1 id="EOS-使用快照快速启动"><a href="#EOS-使用快照快速启动" class="headerlink" title="EOS 使用快照快速启动"></a>EOS 使用快照快速启动</h1><h2 id="1-下载快照文件"><a href="#1-下载快照文件" class="headerlink" title="1. 下载快照文件:"></a>1. 下载快照文件:</h2><p><a href="https://eosnode.tools/snapshots">快照备份地址</a></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><p>.<br>├── config.ini<br>├── node-data<br>│   ├── blocks<br>│   ├── snapshots<br>│   └── state<br>└── snapshot.sh</p><ul><li>注意:使用快照备份的方式启动时,需要删除 blocks&#x2F;state 这两个文件夹</li></ul><h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件:"></a>2. 配置文件:</h2><p><code>vim config.ini</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">agent-name = EOSNODEOS</span><br><span class="line"></span><br><span class="line">chain-state-db-size-mb = 10240</span><br><span class="line">reversible-blocks-db-size-mb = 1024</span><br><span class="line"></span><br><span class="line">http-server-address = 0.0.0.0:8870</span><br><span class="line"></span><br><span class="line">http-validate-host = false</span><br><span class="line">verbose-http-errors = true</span><br><span class="line">abi-serializer-max-time-ms = 2000</span><br><span class="line"></span><br><span class="line">access-control-allow-origin = *</span><br><span class="line">allowed-connection = any</span><br><span class="line"></span><br><span class="line">max-clients = 2</span><br><span class="line">sync-fetch-span = 3000</span><br><span class="line">connection-cleanup-period = 30</span><br><span class="line">enable-stale-production = false</span><br><span class="line"></span><br><span class="line">plugin = eosio::chain_api_plugin</span><br><span class="line">plugin = eosio::chain_plugin</span><br><span class="line"></span><br><span class="line">p2p-peer-address = bp.cryptolions.io:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eosgermany.online:9876</span><br><span class="line">p2p-peer-address = mainnet.eospay.host:19876</span><br><span class="line">p2p-peer-address = 94.130.250.22:9806</span><br><span class="line">p2p-peer-address = peer.main.alohaeos.com:9876</span><br><span class="line">p2p-peer-address = peer.eosn.io:9876</span><br><span class="line">p2p-peer-address = p.jeda.one:3322</span><br><span class="line">p2p-peer-address = peering.eosio.cr:1976</span><br><span class="line">p2p-peer-address = eos.nodepacific.com:9876</span><br><span class="line">p2p-peer-address = eu1.eosdac.io:49876</span><br><span class="line">p2p-peer-address = pub1.eostheworld.io:9876</span><br><span class="line">p2p-peer-address = 807534da.eosnodeone.io:19872</span><br><span class="line">p2p-peer-address = mainnet.eoseco.com:10010 </span><br></pre></td></tr></table></figure><h2 id="3-初次启动脚本"><a href="#3-初次启动脚本" class="headerlink" title="3. 初次启动脚本:"></a>3. 初次启动脚本:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeos --config-dir ./ --data-dir ./node-data --snapshot ./node-data/snapshots/snapshot-023e5e8813f687c6c5ffcf6eae853eb24f78d90b475dac4fb94face8c8308e4f.bin</span><br></pre></td></tr></table></figure><h2 id="4-再次启动"><a href="#4-再次启动" class="headerlink" title="4. 再次启动:"></a>4. 再次启动:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeos --config-dir ./ --data-dir ./node-data</span><br></pre></td></tr></table></figure><h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证:"></a>5. 验证:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const FIBOS = require(&quot;fibos.js&quot;);</span><br><span class="line">const fibos = FIBOS(&#123;</span><br><span class="line">    chainId: &quot;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&quot;,</span><br><span class="line">    httpEndpoint: &quot;http://127.0.0.1:8871&quot;,</span><br><span class="line">    keyProvider: &quot;&quot;,</span><br><span class="line">    logger: &#123;</span><br><span class="line">        log: null,</span><br><span class="line">        error: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let r =  fibos.getBlockSync(&quot;最新快高度&quot;);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure><ul><li>需要依赖于 <a href="https://dev.fo/zh-cn/api/fibosjs/index.html#getBlock">fibos.js</a></li></ul><h2 id="6-生成快照"><a href="#6-生成快照" class="headerlink" title="6.生成快照"></a>6.生成快照</h2><h3 id="1-添加插件"><a href="#1-添加插件" class="headerlink" title="1. 添加插件"></a>1. 添加插件</h3><p>在 config.ini 中添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin = eosio::producer_api﻿_plugin</span><br></pre></td></tr></table></figure><ul><li>注意: 开启该插件后,请确保你的节点放置在内网无法被其他地方访问到。</li></ul><h3 id="2-设置备份目录"><a href="#2-设置备份目录" class="headerlink" title="2. 设置备份目录"></a>2. 设置备份目录</h3><p>启动时添加参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--snapshots﻿﻿-dir ../snapshots-backups</span><br></pre></td></tr></table></figure><h3 id="3-创建快照"><a href="#3-创建快照" class="headerlink" title="3. 创建快照"></a>3. 创建快照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://curl http://127.0.0.1:8870/v1/producer/create_sn﻿apshot</span><br></pre></td></tr></table></figure><p>按照目前EOS的大小,这一步大约需要耗时 10~15 分钟。快照创建结束后,在 <code>snapshots-backups</code> 目录下,便生成相应的快照文件。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结:"></a>7. 总结:</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ol><li>使用快照方式能够快速启动节点同时保证和主网同步。</li><li>使用快照的方式能够节省磁盘空间。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>使用快照启动的节点,快照高度之前的区块数据无法获取。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直都在处理 EOS 同步相关的事情,刚好今天有空,就将最近整理的资料发布出来。&lt;/p&gt;</summary>
    
    
    
    <category term="区块链" scheme="http://blog.simoncode.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://blog.simoncode.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="EOS" scheme="http://blog.simoncode.top/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>记ETH智能合约小计</title>
    <link href="http://blog.simoncode.top/2018/06/24/19-ETH%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B0%8F%E8%AE%A1/"/>
    <id>http://blog.simoncode.top/2018/06/24/19-ETH%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B0%8F%E8%AE%A1/</id>
    <published>2018-06-24T15:00:42.000Z</published>
    <updated>2020-06-21T09:49:22.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章是因为上个星期处理了一个ETH中智能合约的业务,所以趁着自己还记得,梳理一下.</p></blockquote><!---more---><h2 id="ETH智能合约"><a href="#ETH智能合约" class="headerlink" title="ETH智能合约"></a>ETH智能合约</h2><blockquote><p>下面的这些理解都是我片面的理解,并没有得到书面的证实.</p></blockquote><p>这里要说的ETH中的智能合约是EIEC币(电能链)</p><ul><li><p>智能合约的理解</p><p>  智能合约可以看做是部署在以太坊上的一个程序。但是这个程序是透明的代码是开源可见的.而发行的代币可以看做是这个程序里面的一个积分.</p></li><li><p>处理的业务</p><ul><li>1.查询余额</li></ul><p>  智能合约的查询余额方法需要调取一个<code>call</code>的方法,而该方法可以看做是一笔转账，通过ETH的<a href="!https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call">wiki</a>我们可以查到该方法所需要的一些参数.</p><ul><li>2.进行数据签名和广播</li></ul><p>  这里就不深入的进行讲解了,智能合约和ETH的签名数据区别在于存在一个ABI编码后的data数据。</p><ul><li>3.交易查询</li></ul><p>  由于智能合约的所有交易的toaddr都是指向了智能合约的主地址(MasterAddr,一个智能合约在主网上的地址是唯一的)。所以并不能更具一笔交易的toaddr查到该交易的具体细节。以太坊提供了另一个方法<code>eth_getTransactionReceipt</code><a href="!https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt">wiki</a>来查询改合约的具体结果.</p></li></ul><p> 这里只是很简单的编写了一下。具体的细节可以等下次有时间把具体的流程和数据结构一起带上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章是因为上个星期处理了一个ETH中智能合约的业务,所以趁着自己还记得,梳理一下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!---more---&gt;
&lt;h2 id=&quot;ETH智能合约&quot;&gt;&lt;a href=&quot;#ETH智能合约&quot; class=&quot;heade</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>服务器迁移小计</title>
    <link href="http://blog.simoncode.top/2018/06/03/18-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%A1/"/>
    <id>http://blog.simoncode.top/2018/06/03/18-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%A1/</id>
    <published>2018-06-03T02:33:00.000Z</published>
    <updated>2020-06-21T09:49:22.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哇.一晃一年过去了,看自己上篇博客还是去年九月份的时候更新了，唉！回想起自己秋招之后的这半年,感觉真的是可以用命运多舛来形容了,好在日子会越过越好,现在的工作虽然没有武汉时那么清闲,偶尔会加班到十一二点,但是年轻人嘛,或者就是折腾得。刚好撑着这个周末其它的一些事情都处理结束了,查看自己的阿里云也马上到期了,(😔 毕业就薅不到这些羊毛了)。但是服务器上还部署着很多服务,所以想着刚好写写自己最近的状态和把服务器上的东西备份一下。</p></blockquote><span id="more"></span><h2 id="服务器迁移"><a href="#服务器迁移" class="headerlink" title="服务器迁移"></a>服务器迁移</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul><li><p>1.去Java官网下载相关的Jdk开发环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>1.编辑相关环境变量<code>vim /etc/profile</code></li><li>2.添加环境变量  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   export JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=./:$JAVA_HOME/lib:$JAVA_HOM/jre/lib</span><br></pre></td></tr></table></figure></li><li>3.执行<code>source /etc/profile</code></li><li>4.验证<code>java -version</code></li></ul><p>  到这里Java的开发环境就安装好了,很简单有木有。</p></li></ul><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><p>作为一个Java开发者,怎么可能少的了Mysql呢,但是现在由于云技术的发展,安装mysql可以采用两种方式,下面具体介绍</p><ul><li><p>普通安装方式(不推荐)</p><p>1.可以去Mysql的官网下载相关依赖库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.使用仓库安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><p>3.mysql的一些基本命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld #启动MySQL</span><br><span class="line">systemctl stop mysqld #关闭MySQL</span><br><span class="line">systemctl restart mysqld #重启MySQL</span><br><span class="line">systemctl status mysqld #查看MySQL运行状态</span><br><span class="line">systemctl enable mysqld #设置开机启动</span><br><span class="line">systemctl disable mysqld #关闭开机启动</span><br></pre></td></tr></table></figure><p>4.找到临时密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>5.删除密码安全限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNINSTALL PLUGIN validate_password;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>到这里普通的Mysql安装方式也结束了,那么来看看Doker是如何安装的把</strong></p></blockquote><ul><li><p>采用Docker安装</p><ul><li><p>1.首先得安装Docker</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-io</span><br></pre></td></tr></table></figure></li><li><p>2.找到一个可靠的源(这里推荐DaoCloud的源)</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hub.daocloud.io/</span><br></pre></td></tr></table></figure></li><li><p>3.配置Mysql的镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=xxx -p 3306:3306 -d daocloud.io/mysql:tag</span><br></pre></td></tr></table></figure><ul><li>其中<code>MYSQL_ROOT_PASSWORD</code>后加mysql的密码</li><li><code>-p</code>后加需要映射的端口</li></ul></li><li><p>4.安装进行后<br>  我们就存在一个默认的容器,使用<code>docker ps</code>就可以看到列表</p></li><li><p>5.如何进入容器<br>  <code>docker exec -it xxx /bash/bin</code></p></li></ul><p>  <strong>到这里Mysql Docker的安装方式也结束了</strong></p></li></ul><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx是现在比较主流的一款web服务器,但是在Linux上，nginx的安装方式还是很麻烦的,所以有Docker的情况下,我们没比较再去花时间在安装上面，我们可以直接去镜像中心下载nginx的镜像</p><ul><li>编写自己的Dockerfile<ul><li>1.创建相关的文件夹<br>  <code>mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</code>三个文件夹的含义分别为:<ul><li>www目录将映射为nginx容器配置的虚拟目录</li><li>logs目录将映射为nginx容器的日志目录</li><li>conf目录里的配置文件将映射为nginx容器的配置文件</li></ul></li><li>2.拉取Nginx镜像  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li>3.运行镜像  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  xxx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-p 80:80：将容器的80端口映射到主机的80端口</p></li><li><p>–name mynginx：将容器命名为mynginx</p></li><li><p>-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</p></li><li><p>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p></li><li><p>-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</p></li></ul></li></ul><h3 id="服务程序"><a href="#服务程序" class="headerlink" title="服务程序"></a>服务程序</h3><blockquote><p>现在在服务器上还存在的程序有:<a href="http://simoncode.top/movie">80s的电影爬虫</a>,<a href="http://simoncode.top/">个人主页</a>;</p></blockquote><h4 id="电影爬虫"><a href="#电影爬虫" class="headerlink" title="电影爬虫"></a>电影爬虫</h4><p>这个项目是采用SpringBoot+Redis实现的,其实编写的时间还算挺早的,早在17年九月份在武汉实习的时候花了不到一个星期就完成了,之后就一直部署在自己的服务器上，期间还自己重构过几次,但是由于天生并不是编写前端的料子,所及虽然重构过几次,页面依然是非常的丑.这个爬虫采用SpringBoot编写,所以只需要有Java环境就可以运行,但是里面相关依赖了Redis、Mysql等组件,所以运行的话需要先将这个组件安装.</p><ul><li><p>自动化更新脚本:</p><p>  凭借自己对Linux的一知半解,编写了一个脚本,用来自动化从Git上拉取代码和更新打包运行。脚本主要分三部分:</p><p> 运行脚本(run.sh):</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java  -jar  -Dserver.port=8089  xxx-1.0-SNAPSHOT.jar   &amp;&gt;nohup.out &amp;</span><br></pre></td></tr></table></figure><p> 停止脚本(stop.sh):</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   for PID in `ps aux | grep &#x27;java&#x27; | grep &#x27;movie&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`; do</span><br><span class="line">        kill -9 $PID</span><br><span class="line">done</span><br><span class="line">echo &quot;[kill Simon service]&quot;</span><br></pre></td></tr></table></figure><p> 更新脚本(update.sh):</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd ~/source/Zhihu #源码路径</span><br><span class="line">git pull #更新代码</span><br><span class="line">mvn package -Dmaven.test.skip=true #maven打包</span><br><span class="line">cd ~/zhihu#进入项目目录</span><br><span class="line">sh stop.sh </span><br><span class="line">rm -f web-1.0.0-SNAPSHOT.jar</span><br><span class="line">mv ~/source/Zhihu/web/target/web-1.0-SNAPSHOT.jar ~/zhihu</span><br><span class="line">echo Project Update Finish </span><br><span class="line">sh run.sh</span><br><span class="line">echo Project Running</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用上部分自动化脚本的前提是你得配置了github的相关ssh key<br>其实配置github的相关key 也是很简单的,只需要在bash中输入<code>ssh-keygen -t rsa -C &quot;email&quot;</code>就可以了</p></blockquote><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><ul><li>其中程序的主要代码都托管在github上了,需要备份的主要是sql数据。sql数据中有两部分:1.就是爬取的电影的sql 2.就是毕业设计做的爬取知乎的sql。</li></ul><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p>😔,今天都已经是六月3号了,2018年都已经过半了,这个月中旬,我的身份也要从大学生变成了一名社会人了,虽然当初在学校的时候，由于各种原因,自己一直迫切着想要去工作,但是当想想自己马上就要离开校园,再也回不去的时候,还是有一点点感伤的。再想想自己的2017年后半年,一点新鲜的技术都没有学习到,用的东西和了解的东西也都过于局限。</p><h2 id="New-Life"><a href="#New-Life" class="headerlink" title="New Life"></a>New Life</h2><blockquote><p>既然是自己的博客,那么久可以畅所欲言和记录自己琐碎的事情.</p></blockquote><p>4.16日,毕业答辩。虽然距离现在马上要到两个月了,但是那天或者说那个星期的事情我都依然清楚的记得。那天早上六点多我就醒来,收拾收拾后便和邹恒一起打的前往火车站,我们是九点半的车但是我们七点多就到了火车站,等了两个多小时,当我们提着行李到铁轨旁后车时。我俩都感觉自己度过了滑稽可笑的三个月,三个月里面知识没长、见识没长、钱包没长。我俩商量着接下来的打算,他准备去深证我准备…经过一天的“长途跋涉”，终于到了学校,哇 看到同学回到宿舍的那一刻真的好幸福,顿时感觉自己还是一个学生,什么压力都没有。五点多到宿舍,和同学交流了一会,便去和张鹏赴约,感觉和张鹏总是有聊不完的话题,可能都是对技术的喜欢,就像我和邹恒一样,总是有聊不完的技术和问题,[虽然大部分时间都是他在和我讲着我从来都没有听说过的技术]。见到老哥的那一刻依然是那么的情切,还没来得及聊聊最近的状况他便去见他的导师了。唉约好的去一次上海都没有实现。</p><p>第二天,也就是答辩的那天,七点多我本来还在床上睡觉呢,室友便说他程序有bug🤣叫我去帮忙修bug，带着困意和疲惫。我去了。没想到的是我尽然在哪里呆了一天😂也就是我帮他们修了一天的bug。和同学们聊天感觉真的很开心！但是由于自身的原因，第二天晚上便离开了学校。后面的事情就让它过去吧。</p><p><strong>讲讲现在吧</strong><br>也不知道是命运还是啥,本来信心满满的小杨并没有考上自己准备一年的志愿者。带着失落的她也投身到了找工作的行列,有时候命运就是那么意想不到,从大一开始就准备工作的我到上个月才能说是真正的开始工作,而一直以为会继续读书的她既然也开始了工作，好在彼此都比较勤奋和努力,虽然比不上那些大佬,但是和暂时的自己比起来还是算不差的。</p><p>她在南京找到了一份还不错的工作，福利待遇行业都比较符合她的口味,就这样我们寄去年七月份后又再一次的在一起了,也算结束了四年的异地恋.每天下班早或者周末的时候都可以做一顿好吃的一起品尝。[话说现在的我做饭手艺确实不赖啊!]</p><p>最后分享一点最近的照片吧.</p><p><img src="/images/18.6.3/01.JPG" alt="酷酷的小杨"></p><center><font color=grey>**酷酷的小杨**</font></center>![安静的小杨](/images/18.6.3/02.JPG)<br>![安静的小杨](/images/18.6.3/03.JPG)<br>![酷酷的小杨](/images/18.6.3/04.JPG)<br>![酷酷的小杨](/images/18.6.3/05.JPG)<br>![酷酷的小杨](/images/18.6.3/06.JPG)<br>![酷酷的小杨](/images/18.6.3/07.JPG)<br>![酷酷的小杨](/images/18.6.3/08.JPG)<center><font color=grey>**安静的小杨**</font></center>![快要死掉的多肉](/images/18.6.3/09.JPG)<center><font color=grey>**快要死掉的多肉**</font></center>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;哇.一晃一年过去了,看自己上篇博客还是去年九月份的时候更新了，唉！回想起自己秋招之后的这半年,感觉真的是可以用命运多舛来形容了,好在日子会越过越好,现在的工作虽然没有武汉时那么清闲,偶尔会加班到十一二点,但是年轻人嘛,或者就是折腾得。刚好撑着这个周末其它的一些事情都处理结束了,查看自己的阿里云也马上到期了,(😔 毕业就薅不到这些羊毛了)。但是服务器上还部署着很多服务,所以想着刚好写写自己最近的状态和把服务器上的东西备份一下。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术" scheme="http://blog.simoncode.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Linux" scheme="http://blog.simoncode.top/tags/Linux/"/>
    
    <category term="云服务" scheme="http://blog.simoncode.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Docker" scheme="http://blog.simoncode.top/tags/Docker/"/>
    
    <category term="工作" scheme="http://blog.simoncode.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>实习总结</title>
    <link href="http://blog.simoncode.top/2017/09/03/17-%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2017/09/03/17-%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2017-09-03T10:16:33.000Z</published>
    <updated>2020-06-21T09:49:22.913Z</updated>
    
    <content type="html"><![CDATA[<p>17.7.3-17.9.3 刚好两个月的时间，我觉得我有必要对我的第一次实习做一次总结了。</p><span id="more"></span><h2 id="从第一天说起"><a href="#从第一天说起" class="headerlink" title="从第一天说起"></a>从第一天说起</h2><p>6.30号，因为前天晚上我和室友们一起开放打麻将，早上起来的一场大雨真的是一点面子也没给，我们四个冒着大雨从宾馆冲回了宿舍，因为所有的东西都基本收拾差不多了，我们拿到行李箱之后便向接我们的大巴走去。四个人，三个人去一个地方，而另外一个去其他地方的就是我。庆幸的是我们乘坐的是同一辆车，伴随这忽大忽小的雨我们到达了武汉，一到武汉我感觉我整个人呢愈发的抗拒起来，我抗拒的并不是这座城市，而是马上要去的培训机构。我讨厌去哪里学习一些我丝毫不感兴趣的东西，我讨厌学校的领导把我们当作他们的赚钱工具。好在，我是幸运的，我能够逃离那个地方去另外一个地方继续学习我喜欢的知识。然而那天也发生了很多插曲，比如我害怕纯纯等的太久就自己离开了集合的地方而被班主任简单的批评了一顿。因为不得不面对，和社会上的人商量租房。拖着巨大的行李箱住进了这座我陌生的城市。</p><h2 id="两个月中"><a href="#两个月中" class="headerlink" title="两个月中"></a>两个月中</h2><p>当第一天在公司上完班之后，觉得之前心里的恐惧少了几分。取而代之的是对这座城市的适应，物价和咸宁的区别，生活方式和学校的区别，这些都在慢慢的适应。觉得那些干吧的话我也不知道怎么说了，下面我就从技术方面对自己总结一下。<br>掌握&#x2F;了解到新的技术栈:</p><ul><li>SpringBoot</li><li>Redis</li><li>Hbase</li><li>Vue</li><li>前端</li><li>ELK</li><li>分布式服务</li><li>Nginx</li><li>Maven<br>上面这些我所列举都是我在学校没有听过或者听过从来没有实践过的，但是在这两个月里，我每天都是和这些技术一起。给我最直观的区别就是学校学习的东西和外面用到的东西区别是真的大。我们学校还是在用三大框架，各种xml配置，而学习了SPringBoot之后我觉得这个框架真的大大的减轻了开发的成本。而因为boss的要求，我一个前端小白，也硬着头皮把一个前端项目迁移成为Vue项目。迁移过程中我了解到不少前端的知识，包括WebPack 和jQuery BootStapt 。。。 附上一个我准备详细整理我学习的技术栈的链接戳我<h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2>这次去了之后，打算好好的整理整理自己的简历，秋招我来了！！！</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;17.7.3-17.9.3 刚好两个月的时间，我觉得我有必要对我的第一次实习做一次总结了。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="生活" scheme="http://blog.simoncode.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="技术" scheme="http://blog.simoncode.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>技术小计</title>
    <link href="http://blog.simoncode.top/2017/09/02/16-%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%A1/"/>
    <id>http://blog.simoncode.top/2017/09/02/16-%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%A1/</id>
    <published>2017-09-02T07:49:14.000Z</published>
    <updated>2020-06-21T09:49:22.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术小计"><a href="#技术小计" class="headerlink" title="技术小计"></a>技术小计</h2><blockquote><p> 写在前面，这篇博客的目的主要是总结我在公司实习的这两个月里面所接触的一些新技术栈，因为时间的关系今天就只能跟新我自己弄的ELK监控平台，以后肯定会慢慢把我这两个月学习的补充上去。</p></blockquote><span id="more"></span><h3 id="ELK-日志监控平台"><a href="#ELK-日志监控平台" class="headerlink" title="ELK 日志监控平台"></a>ELK 日志监控平台</h3><blockquote><p> 缘起: 因为实习公司的主要业务就是爬虫,所以所有的服务都是以分布式的方式存在。所以公司就使用ELK搭建了一个日志监控平台。</p></blockquote><p>首先ELK看似是存在三个服务的，就我简单理解。分别为:</p><ul><li>Elasticsearch 处理格式化日志</li><li>Logstash 收集日志</li><li>Kinaba 前台展示</li></ul><p>那我现在就一一讲一下我搭建这个平台的时候碰到的坑。首先这三个服务的所有下载包都可以到Elk下载。</p><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ul><li><p>下载安装包<br><code>wget https://artifacts.elasticco/downloads/elasticsearch/elasticsearch-5.5.2.zip</code></p><ul><li>使用非root用户登陆</li><li>因为Elasticsearch的安全策略，禁止root用户启动，所以需要创建一个非root用户来运行Elasticsearch程序。<code>useradd simon</code></li><li>更换Elasticsearh的工作目录的所有者和组都为<code>simon</code>所有。</li></ul></li><li><p>修改配置文件</p><ul><li>开启服务之前还会遇到一个坑，就是Elasticsearch默认的内存为2g而一般的服务器都不会得到那么大的内存，所以需要到<code>/config/log4j2.properties</code> 修改内存为能顾接受的范围。</li></ul></li><li><p>运行<br>好了到这里Elasticsearch的配置就差不多了,只需要让它默默的跑在后台给我们处理日志就可以了。<code>nohup ./bin/elasticsearch &gt;&amp; nohup.out &amp;</code></p></li><li><p>验证<br>如何看自己的Elasticsearch是否真的运行在后台呢？<br>只需要访问Elasticsearch的服务测试一下就可以<code>curl localhost:9200</code></p></li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><ul><li><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/logstash/logstash-5.5.2.tar.gz  tar -zxvf</code></p></li><li><p>创建输入输出模板<br>前面说过我的浅显理解Logstas就是用来对日志的收集，所以必定存在对日志输入和输出设定。我这里使用的log4j的日志输入，而且Logstash存在log4j的模板，所以我的日志设置为(需要自建文件):<br><code> Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html input &#123; For detail config for log4j as input, See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html log4j &#123;   mode =&gt; &quot;server&quot;   host =&gt; &quot;0.0.0.0&quot;   port =&gt; 4500 &#125; &#125; filter &#123; Only matched data are send to output. &#125; output &#123; For detail config for elasticsearch as output, See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html elasticsearch &#123;   action =&gt; &quot;index&quot;          #The operation on ES   hosts  =&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.   index  =&gt; &quot;applog&quot;         #The index to write data to. &#125; &#125;</code></p></li></ul><p>其中各个参数的含义如下:</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">mode</td><td align="center">server&#x2F;client</td><td align="center">服务器&#x2F;客户端</td></tr><tr><td align="center">host</td><td align="center">string</td><td align="center">服务地址</td></tr><tr><td align="center">port</td><td align="center">int</td><td align="center">服务端口</td></tr><tr><td align="center">antion</td><td align="center">index</td><td align="center"></td></tr><tr><td align="center">hosts</td><td align="center">string</td><td align="center">服务的地址</td></tr><tr><td align="center">index</td><td align="center">Stirng</td><td align="center">parent 的名称</td></tr></tbody></table><p>其中，加入你是把你的ELK放在服务器端的话，就需要把hosy设置成为允许访问的ip即 0.0.0.0</p><ul><li>SpringBoot日志输送</li></ul><p>由于SpringBoot的成熟，所以已经集成了Logstash的日志传输服务，只需要在application.properties中添加:</p><p><code>log4j.appender.logstash=org.apache.log4j.net.SocketAppender log4j.appender.logstash.RemoteHost=your_server_host log4j.appender.logstash.port=4500 log4j.appender.logstash.ReconnectionDelay=60000 log4j.appender.logstash.LocationInfo=true</code></p><p>当然你事先得导入log4j的maven依赖库</p><p><code>&lt;dependency&gt;   &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt;</code></p><ul><li>运行</li></ul><p>当一切准备结束之后，我们就可以让Logstash也默默热运行在后台了<br><code>nohup ./bin/logstash -f log4j.conf *&amp; nohup.out &amp;</code></p><h3 id="Kinaba"><a href="#Kinaba" class="headerlink" title="Kinaba"></a>Kinaba</h3><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/kibana/kibana-5.5.2-linux-x86_64.tar.gz tar -zxvf</code></p><ul><li>配置Kinaba允许外网访问</li></ul><p>进入Kinaba的<code>config/</code>目录下vi Kinaba.yml<br>其中将:</p><ul><li>server.port ：port</li><li>server.host :0.0.0.0</li><li>elasticsearch.url: “<a href="http://localhost:9200“">http://localhost:9200“</a></li></ul><p>设置完毕，看起来Kinaba的设置相比前面起来简单很多。</p><ul><li>运行</li></ul><p>啦啦啦，只需要简单的配置Kinaba的服务可以运行起来了。<br><code>nohup Kinaba &gt;&amp; nohup.out &amp;</code></p><ul><li>测试</li></ul><p>我们可以打开浏览器输入: localhost:port，等一会，我们就可以看到Kinaba的界面了。<br>然后在中我们在配置Logstash设置的index属性：applog，然后我们就可以看到我们的日志文件了。</p><p><strong>最后说一下，三个的服务启动时存在先后顺序的，处理日志的Elasticsearch必须第一个启动，原因是Logstash中设置了文件输出的位置，假设Elasticsearch的服务没有启动的话，就会存在找不到输出文件的错误。同理在Knaba中也设置了读取日志文件的位置。</strong></p><p>好了，到这里一个简单的日志监控平台就搭建完毕了，因为我写的这篇博客完全都是出于个人的理解，所以其中个肯定存在很多问题。仅供参考。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;技术小计&quot;&gt;&lt;a href=&quot;#技术小计&quot; class=&quot;headerlink&quot; title=&quot;技术小计&quot;&gt;&lt;/a&gt;技术小计&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 写在前面，这篇博客的目的主要是总结我在公司实习的这两个月里面所接触的一些新技术栈，因为时间的关系今天就只能跟新我自己弄的ELK监控平台，以后肯定会慢慢把我这两个月学习的补充上去。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>最近的总结</title>
    <link href="http://blog.simoncode.top/2017/05/08/15-%E6%9C%80%E8%BF%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2017/05/08/15-%E6%9C%80%E8%BF%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/</id>
    <published>2017-05-08T12:46:16.000Z</published>
    <updated>2020-06-21T09:49:22.914Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先来一张我最喜欢的照片</strong><br><img src="/images/17.5.8/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%85%AB%E5%B2%81.jpg"></p><blockquote><p>写在前面:晚上解决一个算法问题，解决了一晚上但是并没有解决^_^，所以趁着现在还没有回去的时间对自己最近的生活学习状况进行一个总结。</p></blockquote><span id="more"></span><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h3><p>  说到上课，愈发的觉得自己成为老油条了。大一的时候上课带书又带笔有时候还带草稿本，大二带书带笔，大三沦落到要考试了都不知道带笔去上课。。好在这个学期的考试课很少，大部分的考察课都是可以蒙混过关的。其实说道上课，我就不得不说一下我们BT的学校，上课收手机，院长动不动就冲进来这种事情真的没想到在读大学的我身上发生了，真的无语。讲道理，院里面这样抓我们的学习，应该是很放心我们的就业的，但是动不动就以名曰“就业指导”的口号叫我们去各种培训机构的宣讲会。看来对赚钱的事情果然每个人都是很上心的。说实话虽然在我的心目中是很抵触培训机构的，因为要是去培训结构的话什么不直接不读大学就去呢？非要在大学耽误那么长时间。但是我也不否认培训结构对一些大学没学习(讲道理我也啥都没学到)什么的是一条路子。但是为什么我觉得是屎的东西院里面还要用力往每个人嘴里面喂。。搞不懂搞不懂。。</p><h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><ul><li><p>看完了小甲鱼关于数据结构的视频</p></li><li><p>看完了《剑指Offer》</p></li><li><p>参加了春招的笔试(心痛自己)</p></li><li><p>参与了实验室的一点小项目</p></li><li><p>复习了Java的很多小基础知识</p><p>一本《剑指Offer》开学的时候买的，到今天才算是真真的搞完了(虽然保存到了github,因为都是一些平常学习的代码，所以将仓库私有了，主要还是怕丑^_^)。说实话虽然是看完了，只能说自己以后看到这种编程题目的时候不会再那么畏惧，但是好多思路还是不知道从哪里来。虽然有时候看的也不是很认真，但是毕竟是过了一遍的。发自内心的觉得算法这个东西很强大。关于看完数据结构的C语言版视频虽然也花了很长时间，但是只能说是是加深了其中的某些印象，比如树的结构，二叉树的便利，链表,队列…看过的还是知道一点的。再说说关于春招，觉得还是自己的态度没有摆端正，算法问题一点都不知道，所以做每个公司的编程题目的时候都不知道从何下手，很多问题都是没有听说过，其中关于哈夫曼树和背包问题我花了一下午的时候进行了详细的总结。觉得也算是自己的一点成就吧。既然春招没有用心准备，那就把所有的心思都放在秋招上面咯。只有祝自己好运咯。</p></li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="/images/17.5.8/graduation_photo_1.jpg"><br><img src="/images/17.5.8/graduation_photo_2.jpg"><br>  上个星期四拍完的毕业照，我们院有着个让人不能理解的传统，每届都是在大三的时候拍毕业照。可惜我那天并没有把头发梳成大人模样，哈哈… 现在还记得我们上一届拍毕业照的时候，那天我刚好在实验室，他们抱着一大堆学士服，没想到一转眼就轮到我穿上了。。(话说那天还被他们草柱子了)<strong>现在这里立一个flag：大四毕业的时候一定要喝醉。。</strong>感觉之前的日子有点想不起来了。。(尴尬)<br>    最后再说说和纯纯的事情吧(感觉很少把这种事情写成文字发出来):纯纯现在下定目标准备出国读研了，这就意味着她也是要面临这毕业就就业的问题了。我内心从大一的时候就有这种打算所以对我来说还好，我就怕纯纯到时候有点不能接受。好了这个事情就不扯了。虽说我们两个这个学期也是有点小问题不断，而且我都总结出规律来了(都是星期五的！！！),但是还是坚持下来了，对我来说，在一起之前我都不知道什么叫做”异地恋”,感觉稀里糊涂的就开始了这段恋情。而且稀里糊涂得一起过了这么久，有时候自己想想都觉得有点不可思议。。感觉这个学期结束之前应该没有机会去她哪里了。说起来惭愧大学到现在三年了，去过他们学校的次数真的可以用手指头数出来。。<br>    最后的最后就来说一下去郑州的过程吧。虽然去之前我们还闹着矛盾，原本准备星期五见面的我冲动的买了当天的票，火车上坐了一晚上都是想着见面时候的喜悦。越想越激动，想着待会纯纯见到我的时候的喜悦，坐公交的时候感觉自己都想一到就冲下去的那种。果然所有异地恋都一样，一见面什么问题多解决了。哈哈，还来了一个少林寺一日游。开心。！！<strong>我不知道未来怎么样，我只想好好的过好现在的每一天</strong><br>  最后的最后来几张照片吧。。 哈哈<br><img src="/images/17.5.8/chunchun1.jpg"><br><img src="/images/17.5.8/chunchun2.jpg"><br><img src="/images/17.5.8/chunchun3.jpg"><br><img src="/images/17.5.8/chunchun4.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;先来一张我最喜欢的照片&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/images/17.5.8/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%85%AB%E5%B2%81.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写在前面:晚上解决一个算法问题，解决了一晚上但是并没有解决^_^，所以趁着现在还没有回去的时间对自己最近的生活学习状况进行一个总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="总结" scheme="http://blog.simoncode.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="http://blog.simoncode.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>详细了解哈夫曼树和背包问题</title>
    <link href="http://blog.simoncode.top/2017/04/12/14-%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.simoncode.top/2017/04/12/14-%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2017-04-12T06:47:16.000Z</published>
    <updated>2020-06-21T09:49:22.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详细了解哈夫曼树和背包问题"><a href="#详细了解哈夫曼树和背包问题" class="headerlink" title="详细了解哈夫曼树和背包问题"></a>详细了解哈夫曼树和背包问题</h1><p><B>写在前面</b>：</p><ul><li>最近在疯狂复习数据结构和算法，虽然看完了一部完整的视频。但是转眼看看自己手中的《剑指Offer》里面还是不是很清楚。。。而且最近也突然觉得自己知识和别人比起来就是一个渣渣。各种被人家吊打。。。</li><li><b>这两个算法一个（哈夫曼树）是看最近视频动手实践的，一个(背包问题)是前段时间一个面试里面的题目，当时不知道这是一个系类的问题，昨天和大神聊完天之后才明白。所以乘着短暂的热情还在就记录下来</b>先从哈夫曼树开始！！ <span id="more"></span></li></ul><h3 id="1-哈夫曼树（实现基本的编码解码）"><a href="#1-哈夫曼树（实现基本的编码解码）" class="headerlink" title="1.哈夫曼树（实现基本的编码解码）"></a>1.哈夫曼树（实现基本的编码解码）</h3><ul><li><p>简单定义：<br>   给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>  复杂的文字定义我觉得以后肯定不会看。。所以直接来一张哈夫曼树的构造过程简单明了。。<br>  <img src="/images/17.4.11/huffmanTree.jpg"></p></li></ul><h4 id="1-模型构造"><a href="#1-模型构造" class="headerlink" title="1.模型构造"></a>1.模型构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">String data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">Node leftChild;</span><br><span class="line">Node rightChild;</span><br><span class="line">Node parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String data, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.data = data;</span><br><span class="line"><span class="built_in">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Node [data=&quot;</span> + data + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列排序依据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) (weight - o.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> data.length() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含属性:</p><table><thead><tr><th>属性</th><th>定义</th><th>类型</th></tr></thead><tbody><tr><td>data</td><td>数据</td><td>String</td></tr><tr><td>weight</td><td>权值</td><td>double</td></tr><tr><td>leftChild</td><td>左节点</td><td>Node</td></tr><tr><td>rightChild</td><td>右节点</td><td>Node</td></tr><tr><td>parent</td><td>父节点</td><td>Node</td></tr></tbody></table><h4 id="2-统计字符出现的次数，用出现的次数作为权值"><a href="#2-统计字符出现的次数，用出现的次数作为权值" class="headerlink" title="2.统计字符出现的次数，用出现的次数作为权值"></a>2.统计字符出现的次数，用出现的次数作为权值</h4><ul><li>这里实现的思路是：将出现的字符串(C)和次数(count)保存为一个Map&lt;字符，次数&gt;对象,然后再保存为List集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">statistics</span><span class="params">(<span class="type">char</span>[] charArray)</span> &#123;</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : charArray) &#123;</span><br><span class="line"><span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(character)) &#123;</span><br><span class="line">map.put(character, map.get(character) + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(character, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">statisticsProbability</span><span class="params">(Map&lt;Character, Integer&gt; maps)</span> &#123;</span><br><span class="line">List&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TestHuffmanTree_Encode_Decode.Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; map : maps.entrySet()) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(map.getKey().toString(), map.getValue());</span><br><span class="line">list.add(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-根据统计的List进行哈夫曼树的构造"><a href="#3-根据统计的List进行哈夫曼树的构造" class="headerlink" title="3.根据统计的List进行哈夫曼树的构造"></a>3.根据统计的List进行哈夫曼树的构造</h4><p>首先List中保存的就是Node集合，其中Node的data就是字符串，Node的weight就是出现的次数也就是权值<br><B>哈夫曼树的构造:</B>   </p><ul><li>首先利用Java中的priorityQueue<E>方法进行模拟队列<br> priorityQueue<E>的用法 <!-- 插入图片-->  其中主要的方法：<table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>将指定元素插入到次优先级队列</td></tr><tr><td>poll</td><td>获取并且移除队列头</td></tr><tr><td>peek</td><td>获取但是不移出队列</td></tr></tbody></table></li><li>将List中的数据保存到队列里面去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PriorityQueue&lt;Node&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">priorityQueue.add(nodes.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><b>然后利用poll方法获取队列头节点</b>,这里可能就由疑问了，哈夫曼树不是要求按照权值最小的两个开始组成树嘛。这里为什么随便从队列里面弄两个出来就可以。<br>其实是这样的;在Node定义的时候实现了Comparable<Node>接口并且实现了compareTo（E e）方法，这里其实就已经实现了队列里面的排序<!--插入图片--></li><li>然后构建两个子节点的父节点，并且声明三者之间的关系(父子，左右)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 构建父节点</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">sumNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node1.data + node2.data, node1.weight</span><br><span class="line">+ node2.weight);</span><br><span class="line"></span><br><span class="line">sumNode.leftChild = node1;</span><br><span class="line">sumNode.rightChild = node2;</span><br><span class="line"></span><br><span class="line">node1.parent = sumNode;</span><br><span class="line">node2.parent = sumNode;</span><br></pre></td></tr></table></figure><ul><li>然后再将父节点保存到队列中去:这样做的目的是为了得到根节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(sumNode);</span><br></pre></td></tr></table></figure></li><li>最后返回根节点 priorityQueue.poll();</li></ul><p><B>这样，到这里哈夫曼树的构建就完成了，但是既然学习了就深入一点，<br>哈夫曼树的最长用途就是用来文件压缩，因为我们知道发送一句话的时候并不是每个字母出现的频率都是一样的，有的出现的多有的出现的少，但是如果还是使用一样额编码那样会有很大的消耗，所以这里我们就用哈夫曼树实现对字符串的编码和解码</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;详细了解哈夫曼树和背包问题&quot;&gt;&lt;a href=&quot;#详细了解哈夫曼树和背包问题&quot; class=&quot;headerlink&quot; title=&quot;详细了解哈夫曼树和背包问题&quot;&gt;&lt;/a&gt;详细了解哈夫曼树和背包问题&lt;/h1&gt;&lt;p&gt;&lt;B&gt;写在前面&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最近在疯狂复习数据结构和算法，虽然看完了一部完整的视频。但是转眼看看自己手中的《剑指Offer》里面还是不是很清楚。。。而且最近也突然觉得自己知识和别人比起来就是一个渣渣。各种被人家吊打。。。&lt;/li&gt;
&lt;li&gt;&lt;b&gt;这两个算法一个（哈夫曼树）是看最近视频动手实践的，一个(背包问题)是前段时间一个面试里面的题目，当时不知道这是一个系类的问题，昨天和大神聊完天之后才明白。所以乘着短暂的热情还在就记录下来&lt;/b&gt;先从哈夫曼树开始！！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android开源框架总结</title>
    <link href="http://blog.simoncode.top/2017/03/14/13-Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.simoncode.top/2017/03/14/13-Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</id>
    <published>2017-03-14T10:52:02.000Z</published>
    <updated>2020-06-21T09:49:22.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Andorid开源框架总结"><a href="#Andorid开源框架总结" class="headerlink" title="Andorid开源框架总结"></a>Andorid开源框架总结</h1><blockquote><p>本文章转载自:<a href="http://www.jianshu.com/p/e94007f59e8d">zhuozhou810</a>，然后结合自己日常学习中用到的一些框架总结，谢谢！！！         </p></blockquote><ul><li><b>写在前面:</b><br> 最近通过Hexo+github终于弄成了一个自己像模像样的<a href="http://www.simoncode.top/">Blog</a>网站了。虽然都是跟着教程弄的，但是还是遇到了不少坑啊!四天的时间帮老师完成了一个很小的Demo，做完的时候其实内心还是很激动的。突然想到要不是写这个Demo我应该开学到现在还没有撸过代码。<br> <b>总结一下：</b>使用阿里云解析的时候记录值为:@+www，在github.io中添加CNAME指定xx域名<span id="more"></span><h2 id="图片总结"><a href="#图片总结" class="headerlink" title="图片总结"></a>图片总结</h2><img src="/images/%E5%AE%89%E5%8D%93%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.png"></li></ul><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul><li><a href="#%E7%BD%91%E7%BB%9C">网络</a>  </li><li><a href="#%E5%BD%B1%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86">影视频处理</a></li><li><a href="#View+Layout">View+Layout</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库操作</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E5%B1%82">系统层</a></li></ul><h2 id="网络">网络</h2>* <b>[OkHttp](https://github.com/square/okhttp):比较全面的网络框架</b>* <b>[retrofit](https://github.com/square/retrofit):okhttp注解封装框架</b>* <b>[xutils3](https://github.com/wyouflf/xUtils3)：我使用最多的网络请求框架</b>* <b>[nohttp](https://github.com/yanzhenjie/NoHttp):请求日志很好的开源框架</b><h2 id="影视频处理">影视频处理</h2>* <h3>视频播放</h3>   * <b>[JieCaoVideoPlayer ](https://github.com/lipangit/JieCaoVideoPlayer)</b>* <h3>图片选择</h3>   * <b>[GalleryFinal ](https://github.com/pengjianbo/GalleryFinal)</b>* <h3>图片裁剪</h3>   * <b>[cropper ](https://github.com/edmodo/cropper):图片裁剪</b>   * <b>[PhotoView](https://github.com/bm-x/PhotoView):图片缩放</b>* <h3>图片加载</h3>   * <b>[picasso](https://github.com/square/picasso)</b>   * <b>[smartimageview](https://github.com/JackCho/SmartImageView)</b>* <h3>动画效果</h3><b>   * [SmoothCheckBox](https://github.com/andyxialm/SmoothCheckBox):CheckBox   * [MaterialEditText](https://github.com/rengwuxian/MaterialEditText):EditText   * [SmoothProgressBar](https://github.com/castorflex/SmoothProgressBar):ProgressBar   * [ExplosionField](https://github.com/tyrantgit/ExplosionField):视图爆炸效果</b><h2 id="View+Layout">View Layout</h2>* <h3>屏幕适配</h3>  * <b>[AndroidAutoLayout](https://github.com/hongyangAndroid/AndroidAutoLayout):Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配</b>  * <b>[android-percent-support-lib-sample](https://github.com/JulienGenoud/android-percent-support-lib-sample):一个简单的Android适配库</b>* <h3>图表控件</h3>  * <b>[hellocharts-android](https://github.com/lecho/hellocharts-android):图表支持滚动，缩放和动画</b>  * <b>[MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):一个流行的Android图标表</b>* <h3>ViewPager相关</h3>  * <b>[InfiniteCycleViewPager](https://github.com/Devlight/InfiniteCycleViewPager):viewpage双向取向和互动效果</b>* <h3>ViewPager指示器</h3> <b>  * <b>[MagicIndicator](https://github.com/hackware1993/MagicIndicator):强大，可定制，易拓展的ViewPager指示器</b>  * <b>[NavigationTabBar](https://github.com/Devlight/NavigationTabBar):导航标签栏和丰富多彩的交互 </b>* <h3>列表拖动排序、滑动删除、侧滑菜单等</h3>    * <b>[SwipeRecyclerView](https://github.com/yanzhenjie/SwipeRecyclerView):下拉刷新框架 </b>   * <b>[DragRecyclerView](https://github.com/AleBarreto/DragRecyclerView):ListView支持拖 </b>* <h3>Android布局</h3>    * <b>[FlowLayout](https://github.com/hongyangAndroid/FlowLayout):Android流式布局，支持单选、多选等，适合用于产品标签等。  </b>* <h3>Fragment使用简化</h3>    * <b>[Fragmentation](https://github.com/YoKeyword/Fragmentation):一个管理Android Fragment的框架</b>* <h3>字母导航栏</h3>    * <b>[ZzLettersSideBar](https://github.com/zhouzhuo810/ZzLettersSideBar):字母导航栏</b>   * <b>[IndexableRecyclerView](https://github.com/YoKeyword/IndexableRecyclerView):提供城市选择和联系人选择等索引功能</b>* <h3>角标</h3>    * <b>[android-viewbadger](https://github.com/jgilfelt/android-viewbadger):类似QQ消息通知时候的角标</b>* <h3>二维码扫描</h3>    * <b>[barcodescanner](https://github.com/dm77/barcodescanner)：二维码扫描的库</b>* <h3>侧滑菜单</h3>   *  <b>[AndroidResideMenu](https://github.com/SpecialCyCi/AndroidResideMenu):侧滑菜单栏</b><h2 id="数据库">数据库操作</h2>   * <b> [xutils3](https://github.com/wyouflf/xUtils3):强大的Android开源框架</b><h2 id="系统层">系统层</h2>* <h3>内存管理</h3>   * <b>[leakcanary](https://github.com/square/leakcanary):Android和Java内存管理的开源库</b><ul><li><h3>6.0权限管理</h3> * <b>[AndPermission](https://github.com/yanzhenjie/AndPermission):Android 6.0运行时权限管理</b></li><li><h3>线程间通信、组件间通信</h3>  * <b>[EventBus](https://github.com/greenrobot/EventBus)</b></li><li><h3>蓝牙、摄像头相关</h3> * <b>[FastBle](https://github.com/Jasonchenlijian/FastBle):蓝牙快速开发框架</b></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Andorid开源框架总结&quot;&gt;&lt;a href=&quot;#Andorid开源框架总结&quot; class=&quot;headerlink&quot; title=&quot;Andorid开源框架总结&quot;&gt;&lt;/a&gt;Andorid开源框架总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文章转载自:&lt;a href=&quot;http://www.jianshu.com/p/e94007f59e8d&quot;&gt;zhuozhou810&lt;/a&gt;，然后结合自己日常学习中用到的一些框架总结，谢谢！！！         &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;写在前面:&lt;/b&gt;&lt;br&gt; 最近通过Hexo+github终于弄成了一个自己像模像样的&lt;a href=&quot;http://www.simoncode.top/&quot;&gt;Blog&lt;/a&gt;网站了。虽然都是跟着教程弄的，但是还是遇到了不少坑啊!四天的时间帮老师完成了一个很小的Demo，做完的时候其实内心还是很激动的。突然想到要不是写这个Demo我应该开学到现在还没有撸过代码。&lt;br&gt; &lt;b&gt;总结一下：&lt;/b&gt;使用阿里云解析的时候记录值为:@+www，在github.io中添加CNAME指定xx域名</summary>
    
    
    
    <category term="Android" scheme="http://blog.simoncode.top/categories/Android/"/>
    
    
    <category term="Android" scheme="http://blog.simoncode.top/tags/Android/"/>
    
    <category term="框架" scheme="http://blog.simoncode.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="github" scheme="http://blog.simoncode.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结-下</title>
    <link href="http://blog.simoncode.top/2017/03/01/12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E4%B8%8B/"/>
    <id>http://blog.simoncode.top/2017/03/01/12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E4%B8%8B/</id>
    <published>2017-03-01T06:37:23.000Z</published>
    <updated>2022-02-07T01:28:59.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h2><ul><li><p>思路：堆就是一个完全二叉树（小顶堆），</p></li><li><p>主要解决两个问题:</p><ul><li><p>如何将n个待排序的数构建成堆</p><ul><li>输出堆顶元素之后如何调整剩下的n-1个元素，使之成为新的堆</li></ul></li></ul></li><li><p>时间复杂度:O(nlogn)</p><span id="more"></span><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3></li></ul><p><img src="http://img.blog.csdn.net/20170301143400796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><p><img src="http://img.blog.csdn.net/20170301143445485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            buildMaxHeapify(a);</span><br><span class="line">            heapSort(a);</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;****4.堆排序之后:****&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建初始最大堆</span></span><br><span class="line">        <span class="comment">// 假设长度为8 那么</span></span><br><span class="line">        <span class="comment">// 第一个父节点就是a[3] 左结点为:a[7]</span></span><br><span class="line">        <span class="comment">// 第二个父节点为:a[1] 左节点为:a[3] 右结点为:a[4]</span></span><br><span class="line">        <span class="comment">// 第三份父节点为:a[2] 左节点为:a[5] 右结点为:a[6]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeapify</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;字符串的长度为:&quot;</span> + a.length);</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> getParentIndex(a.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                maxHeapify(a, a.length, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         *            数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">         *            数据长度</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">         *            当前的父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> length, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="comment">// 与当前左右结点进行比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getChildLeftIndex(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getChildRightIndex(index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行左右节点值的对比</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; length &amp;&amp; a[left] &gt; a[index]) &#123;</span><br><span class="line">                largest = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; length &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">                largest = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">                a[index] = a[largest];</span><br><span class="line">                a[largest] = temp;</span><br><span class="line">                <span class="comment">// 整理节点</span></span><br><span class="line">                maxHeapify(a, length, largest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左孩子的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildLeftIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右孩子的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildRightIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个函数的含义就是： 将排好的最大堆的堆顶和最后一个交换再进行最大堆排序 排序：最大值放在末尾，再次进行排序</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">                a[<span class="number">0</span>] = a[i];</span><br><span class="line">                a[i] = temp;</span><br><span class="line">                maxHeapify(a, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5.冒泡排序"></a>5.冒泡排序</h2><ul><li><p>思路：就是不断的两两比较</p></li><li><p>时间复杂度:O(n^2)</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="http://img.blog.csdn.net/20170301143536765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的冒泡排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort_A</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-i- <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        Swap(a, j, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//改进的冒泡，添加了标记</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort_B</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        pos = i;</span><br><span class="line">                        Swap(a, i, i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                n = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><ul><li><p>思路：</p><ul><li>选择一个基准元素</li><li>通过一次快排序将待排序数分为两个部分，一部分比基准数小，一部分比基准数大</li><li>然后接着对这两部分进行相同的操作，直到序列有序</li></ul></li><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度: O(nlogn)</p><h3 id="图解：-1"><a href="#图解：-1" class="headerlink" title="图解："></a>图解：</h3><p><img src="http://img.blog.csdn.net/20170301143550828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">privotLoc</span> <span class="operator">=</span> partition(a,low,high);</span><br><span class="line">                quickSort(a, low, privotLoc-<span class="number">1</span>);</span><br><span class="line">                quickSort(a, privotLoc+<span class="number">1</span>, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">privotKey</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=privotKey)--high;<span class="comment">//从后半部分向前扫描</span></span><br><span class="line">                a[low] = a[high];</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=privotKey)++low; <span class="comment">//从前部分扫描</span></span><br><span class="line">                a[high] = a[low];</span><br><span class="line">            &#125;</span><br><span class="line">            a[high] = privotKey;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;4-堆排序&quot;&gt;&lt;a href=&quot;#4-堆排序&quot; class=&quot;headerlink&quot; title=&quot;4.堆排序&quot;&gt;&lt;/a&gt;4.堆排序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;思路：堆就是一个完全二叉树（小顶堆），&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主要解决两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何将n个待排序的数构建成堆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出堆顶元素之后如何调整剩下的n-1个元素，使之成为新的堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间复杂度:O(nlogn)&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://blog.simoncode.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://blog.simoncode.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://blog.simoncode.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="http://blog.simoncode.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
