<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>路在远方，努力不止！！！</title>
    <url>/2016/05/13/01-%E8%B7%AF%E5%9C%A8%E8%BF%9C%E6%96%B9%EF%BC%8C%E5%8A%AA%E5%8A%9B%E4%B8%8D%E6%AD%A2%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<p><span style="color:#ff6666">写给自己：<span style="white-space:pre"> </span>作为一个理科生，我认为我自己很难写出那种感动人的文字和带着浓厚笔墨味文章，所以我只是想在这里默默的发布者我自学Android的学习心得。</span></p>
<span id="more"></span>

<p>大二下的我还在迷茫，大一上加入实验室C语言，对如刚刚上大学的我来说大学太好玩了，没有高中的约束没有作业，有很多很多的时间可以去打游戏可以不用去想哪一些烦心的事情，所以我虽然在实验室，但是贪玩的我很少待在哪里，C语言惨败。大一下，我在学长的指导下自学了C#那时候的我很勤奋，有时间就劲量待在哪里，我觉得大一下的生活很充实，我学到了很多东西，也觉得时间过得好慢，每天都是满满的，虽然周末也是去打游戏，但是我起码花费了时间在学习上面。大二上对我来说是惨淡的，现在想起来我都不知道我的大二上到底是干了什么。。每天待在宿舍的打游戏打游戏打游戏，期末没有复习玩玩玩，果然我迎来了大学的第一次挂科并且还是一次挂了两科！！可怕。现在想起来对如那时候的回忆一点也没有。只知道LOL还有睡觉。可能是上天也看不下去我整天的打游戏了吧。希望我好好努力来扛起我加的重担。虽然大二下到现在才两个多月但是我觉得我每天都是满满的，除了晚上睡觉我要不是在实验室学习就是在上课。一个多月我学完了javaEE虽然不是很精通，也没有和他们一起做过任何项目，但是我觉得能过多学一点起码是有一点谈资的。我开始准备是这个学期学习wab下个学期在去学习Android但是我觉得留给我的时间不多了。第一本书就是看了好多帖子说的&lt;第一行代码&gt;。我差不多花了半个月看完的吧，索然看的不是很清楚，但是我准备再看一遍。<span style="color:#ff0000">所以我还在路上，朝着生活追赶！！！</span></p>
<span style="color:#ff6666">

</span>

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>生活</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个Android Demo :Chat(伪即时通讯)</title>
    <url>/2016/05/30/02-%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid-Demo-Chat-%E4%BC%AA%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p><strong>说明</strong>：上一篇文章因为我对这个写博客还不是很了解，所以造成了页面很乱的情况，所以看到之后马上修改</p>
<p>学习Android到现在估计应该还不到一个月的时间，我很激动能够在自己的努力还有奋斗下开发一个自己想要的App,虽然这个App的功能还不够完善，界面很丑陋，Bug很存在很多，但是我觉得这个起码是我自己动用智慧开发的第一个App,所以我要在这里将我开发的思路还有一个想法写在这里。</p>
<span id="more"></span>
<p>以实现功能：<br>即时通讯：不同好友之间可以即时通讯。但是同时只能和一个人通讯。<br>注   册：注册功能实现，但是数据保存的是客户端，即是在Android本地的数据库，并没有将用户保存到服<br>服务器。<br>登   录：登录会自动和本地数据库中进行校对,基本的登录思想。<br>添加好友：当前数据库中存在好友时，可以实现添加到好友列表。Bug：Sqlite的用法还是不够熟练，<br>当存在该好友的情况下还是可以继续添加该还有</p>
<p>用到的知识：<br>基本的Android界面布局，Sqlite，Servlet（服务器端），JavaBean思想，Http协议，Android中的<br>Http操作，ListView，自定义ArrayAdapter,Android中Activity的生命周期，Activity中的定时操<br>作，异步处理，子线程处理。</p>
<pre><code>功能详解：
Login（登录页面）：
</code></pre>
<p><img src="http://img.blog.csdn.net/20160527124853791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>    作为App的主页面，虽然丑陋了一点，但是它起到的作用也就是仅仅登录作用，当点击登录之后，会自动<br>    和本地数据库中做校验，存在即登录，失败即提示无法登陆；<br>    <img src="http://img.blog.csdn.net/20160527125415498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p>
<pre><code>Regist(注册页面)：
和登录洗洗相关的，登录即少不了注册;
</code></pre>
<p><img src="http://img.blog.csdn.net/20160530162332841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>这个是我注册的主界面，提供了用户名，密码注册选项，其中后台数据库并没有使用Base64,和md5进行加密。<br>其中在后台会自动为每一个UUID作为主键，保证每个人的信息不同，其中用户名时唯一存在的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();</span><br></pre></td></tr></table></figure>

<p>当数据库存在该用户时：<br><img src="http://img.blog.csdn.net/20160530163011536" alt="这里写图片描述"><br>数据库中保存的情况：</p>
<p><img src="http://img.blog.csdn.net/20160530163220229" alt="这里写图片描述"></p>
<p>FriendList(好友列表)：</p>
<p><img src="http://img.blog.csdn.net/20160530163420366" alt="这里写图片描述"><br>此处是用来显示自己的好友；还提供添加好友的按钮和逻辑<br>实现思想：创建一个JavaBean,包含当前用户和用户所有的好友List<Friend>，并在数据库中创建相关的表。<br>当接收从登陆界面获得的User时，用得到的User和数据库中的当前用户做比较，返回所有的List<Friend>。</p>
<p>复写：ArrayAdapter，添加选中事件。</p>
<p>AddFriend(添加好友页面):</p>
<p><img src="http://img.blog.csdn.net/20160530163923744" alt="这里写图片描述"><br>输入需要查找的好友；如果存在：</p>
<p><img src="http://img.blog.csdn.net/20160530163929338" alt="这里写图片描述"><br>找到该好友并且提供添加。</p>
<p><img src="http://img.blog.csdn.net/20160530163933800" alt="这里写图片描述"><br>点击OK之后会在数据中将该好友的信息添加到该用户的好友列表中去。</p>
<p>但是当不存在时，会提示不存在该好友。</p>
<p>已知Bug:<br>由于对Sqlite的使用不是很熟练,导致不能判断在该用户的好友列表是否已经存在该好友，导致可以重复添加单个用户。</p>
<p>Chat(聊天)：<br>这个应该才是重点。<br>基本界面：</p>
<p><img src="http://img.blog.csdn.net/20160530164433387" alt="这里写图片描述"></p>
<p>很简陋的一个页面。当点击了该还有之后便可以实现好友之间的通讯。</p>
<p>演示图：</p>
<p><img src="http://img.blog.csdn.net/20160530164940798" alt="这里写图片描述"></p>
<p>基本思想：使用的是Http协议进行通讯，后台是使用Servlet写的。</p>
<p>发送消息：每个用户进行发消息，会将当前的消息内容，当前用户，目的用户发送到后台的Servlet。后台接受到所有用户发送的消息，保存到一个Bean类中去。</p>
<p>接受消息：在MainActivity创建一个定时操作。一直访问后台的Servlet。后台通过访问接受到数据进行分辨，将该用户的信息返回。（为了研究那个定时操作，我用掉了手机100多M流量）;</p>
<p>因为学过一段时间的JavaWab所以还是有一点点后台基础的。。。</p>
<p>好了 我这个第一个AndroidDemo Chat在这里也介绍完了。希望Csdn中的大牛能够指出我的错误和不足的地方，我好进步。</p>
<p>写完这个博客我很激动，毕竟这个是我第一Android项目，并且也是第一个技术贴。我很懒不是很喜欢打那么多字，但是这个博客慢慢的就写完了。。。</p>
<p>分享下自己下段时间的打算：</p>
<pre><code>        Android生命周期的更深层次理解
        Android动画相关知识
        Android基本手势操作
        JavaIo流的复习和深入
</code></pre>
<p>*****虽然我现在还是个菜鸟，但是我相信我还是可以飞的！！！！！！！！！！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BadgeView开源项目的使用.md</title>
    <url>/2016/10/17/03-BadgeView%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8-md/</url>
    <content><![CDATA[<p><font color="red" size="5">BadgeView开源项目的使用</font></p>
<span id="more"></span>
<h2 id="第一步：导入jar包"><a href="#第一步：导入jar包" class="headerlink" title="第一步：导入jar包"></a>第一步：导入jar包</h2><pre><code>badgeview.jar
</code></pre>
<h2 id="第二步：初始化BadgeView"><a href="#第二步：初始化BadgeView" class="headerlink" title="第二步：初始化BadgeView"></a>第二步：初始化BadgeView</h2><pre><code>Private BadgeView badgeView;
 protected void onCreate(Bundle savedInstanceState) &#123;
   super.onCreate(savedInstanceState);
   badgeView = new BadgeView(getApplicationContext());
 &#125;
</code></pre>
<h2 id="第三步：设置BadgeView的属性"><a href="#第三步：设置BadgeView的属性" class="headerlink" title="第三步：设置BadgeView的属性"></a>第三步：设置BadgeView的属性</h2><ul>
<li><p>设置小红点中显示的数量</p>
<p><code>badgeView.setBadgeCount(int)；</code></p>
</li>
<li><p>设置小红点是附着在那个View上面<br><code>badgerView.setTargetView(TargetView);</code></p>
</li>
<li><p>设置所处小红点的位置<br><code>setBadgeGravity(Gravity) </code></p>
</li>
<li><p>设置小红点的背景颜色<br><code>setBackgroundColor()</code></p>
</li>
<li><p>设置小红点的背景图片<br><code>setBackgroundResource()</code></p>
</li>
<li><p>设置字体的阴影<br><code>setShadowLayer()</code></p>
</li>
<li><p>设置显示的字体<br><code>setTypeface()</code></p>
</li>
</ul>
<h2 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h2><p><img src="http://img.blog.csdn.net/20161017203510198" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>java中IO流的操作</title>
    <url>/2016/10/31/04-Java%20%E4%B8%ADIO%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Io流操作"><a href="#Io流操作" class="headerlink" title="Io流操作"></a>Io流操作</h1><p>File file &#x3D; new File(“文件路径”)<br>file.exists:文件是否存在<br>file.createNewFile:创建新的文件<br>file.delete:删除文件</p>
<span id="more"></span>
<p>file.getParent:返回父目录<br>file.makedir:创建目录<br>file.isDirectory:判断文件是不是目录<br>file.list()：返回目录下所有目录包括文件的名称<br>file.listFiles()：返回子目录下所有的文件<br>输入流InputStream<br>in.read(byte[] byte);直接将读入的放在byte中去<br>int.write(byte[] byte,int start ,int size):字节数据byte从start位置开始读size长度的字节到流<br>输出流OutSteam<br>out.write(byte[] byte):将byte自己数据直接写入到流<br>out.write(byte[] byte,int start ,int size):字节数据byte从start位置开始写size长度的字节到流<br>FileInputStream：将文件作为字节流，进行读的操作！<br>通常利用文件缓冲进行文件的读取，用来提高读取大文件的效率<br>FileOutputStream：实现向文件写出字节数据的方法<br>DataOututStream&#x2F;DataInputStream<br>对“流”功能的拓展，可以更加方便的读取int，long，字符等类型数据<br>不再是只读字节的前八位<br>DataOutStream out &#x3D; new DataOutStream(new FileOutStream(file));<br>DataInpuyStream in &#x3D; new DataIntStream(new FileInputStream(file));<br>BufferedInputStream&#x2F;BufferedOutputStream<br>这两个流为IO提供带缓冲区的操作，一般打开文件进行写入或者读取时，都会加上缓冲，这种流模式提高了IO的性能。<br>FileOutStream—&gt;write()方法相当于将一滴滴的”水“转移到”缸“中<br>DataOutStream—&gt;write()方法相当于一瓢瓢地把“水”放到“缸”中<br>BufferedOutStream—&gt;write()方法相当于先一瓢瓢地把“水”方法到“桶”中去，然后再放到”缸“中去<br>字符流(默认按照项目编码来读写的)：<br>InputStreamReader :完成byte流解析为char流<br>OutputStreamWrite :提供char流到byte流的解析</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>Io流</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub代码提交过程</title>
    <url>/2016/11/07/05-GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="GitHub代码提交"><a href="#GitHub代码提交" class="headerlink" title="GitHub代码提交"></a>GitHub代码提交</h2><span id="more"></span>

<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://img.blog.csdn.net/20161107124237507" alt="这里写图片描述"></p>
<h4 id="Linux系统提交代码过程"><a href="#Linux系统提交代码过程" class="headerlink" title="Linux系统提交代码过程"></a>Linux系统提交代码过程</h4><blockquote>
<h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5></blockquote>
<p>安装git环境 <code>sudo apt-get install git-core</code></p>
<blockquote>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5></blockquote>
<p>在github网站创建代码仓库 </p>
<p><img src="http://img.blog.csdn.net/20161107125311677" alt="这里写图片描述"></p>
<p>复制Clone地址： </p>
<p><img src="http://img.blog.csdn.net/20161107125457052" alt="这里写图片描述"></p>
<blockquote>
<h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5></blockquote>
<ul>
<li><p>进入项目目录<br><img src="http://img.blog.csdn.net/20161107125558118" alt="这里写图片描述"></p>
</li>
<li><p>将代码仓库复制到本地<br><font color="red">代码</font><code>git clone xxxxxxxxxxxxxxx</code></p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20161107125712474" alt="这里写图片描述"></p>
<ul>
<li><p>将代码仓库复制到本地之后，项目目录中就会有复制下来的文件<br><img src="http://img.blog.csdn.net/20161107130206580" alt="这里写图片描述"></p>
</li>
<li><p>进入到clone下来的文件夹，将复制下来的<font color="red">.git</font>文件和<font color="red">README.md</font>文件复制到项目目录下</p>
</li>
</ul>
<p><font color="red">代码如下：</font><code>cp -r .git/  /home/wang/桌面/Spring</code></p>
<p><img src="http://img.blog.csdn.net/20161107130429458" alt="这里写图片描述"></p>
<p><code>cp -r README.md /home/wang/桌面/Spring</code> </p>
<p><img src="http://img.blog.csdn.net/20161107130609181" alt="这里写图片描述"></p>
<ul>
<li>看一看项目文件夹下是否存在刚刚复制的文件</li>
<li>删除clone下来的文件<br><code>rm -rf Spring/</code></li>
</ul>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><ul>
<li><p>将文件添加到git上面<br><code>git add .</code><br><strong>add . 就是讲所有的文件添加</strong></p>
</li>
<li><p>添加提交注释<br><code>git commit -m &quot;提交注释&quot;</code><br><strong>”“中就是提交的注释</strong></p>
</li>
<li><p>将代码提交到远程版本控制库<br><code>git push origin master</code></p>
</li>
<li><p>输入账号和密码<br><img src="http://img.blog.csdn.net/20161107130713041" alt="这里写图片描述"><br>等输入完就提交完了</p>
</li>
</ul>
<p>然后再查看你的github库就发现本地的代码提交上去了 </p>
<p><img src="http://img.blog.csdn.net/20161107130840775" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>GitHub	</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>XML基础知识总结</title>
    <url>/2016/11/24/06-XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Xml基础知识"><a href="#Xml基础知识" class="headerlink" title="Xml基础知识"></a>Xml基础知识</h1><blockquote>
<p>写在前面:今天有时间就把以前学习JavaEE的时候记录的笔记总结了一下。<br>  主要包含XMl的基础和解析技术。</p>
</blockquote>
<span id="more"></span>

<br/>

<br/>

<h2 id="1-XML属性"><a href="#1-XML属性" class="headerlink" title="1.XML属性"></a>1.XML属性</h2><p><b><?xml version="1.0" encoding="gbk"?></b></p>
<blockquote>
<ul>
<li>xml的声明文件（必须写在第一行第一列）</li>
</ul>
</blockquote>
<ul>
<li><p>vareion:版本 encoding:编码gbk utf-8</p>
</li>
<li><p>乱码是因为属性的编码情况和系统的不一样</p>
</li>
</ul>
<br/>

<br/>

<br/>

<br/>

<h2 id="2-XML得约束：排除一些不需要的条件"><a href="#2-XML得约束：排除一些不需要的条件" class="headerlink" title="2.XML得约束：排除一些不需要的条件"></a>2.XML得约束：排除一些不需要的条件</h2><br/>

<h3 id="dtd约束"><a href="#dtd约束" class="headerlink" title="dtd约束:"></a><b>dtd约束:</b></h3><p><b> 1.创建后缀名为.dtd文件 </b></p>
<blockquote>
<p>1.看xml中有多少个元素，有多少个就在dtd中写几个&lt;!ELEMENT&gt;</p>
</blockquote>
<blockquote>
<p>2.看元素什么为<b>简单元素（没有字元素）</b>和<b>复杂元素（含有子元素）</b></p>
</blockquote>
<blockquote>
<blockquote>
<p>复杂元素：元素名称 （子元素名称）<!ELEMENT 元素名称“这个之间必须有空格”(子元素名称）></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>简单元素：元素名称 （#PCDATA）</p>
</blockquote>
</blockquote>
<blockquote>
<p>3.dtd文件的导入：</p>
</blockquote>
<!DOCTYPE 根元素名称 SYSTEM "文件的路径">

<p><b>2.在xml中直接使用dtd约束</b></p>
<!DOCTYPE 根元素名称 ["定义的<!ELEMENT><p>“]&gt; 使用这种方法直接将dtd放在xml中</p>
<p><b>3.元素的约束：</b></p>
<p><img src="/7ca0c1e9-077e-4005-a0b5-d166266627e0_files/DTD_u5C5E_u6027_u7684_u5B9A_u4E49.png" alt="DTD属性的定义.png"></p>
<p><em><b>1.简单元素的约束（没有子元素的约束）</b></em></p>
<blockquote>
<p>(#PCDATA):元素为字符串类型</p>
</blockquote>
<blockquote>
<p>EMPTY:元素的值为空</p>
</blockquote>
<blockquote>
<p>ANY：随便什么都可以</p>
</blockquote>
<p><em><b>2.复杂元素的约束（有子元素的约束）</b></em></p>
<blockquote>
<!DOCTYPE 复杂元素 （子元素）[]>
</blockquote>
<blockquote>
<p>都是放在样约束的后面</p>
</blockquote>
<blockquote>
<p><b>+:</b>表示子元素出现一次或者多次</p>
</blockquote>
<blockquote>
<p><b>?:</b>表示子元素出现零次或者一次</p>
</blockquote>
<blockquote>
<p><b>*:</b>表示子元素随便都可以</p>
</blockquote>
<blockquote>
<p>子元素之间用逗号<b>“,”</b>隔开： 表示子元素出现的顺序</p>
</blockquote>
<blockquote>
<p>子元素之间用竖线<b>“|”</b>隔开： 表示子元素只能出现其中的任意一个</p>
</blockquote>
<p><b>4.元素属性的定义：</b></p>
<p><b><!ATTLIST 元素名称 属性名 属性类型 属性约束></b></p>
<p><em><b>属性类型：</b></em></p>
<p><b>CDATA：</b>字符串类型的值</p>
<p><b>枚举类型：</b>值必须为定义中的一个 定义（aaa|bbb|ccc）</p>
<p><b>ID:</b>属性的值不能重复，且只能由字母下划线开头</p>
<p><em><b>属性约束：</b></em></p>
<p><b>#REQUIRED:</b>表示该属性必须出现</p>
<p><b>#IMPLIED:</b>表示该属性出现可有可无</p>
<p><b>#FIXED:</b>该属性的值为固定值 语法：#FIXED “值”</p>
<p><b>直接为值：</b>该值为属性的默认值</p>
<p><b>5.实体的定义</b></p>
<p>&lt;ENTITY 实体名 “实体值”&gt; 使用&amp;实体名; 记得分号 一般都是写在内部定义的</p>
<br/>

<br/>

<h3 id="Schema约束："><a href="#Schema约束：" class="headerlink" title="Schema约束："></a>Schema约束：</h3><p><b>1.定义</b></p>
<p>Schema符合xml语法，xml语句。xml中可以包含多个Schema，通过名称空间来区分（类似于java的包），</p>
<p>可以直接用Int string 类型来定义，但是Schema更复杂。</p>
<p><b>2.创建一个Schema文件：</b></p>
<p><b>复杂元素：</b></p>
<p><b><code>&lt;complexType&gt;</code></b></p>
<p><b><code>&lt;sequence&gt;</code></b></p>
<p><b>简单元素:</b></p>
<p><b><code>&lt;/sequence&gt;</code></b></p>
<p><b><code>&lt;/complexType&gt;</code></b></p>
<hr>
<p><b><code>&lt;sequence&gt;</code></b> :出现的元素是按照顺序的</p>
<p><b><code>&lt;all&gt;</code></b> :单个标签只能出现一个</p>
<p><b><code>&lt;choice&gt;</code></b> :子标签只能出现一个</p>
<p><b><code>&lt;any&gt;</code></b> ：随便出现一个标签</p>
<p><b>maxOccurs&#x3D;”unbounded” </b> :在子标签中，表示标签可以出现无数次</p>
<p><b><code>&lt;attribute&gt; </code></b> :定义属性，只有在复杂元素中才可以定义属性，在<b><code>&lt;/complexType&gt;</code></b>前面写</p>
<hr>
<p><b>两个Schema应用的时候，用引入Schema别名:标签名称</b></p>
<ul>
<li>比如<b><code>&lt;check:name&gt;&lt;/check:name&gt;</code></b>这种方法调用</li>
</ul>
<br/>

<h3 id="在xml中引入约束xsd"><a href="#在xml中引入约束xsd" class="headerlink" title="在xml中引入约束xsd"></a>在xml中引入约束xsd</h3><ul>
<li><p>xmlns:check&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a> “-instance”表示被约束的意思</p>
</li>
<li><p>xmlns&#x3D;”<a href="http://www.example.org/jaxpText_02&quot;">http://www.example.org/jaxpText_02&quot;</a></p>
</li>
<li><p>check:schemaLocation&#x3D;”<a href="http://www.example.org/jaxpText_02">http://www.example.org/jaxpText_02</a> jaxpText_02.xsd”</p>
</li>
<li><p>check是用户自定义的名称，xmlns：的值为xsd中targetNamespace的值</p>
</li>
<li><p>checj:schemaLocation&#x3D;“targetNamespace的值 xsd的文件名称”</p>
</li>
</ul>
<br/>

<br/>

<br/>

<h2 id="3-XML和java的结合"><a href="#3-XML和java的结合" class="headerlink" title="3.XML和java的结合"></a>3.XML和java的结合</h2><p>1.使用dom解析xml（内存中分配树装结构）</p>
<p>2.使用sax解析：采用事件驱动，边读变解析（从上到下，一行一行的解析，解析到一个对象，返回对象名）</p>
<br/>

<br/>

<br/>

<h2 id="4-XML的解析"><a href="#4-XML的解析" class="headerlink" title="4.XML的解析"></a>4.XML的解析</h2><h3 id="1-dom解析"><a href="#1-dom解析" class="headerlink" title="1.dom解析"></a>1.dom解析</h3><p><b>documentBuilder:解析器类</b></p>
<p><em><b>抽象类 不能直接new 要使用documentBuilderFactory.newdocumentBuilder调用</b></em></p>
<p><b> 1.直接解析xml方法:parse(“xml路径”),返回整个Document文档</b></p>
<p><b><code>Document document = bulider.parse(&quot;XML路径&quot;);</code></b></p>
<p><b>2.document的父节点是Node</b></p>
<h5 id="document的方法："><a href="#document的方法：" class="headerlink" title="document的方法："></a>document的方法：</h5><blockquote>
<p><b>getElementsByTagName ：</b>返回得到的标签，集合</p>
</blockquote>
<blockquote>
<p><b>createElement :</b>创建标签</p>
</blockquote>
<blockquote>
<p><b>createTextNode :</b>创建文本内容</p>
</blockquote>
<blockquote>
<p><b>appendChild :</b>将内容插到末尾（粘贴）</p>
</blockquote>
<h5 id="NodeLise（数组）："><a href="#NodeLise（数组）：" class="headerlink" title="NodeLise（数组）："></a>NodeLise（数组）：</h5><blockquote>
<p><b>getlength() :</b>获得数组的长度</p>
</blockquote>
<blockquote>
<p><b>item(数组) :</b>获得当前位置的值</p>
</blockquote>
<blockquote>
<p><b>getTextContent() :</b>得到标签中的内容</p>
</blockquote>
<p><b>3.将在dom解析器中写的内容回写到xml中，利用这个方法回写</b></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line"></span><br><span class="line">transformer.transform(new DOMSource(document), new StreamResult(&quot;src/jaxpText_01.xml&quot;&quot;xml路径&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b>documentBuilderFactory ：</b>解析器工厂</p>
<p>_<b>也是抽象类，使用newInstance()调用</p>
<p>DocumentBuilderFactory builderfactory &#x3D; DocumentBuilderFactory.newInstance();创建实例builderfactory </b>_</p>
<br/>

<h3 id="2-sax解析"><a href="#2-sax解析" class="headerlink" title="2.sax解析"></a>2.sax解析</h3><p><b>SAXParser:解析类</b></p>
<p><em><b>通过SAXParserFactory .newSAXParser来得到；</b></em></p>
<p>parise(“xml路径”,”执行的事件”);</p>
<p>{</p>
<p>startElement():解析开始标签，返回qName:标签名称</p>
<p>characters() :解析文本内容，通过string构造方法返回</p>
<p>endElement() :解析结束标签，也是通过qName返回标签名称</p>
<p>} 都是自动完成的。</p>
<p><em><b>SAXParserFactory :解析器工厂通过newInstance()来得到。</b></em></p>
<br/>

<h3 id="3-dom4j解析（重点）"><a href="#3-dom4j解析（重点）" class="headerlink" title="3.dom4j解析（重点）"></a>3.dom4j解析（重点）</h3><h4 id="1-导入dom4j的包"><a href="#1-导入dom4j的包" class="headerlink" title="1.导入dom4j的包"></a>1.导入dom4j的包</h4><h4 id="2-得到document"><a href="#2-得到document" class="headerlink" title="2.得到document"></a>2.得到document</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(url);</span><br></pre></td></tr></table></figure>


<p><em><b>document的父接口是Node</b></em></p>
<p><b>document方法：</b></p>
<p>getRootElement:获取根节点，返回为Element，</p>
<p>Element的父接口也是Node</p>
<p><em><b>创建解析器</b></em></p>
<p>得到document</p>
<p><b>得到根节点</b></p>
<ul>
<li><p><b>节点.element（“标签名称”）:</b>得到节点下第一个标签为“标签名称”的节点</p>
</li>
<li><p><b>节点.elements（”标签名称”）：</b>得到节点下第一层为“标签名称”的所有节点，为list类型，使用list.get(int)获取是第几个子标签</p>
</li>
<li><p><b>节点.element() :</b>得到节点下第一层的所有标签，也是list类型。</p>
</li>
<li><p><b>使用getText()</b>方法获得标签中的值</p>
</li>
<li><p><b>添加子标签直接使用.addElement()</b>,添加文本直接使用setText().</p>
</li>
</ul>
<p><b>指定位置插入一个标签：</b></p>
<ul>
<li><p>主要是调用list中的add（”位置”,”标签的方法”）;</p>
</li>
<li><p>所以在某一个复杂元素中插入必须是得到所有的简单元素</p>
</li>
<li><p>辅助方法：DocumentHelper.createElement(“标签名称”);<b>来新建一个element</b></p>
</li>
</ul>
<p><b>得到属性值（不需要回写xml）：</b></p>
<ul>
<li>标签名称.attributeValue (属性名称)；</li>
</ul>
<p><b>回写xml：</b></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();//定义xml文件的样式</span><br><span class="line"></span><br><span class="line">XMLWriter xmlWriter = new XMLWriter(new FileOutputStream(&quot;src/jaxpText_dom4j_01.xml&quot;),format);//直接new XMLWriter的类传入两个参数第一个文件路径，第二个文件格式</span><br><span class="line"></span><br><span class="line">xmlWriter.write(document);//写入的为document</span><br><span class="line"></span><br><span class="line">xmlWriter.close();//关闭这个流</span><br></pre></td></tr></table></figure>

<h4 id="3-dom4j对于xpath的支持："><a href="#3-dom4j对于xpath的支持：" class="headerlink" title="3.dom4j对于xpath的支持："></a>3.dom4j对于xpath的支持：</h4><ul>
<li><p>第一种形式：&#x2F;aaa &#x2F;bbb&#x2F;ccc &#x2F;表示一层</p>
</li>
<li><p>第二种形式：&#x2F;&#x2F;aaa &#x2F;&#x2F;表示得到所有的</p>
</li>
<li><p>第三种形式：* *表示得到所有元素</p>
</li>
<li><p>第四种形式：&#x2F;bbb[1] [1]表示第一个元素[last]表示最后一个元素</p>
</li>
<li><p>第五中形式：&#x2F;&#x2F;@属性名称 得到所有含有属性名称的元素</p>
</li>
<li><p>第六中形式：&#x2F;&#x2F;aaa[@属性名称&#x3D;“值”] 表示名称为bbb并且属性名称为这个值得元素</p>
</li>
</ul>
<h4 id="4-dom4j对于xpach的操作"><a href="#4-dom4j对于xpach的操作" class="headerlink" title="4.dom4j对于xpach的操作"></a>4.dom4j对于xpach的操作</h4><p><b>selectNodes(“xpath语句”)：</b>获取多个节点</p>
<p><b>selectSingleNode(“xpath语句”):<b>获取单个节点</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识总结</title>
    <url>/2016/11/24/07-JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="JavaScript基础知识"><a href="#JavaScript基础知识" class="headerlink" title="JavaScript基础知识"></a><font color=#9AD6E6>JavaScript基础知识</font></h3><ul>
<li><p>alert()：弹出窗口</p>
</li>
<li><p>document.write(“”):将值直接显示在页面上面（包括heml代码）</p>
</li>
</ul>
<h4 id="1-Js-类型"><a href="#1-Js-类型" class="headerlink" title="1.Js 类型"></a>1.Js 类型</h4><p>var string</p>
<h4 id="2-数组定义"><a href="#2-数组定义" class="headerlink" title="2.数组定义"></a>2.数组定义</h4><p>一：var arr&#x3D;[1,2,3];</p>
<p>二：var arr &#x3D; new Array(3):代表数组的长度 arr[0]&#x3D;””;arr[1]&#x3D;””;arr[2]&#x3D;””;</p>
<p>三：var arr &#x3D; new array[1,2,3]代表数组中的值</p>
<p>length:数组长度</p>
<span id="more"></span>

<h4 id="3-javascript中关于string的方法"><a href="#3-javascript中关于string的方法" class="headerlink" title="3.javascript中关于string的方法"></a>3.javascript中关于string的方法</h4><ul>
<li><p><font color=#3CA9EE size="5">bold</font>:将字体加黑</p>
</li>
<li><p><font color=#3CA9EE size="5">fontcolor</font>:字体颜色</p>
</li>
<li><p><font color=#3CA9EE size="5">fontsize</font>:字体的大小数值只能是1-7</p>
</li>
</ul>
<p><code>document.write(string.fontsize());</code></p>
<ul>
<li><font color=#3CA9EE size="5">link</font>:将字体变为超链接</li>
</ul>
<p><code> &lt;font color=#3CA9EE size=&quot;5&quot;&gt;document.write(string.link(&quot;地址&quot;));</code></p>
<ul>
<li><p><font color=#3CA9EE size="5">sub</font>:下标 <font color=red size="5">sut</font>:上标</p>
</li>
<li><p><font color=#3CA9EE size="5">concat</font>:字符串的连接</p>
</li>
</ul>
<p><code>document.write(str1.concat(str2));</code></p>
<ul>
<li><font color=#3CA9EE size="5">charAt</font>：返回指定位置的字符串</li>
</ul>
<p><code>document.write(string.charAt(0)); 返回字符串中第一个的位置</code></p>
<ul>
<li><font color=#3CA9EE size="5">indexOf</font>：返回传入字符串的位置</li>
</ul>
<p><code>document.write(string.indexOf(&quot;字符&quot;));不存在时候返回-1</code></p>
<ul>
<li><font color=#3CA9EE size="5">split</font>:将字符串切分</li>
</ul>
<p><code> document.write(string.split(&quot;-&quot;));按照-来切分一个字符串，切分成数组</code></p>
<ul>
<li><font color=#3CA9EE size="5">replace</font>:替换字符串</li>
</ul>
<p><code>document.write（string.replace(&quot;要替换的值&quot;,&quot;替换成的值&quot;)） </code></p>
<p><code> substr:substr(5,5) 从第五位开始截取，截取五位字符</code></p>
<p><code> substring:substring（3,5） 从第三位截取到第五位，但是不包含第五位</code></p>
<h4 id="4-javascript中关于array的方法"><a href="#4-javascript中关于array的方法" class="headerlink" title="4.javascript中关于array的方法"></a>4.javascript中关于array的方法</h4><ul>
<li><p><font color=#3CA9EE size="5"> length</font>:长度的函数</p>
</li>
<li><p><font color=#3CA9EE size="5">join</font>:按照指定的字符将数组分割arr（1,2,3） arr.join（“-”） 显示的是arr（1-2-3）</p>
</li>
<li><p><font color=#3CA9EE size="5">push </font>: arr.push(“你想加的数据”) 返回值为数组串的长度</p>
</li>
<li><p><font color=#3CA9EE size="5"> pop</font> : 删除最后一个字符串并将之返回</p>
</li>
<li><p><font color=#3CA9EE size="5">reverse</font>： 颠倒数组中的顺序 arr.reverse();</p>
</li>
</ul>
<h4 id="5-javascript中Date的方法"><a href="#5-javascript中Date的方法" class="headerlink" title="5.javascript中Date的方法"></a>5.javascript中Date的方法</h4><h5 id="var-date-x3D-new-Date"><a href="#var-date-x3D-new-Date" class="headerlink" title="var date &#x3D; new Date();"></a>var date &#x3D; new Date();</h5><p>1.<font color=#3CA9EE size="4">得到本地的时间是</font>: date.toLocaleString</p>
<p>2.<font color=#3CA9EE size="4"> 得到当前的年</font> ：date.getFullYear</p>
<p>3.<font color=#3CA9EE size="4"> 得到当前的月 </font> ：date.getMonth 返回的值为0-11 得到当前的值必须要加1</p>
<p>4.<font color=#3CA9EE size="4"> 得到当前的星期 </font>：date.getDay 返回值也为0-6 星期日返回值为0</p>
<p>5.<font color=#3CA9EE size="4"> 得到当前的天 </font> ：date.getDate</p>
<p>6.<font color=#3CA9EE size="4"> 得到当前的小时</font> ：date.hetHours</p>
<p>7.<font color=#3CA9EE size="4">得到当前的分钟</font> ：date.getMinutes</p>
<p>8.<font color=#3CA9EE size="4"> 得到当前的分钟</font> ：date.getSeconds</p>
<p>9.<font color=#3CA9EE size="4">获取毫秒数 </font> ：date.getTimes 返回1970年0月0日到现在的毫秒数 &#x2F;&#x2F;应用场景：不有缓存，解决缓存</p>
<h4 id="6-javascript中math的方法"><a href="#6-javascript中math的方法" class="headerlink" title="6.javascript中math的方法"></a>6.javascript中math的方法</h4><blockquote>
<p>都是静态方法 都是通过<b>Math.</b>来使用</p>
</blockquote>
<p>1.<font color=#3CA9EE size="4">ceil</font> : document.write(Math.ceil(m)); 向上舍入（10.4—&gt;11）</p>
<p>2.<font color=#3CA9EE size="4">floor</font> : document.write(Math.floor(m));向下舍入（10.4—&gt;10）</p>
<p>3.<font color=#3CA9EE size="4">round</font> : document.write(Math.round(m));四舍五入（10.4—&gt;10）</p>
<p>4.<font color=#3CA9EE size="4">random</font> ： 产生0-1之间的随机数</p>
<blockquote>
<p><font size=4>javascript中不存在函数的重载，通过其他方式模拟重载（arugument数组来重载）</font></p>
</blockquote>
<h4 id="7-javascript的Bom对象"><a href="#7-javascript的Bom对象" class="headerlink" title="7.javascript的Bom对象"></a>7.javascript的Bom对象</h4><p>1.<font color=#3CA9EE size="4">navigator</font> ：获取浏览器的信息</p>
<p>2.<font color=#3CA9EE size="4">navigator.appname</font> :获取浏览器名称</p>
<p>3.<font color=#3CA9EE size="4">screen </font> ：浏览器屏幕信息</p>
<p>4.<font color=#3CA9EE size="4">location </font></p>
<p>5.<font color=#3CA9EE size="4">href</font> :获取请求的地址，设置url地址</p>
<p>6.<font color=#3CA9EE size="4">history</font></p>
<p>7.<font color=#3CA9EE size="4">back </font> :上一个页面</p>
<p>8.<font color=#3CA9EE size="4">forward</font> ：下一个页面</p>
<h5 id="9-windows"><a href="#9-windows" class="headerlink" title="9. windows"></a>9. windows</h5><ul>
<li><p><font color=#3CA9EE size="4">window.alert</font> :输出弹框</p>
</li>
<li><p><font color=#3CA9EE size="4">window.confirm (“显示内容”）</font> :确认提示框（点击确定返回true，取消返回false）</p>
</li>
<li><p><font color=#3CA9EE size="4">window.prompt（“显示的内容”，“默认内容”） </font> :文字提示框</p>
</li>
<li><p><font color=#3CA9EE size="4">window.open（链接，名字，格式）</font> ：打开一个新的窗口</p>
</li>
<li><p><font color=#3CA9EE size="4">window.clouse() </font> : 关闭窗口</p>
</li>
<li><p><font color=#3CA9EE size="4">window.setInterval(‘js代码’，毫秒数)</font> ：多长时间执行一次“js代码事件”(模拟定时器的效果)</p>
</li>
<li><p><font color=#3CA9EE size="4">window.setT imeout(“js代码”，毫秒数)</font> : 在毫秒数之后去执行“js代码事件”（只会执行一次）</p>
</li>
<li><p><font color=#3CA9EE size="4">clearInterval(传入的为Interval事件的ID)</font> : 清除setInterval的事件</p>
</li>
<li><p><font color=#3CA9EE size="4">clearInterval() </font> ：清除setTimeout事件</p>
</li>
</ul>
<h4 id="8-javascript的dom对象"><a href="#8-javascript的dom对象" class="headerlink" title="8.javascript的dom对象"></a>8.javascript的dom对象</h4><blockquote>
</blockquote>
<ul>
<li><p>文档： 超文本标记文档</p>
</li>
<li><p>对象：提供属性和方法</p>
</li>
<li><p>模型：使用属性和方法操作的文档</p>
</li>
</ul>
<h4 id="9-javascript的document方法"><a href="#9-javascript的document方法" class="headerlink" title="9.javascript的document方法"></a>9.javascript的document方法</h4><p>1. <font color=#3CA9EE size="4">write</font> :向页面输出变量的值或者HTML代码</p>
<p>2. <font color=#3CA9EE size="4">getElementById</font> :通过Id来得到对象</p>
<p>3. <font color=#3CA9EE size="4">getElementsByName(“name的值为一样的组”)</font> :通过标签的name值得到对象，返回的是一个数组</p>
<p>4. <font color=#3CA9EE size="4">getElementsTagName(“标签名称”)</font> ：通过标签名称得到对象，返回也是一个数组</p>
<p>5. 只有一个标签时，只能用ByName来获取，不能使用ByTagName获取</p>
<p>6. <font color=#3CA9EE size="4">opener</font>:创建窗口的窗口 var p&#x3D;window.opener p得到了创建这个字窗口的窗口 在末尾添加节点：</p>
<blockquote>
<p>1.获取母标签getById<br/><br/></p>
</blockquote>
<blockquote>
<p>2.创建子标签</p>
</blockquote>
<p>document.createElement(‘输入标签’); :创建标签<br/><br/></p>
<blockquote>
<p>3.创建所要输入的文本<br/></p>
</blockquote>
<p>document.createTextNode(“输入文本”) :创建文本<br/><br/></p>
<blockquote>
<p>4.将文本放入标签中<br/></p>
</blockquote>
<p>子标签.appendChild（”文本”） :将文本让入子标签中<br/><br/></p>
<blockquote>
<p>5.将子标签放入母标签中<br/></p>
</blockquote>
<p>母标签.oppendChild(); :将子标签插入到母标签中（类似于剪切粘贴的效果）</p>
<h4 id="10-javascript的Element对象"><a href="#10-javascript的Element对象" class="headerlink" title="10.javascript的Element对象"></a>10.javascript的Element对象</h4><p>1.<font color=#3CA9EE size="4">input.value</font>;</p>
<p>2.<font color=#3CA9EE size="4">input.getAttribute(“value”)</font>; :两个效果是一样的，但是使用后者是区别关键字</p>
<p>3.<font color=#3CA9EE size="4">inout.setAttribute(“属性”,”属性值”)</font>; :设置属性名称和值，传入两个参数</p>
<p>4.<font color=#3CA9EE size="4">inout.removeAttribute(“属性”)</font> ：删除属性，但是不能删除value属性</p>
<p>5.<font color=#3CA9EE size="4">node:标签节点</font></p>
<blockquote>
<p><b>nodeType nodeName nodeValue</b></p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">fistChild </font> :获得第一个节点</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">lastChild</font> :获得最后一个节点</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">nextSibling</font> :子节点中的下一个同辈节点</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">previousSibling</font> :子节点中的上一个同辈节点</p>
</blockquote>
<h4 id="11-javascript的Dom操作"><a href="#11-javascript的Dom操作" class="headerlink" title="11.javascript的Dom操作"></a>11.javascript的Dom操作</h4><p><font color=#3CA9EE size="4">oppendChild();</font> :将子标签插入到母标签中（类似于剪切粘贴的效果）</p>
<p><font color=#3CA9EE size="4">insertBefore(新节点，旧节点)</font> :将新节点插入到旧节点之前（是在母节点的基础上插入）</p>
<p><font color=#3CA9EE size="4">replace(新节点，旧节点)</font> :将新节点代替旧节点（是在母节点的基础上替换）</p>
<p><font color=#3CA9EE size="4">cloneNode(bool类型)</font> :复制子节点子 节点.cloneNode(true);</p>
<p><font color=#3CA9EE size="4">removeNode(子节点)</font> :通过父节点删除子节点</p>
<h4 id="12-javascript的innerHTML属性"><a href="#12-javascript的innerHTML属性" class="headerlink" title="12.javascript的innerHTML属性"></a>12.javascript的innerHTML属性</h4><blockquote>
<p>1.获取文本内容</br></p>
</blockquote>
<p>就是直接获得标签的文本内容</p>
<p>2.向标签中设置内容，包括html代码</p>
<blockquote>
<p>母节点,innerHTNL&#x3D;”htnl代码”;</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">form.submit();</font> :提交内容到服务器</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">form.action&#x3D;””;</font> :将内容提交到那个地址</p>
</blockquote>
<blockquote>
<p>&lt;a href&#x3D;”地址”?”内容”&gt;</a> :使用超链接提交内容</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">onclick</font> :鼠标点击事件</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">onchange</font> :改变内容（select一起使用）</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">onfocus</font> :得到焦点事件</p>
</blockquote>
<blockquote>
<p><font color=#3CA9EE size="4">onblur</font> :失去焦点事件</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Jsp_Cookie_HttpSession_EL</title>
    <url>/2016/11/29/08-Jsp-Cookie-HttpSession-EL/</url>
    <content><![CDATA[<h1 id="Jsp-amp-Cookie-amp-HttpSession-amp-EL"><a href="#Jsp-amp-Cookie-amp-HttpSession-amp-EL" class="headerlink" title="Jsp&amp;Cookie&amp;HttpSession&amp;EL"></a>Jsp&amp;Cookie&amp;HttpSession&amp;EL</h1><blockquote>
<p>写在前面:主要还是之前的JavaEE知识总结</p>
</blockquote>
<span id="more"></span>

<h2 id="1-Jsp基础"><a href="#1-Jsp基础" class="headerlink" title="1.Jsp基础"></a>1.Jsp基础</h2><p>1.<b> 作用：</b></p>
<p>在原有html基础上面添加java脚本，构成jsp页面</p>
<p>2.<b>Servlet:</b></p>
<p>虽然能够动态，但是在页面的时候需要调用函数输出在页面上面</p>
<p>3.<b> Html：</b></p>
<p>虽然能够很好的显示在网页上面，但是不能够动态的现实内容</p>
<p>4.<b> Jsp和servlet的分工：</b></p>
<ul>
<li><p>Jsp：请求发起页面，表单，超链接，请求结束页面，现实数据（服务员）</p>
</li>
<li><p>Servlet：请求中间处理数据（厨师）</p>
</li>
</ul>
<p>5.<b>Jsp组成：</b></p>
<ul>
<li><p>Jsp&#x3D;html+java脚本+jsp标签</p>
</li>
<li><p>Jsp无需创建即可使用的对象（request,response）</p>
</li>
</ul>
<p>6.<b>三种java脚本</b></p>
<ul>
<li><p>&lt;%….%&gt;java代码片段，方法内可以放什么就可以放什么（不能放方法和成员变量）</p>
</li>
<li><p>&lt;%&#x3D;…%&gt;主要用来输出，用于输出一条语句的表达式，system.out.printf（这里面的内容）</p>
</li>
<li><p>&lt;%!…%&gt;声明，变量，方法</p>
</li>
</ul>
<p>7.<b>Jsp原理：</b></p>
<p>其实就是java代码</p>
<p>8.<b>Jsp注释：</b></p>
<p>&lt;%–dasdas–%&gt;</p>
<h2 id="2-Cookie-域"><a href="#2-Cookie-域" class="headerlink" title="2.Cookie(域)"></a>2.Cookie(域)</h2><p><b>1.定义：</b></p>
<p>浏览器保存服务器的数据，第二次访问相同的页面时，浏览器将保存的数据发送到服务器</p>
<p><b>2.举例</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Set-Cookie aaa=AAA</span><br><span class="line"></span><br><span class="line">response.addHeader(“Set-Cookie”,”aaa=AAA”);</span><br><span class="line"></span><br><span class="line">Cookie cookie= <span class="keyword">new</span> <span class="title class_">Cookie</span>(name,value);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><b>快捷方式serponse.addCookie(cookie)</b>&#x2F;&#x2F;向客户端发送cookie</p>
</li>
<li><p><b>request.getCookies()</b>&#x2F;&#x2F;服务器获取从浏览器保存的cookie，返回Cookies数组</p>
</li>
<li><p><b>coookie.setMaxAge():</b>设置cookied的生命周期-1表示直接”杀死“0表示在浏览结束清楚</p>
</li>
<li><p>访问的路径要是包含了cookie的路径，那么服务器就会取得到留在浏览器的cookie值</p>
</li>
</ul>
<h2 id="3-HttpSession（域）-保护用户的登录信息"><a href="#3-HttpSession（域）-保护用户的登录信息" class="headerlink" title="3.HttpSession（域）****保护用户的登录信息"></a>3.HttpSession（域）****保护用户的登录信息</h2><blockquote>
<p><b>Jsp中的内置对象</b></p>
</blockquote>
<ul>
<li><p>服务器端对象，保存在服务器中，属于javaWab不是属于Html</p>
</li>
<li><p>调用HttpSession session &#x3D; request.getSeccion();打开浏览器到关闭浏览器（一个用户）</p>
</li>
<li><p>Resquest.getSession(false):不存在session那么就会返回null</p>
</li>
</ul>
<blockquote>
<p><b>Session案例：（简单登陆页面）</b></p>
</blockquote>
<p><img src="/index_files/_u7B80_u5355_u767B_u5F55_u9875_u9762_u8BBE_u8BA1_u601D_u8DEFpng.png"></p>
<blockquote>
<p><b> Session原理：</b></p>
</blockquote>
<p>和银行卡一样的，访问一次就会得到一张卡，卡里面存数据，关闭网页的时候就流失了这张卡，所以要重新分配这个卡</p>
<p><img src="/index_files/session_u539F_u7406.png"></p>
<h2 id="4-Jsp三大指令"><a href="#4-Jsp三大指令" class="headerlink" title="4.Jsp三大指令"></a>4.Jsp三大指令</h2><p><b>1.Page指令：&lt;%@page %&gt; </b></p>
<p>pageEncoding和contentType</p>
<p>1. pageEncoding:指定当前的页面编码，只要是正确的，就不会乱码。服务器编译jsp成的java的时候会使用pageEncoding；</p>
<p>2.contentType contentType(“type&#x2F;html;charset&#x3D;utf-8”)都是设置jsp页面的编码。</p>
<p>*<b> Import :</b>导包</p>
<ul>
<li><b> ErrorPage:</b>当前页面如果抛出异常，转发到哪一个页面</li>
</ul>
<p>*<b> isErrorPage：</b>指定当前页面是否为处理错误的页面，当属性为true时，可以使用内置对象的exception</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span><span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span><span class="tag">&lt;/<span class="name">location</span>&gt;</span>将错误页面转发到新的页面</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><b> Buffer:</b>指定为缓冲区的大小，通常为8k</p>
</li>
<li><p><b> isELIgnored：</b>是否忽略el表达式（默认为false）</p>
</li>
</ul>
<p><b>2.Include静态包含</b></p>
<ul>
<li><p>RequesetDispatcher的include方法相似</p>
</li>
<li><p>将两个jsp页面绑在一起了，但是requestDispatcher是将两个需要的内容共享。</p>
</li>
</ul>
<h2 id="5-九大内置对象"><a href="#5-九大内置对象" class="headerlink" title="5.九大内置对象"></a>5.九大内置对象</h2><ul>
<li><p><b>Out：</b>输出</p>
</li>
<li><p><b>Config:</b>对应ServletConfig（配置）</p>
</li>
<li><p><b>Page:</b>当前jsp的this，就是当前的对象。引用为Object类型</p>
</li>
<li><p><b>pageContext：</b>最后一个域对象</p>
</li>
<li><p><b>Exception:</b>异常类的对象</p>
</li>
<li><p><b>request</b></p>
</li>
<li><p><b>Response</b></p>
</li>
<li><p><b>Application:</b>ServletContext类的对象</p>
</li>
<li><p><b>Session：</b></p>
</li>
</ul>
<h2 id="6-pageContext-域对象"><a href="#6-pageContext-域对象" class="headerlink" title="6.pageContext(域对象)"></a>6.pageContext(域对象)</h2><blockquote>
<p>四大域对象</p>
</blockquote>
<p><b>1.servletContext（域）：</b>整个应用程序</p>
<p><b>2.Session（域）：</b>整个会话</p>
<p><b>3.Request(域):</b>一个请求链</p>
<p><b>4.pageContext:</b>一个jsp页面，当前jsp页面和jsp标签之间共享数据。</p>
<ul>
<li><p><b> 代理其他域：</b>pageContext.setAttribute(“”,””,PageContext.Seesion_SCope)；代理session对象</p>
</li>
<li><p><b>全域查找：</b>pageContext.findAteeibute(“”):从小范围查找到大域，page的域最小</p>
</li>
</ul>
<p>可以通过get方法，获取其他八个内置对象</p>
<h2 id="7-jsp动作标签"><a href="#7-jsp动作标签" class="headerlink" title="7.jsp动作标签"></a>7.jsp动作标签</h2><p><b>动作标签是有服务器来执行，html是由浏览器执行</b></p>
<ul>
<li><p><b><a href="jsp:forward">jsp:forward</a>:</b>转发</p>
</li>
<li><p><b><a href="jsp:include">jsp:include</a>:</b>包含</p>
</li>
<li><p><b><a href="jsp:param">jsp:param</a>:</b>用来作为forward和include的子标签。</p>
</li>
<li><p><code>&lt;jsp:param value=””,name=””&gt;</code></p>
</li>
</ul>
<p><b>被转发或者被包含的jsp的页面中就可以调用这些内容</b></p>
<h2 id="8-jsp在xml中的配置"><a href="#8-jsp在xml中的配置" class="headerlink" title="8.jsp在xml中的配置"></a>8.jsp在xml中的配置</h2><p>在context.xml的<code>&lt;Context reloadable=”true”&gt;</code>；自动重新加载，不用重启tomcat</p>
<p>在wab.xml中已经将jsp的xml文件已经写好了</p>
<h2 id="9-javaBean"><a href="#9-javaBean" class="headerlink" title="9.javaBean"></a>9.javaBean</h2><ul>
<li><p>必须为成员变量设置set，get方法（其一也是可以的）</p>
</li>
<li><p>方法名称满足一定规范，就是可以称之为属性</p>
</li>
</ul>
</br>

<ul>
<li>pageContext:这个是一个pageContext类型</li>
</ul>
<p><b>项目名：${pageContext.request.contextPath}</b></p>
<p>项目名称变为这样</p>
<p><img src="/index_files/_u6807_u9898.png">EL自带函数库</p>
<p>导入自带的函数库：&lt;@taglib prefix&#x3D;”fn” url&#x3D;”&#x2F;functions”&gt;<br><img src="/index_files/1480423481684El_u81EA_u5E26_u51FD_u6570_u5E93.png"></p>
<p><img src="/index_files/_u6807_u9898.png">EL自定义函数库：</p>
<p>新建一个java类，private 并且都含有返回值</p>
<p>要写tld文件，写在WEB-F下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JSTL 1.1 functions library<span class="tag">&lt;/<span class="name">description</span>&gt;</span>//文件的名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JSTL functions<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span>//版本号码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">short-name</span>&gt;</span>fn<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span>//前缀</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://java.sun.com/jsp/jstl/functions<span class="tag">&lt;/<span class="name">uri</span>&gt;</span>//现在用不上</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Tests if an input string contains the specified substring.</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>contains<span class="tag">&lt;/<span class="name">name</span>&gt;</span>/函数名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-class</span>&gt;</span>org.apache.taglibs.standard.functions.Functions<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span>//函数的位置，和在xml中配置servlet一样的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>boolean contains(java.lang.String,java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span>//返回值</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-EL标签"><a href="#10-EL标签" class="headerlink" title="10.EL标签"></a>10.EL标签</h2><ul>
<li><p>EL是jsp内置的表达式$&lt;”name”&gt;可以全域查找也可以指定域查找</p>
</li>
<li><p>EL只能输出代替&lt;%&#x3D; %&gt;标签</p>
</li>
</ul>
<br/>

<blockquote>
<p><b>EL读取四大域</b></p>
</blockquote>
<ul>
<li><p>${xxx},全域查找名为xxx的属性，不存在返回空字符串</p>
</li>
<li><p>${pageScope.xxx}</p>
</li>
<li><p>${sessionScope.xxx}</p>
</li>
<li><p>${requestScope.xxx}</p>
</li>
<li><p>${applicatScope.xxx}输出指定域的属性</p>
</li>
</ul>
<br/>

<ul>
<li>El可以直接输出内置的十一个内置对象</li>
</ul>
<p><b>其中十个是map对象</b></p>
<p><b>Map.key</b>可以获得键的值</p>
<p><b>Param:map</b>对象，键值对，键key，值是value</p>
<p><b>paramValues</b>：map对象，键值对，值是多个。下表</p>
<p><b>Header:</b>对应请求头，key头名称，value是单个值</p>
<p><b>headerValues:</b>请求头，对象多值</p>
<blockquote>
<p><b>Cookie:</b>Map&lt;string,cookie&gt;key是cookie的name， <b>value是cookie的对象 </b></p>
</blockquote>
<p>想要获得cookie的value必须cookie.name:只是得到cookie的对象</p>
<p>想要获得值还要必须cookie.name.value, cookei.getValue</p>
<p>Cookie.name.name cookie.getName</p>
</br>

<ul>
<li>pageContext:这个是一个pageContext类型</li>
</ul>
<p><b>项目名：${pageContext.request.contextPath}</b></p>
<p>项目名称变为这样</p>
<br/>

<p><img src="/index_files/1480423351511_u6807_u9898.png"><b>EL自带函数库</b></p>
<p>导入自带的函数库：<code>&lt;@taglib prefix=”fn” url=”/functions”&gt;</code></p>
<p><img src="/index_files/El_u81EA_u5E26_u51FD_u6570_u5E93.png"></p>
<br/>

<p><img src="/index_files/1480423351511_u6807_u9898.png"><b>EL自定义函数库：</b></p>
<p>1.新建一个java类，private 并且都含有返回值</p>
<p>2.要写tld文件，写在WEB-F下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JSTL 1.1 functions library<span class="tag">&lt;/<span class="name">description</span>&gt;</span>//文件的名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JSTL functions<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span>//版本号码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">short-name</span>&gt;</span>fn<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span>//前缀</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://java.sun.com/jsp/jstl/functions<span class="tag">&lt;/<span class="name">uri</span>&gt;</span>//现在用不上</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Tests if an input string contains the specified substring.</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>contains<span class="tag">&lt;/<span class="name">name</span>&gt;</span>/函数名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-class</span>&gt;</span>org.apache.taglibs.standard.functions.Functions<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span>//函数的位置，和在xml中配置servlet一样的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>boolean contains(java.lang.String,java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span>//返回值</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-Jspl"><a href="#11-Jspl" class="headerlink" title="11.Jspl"></a>11.Jspl</h2><h3 id="Jspl包含四大标签库："><a href="#Jspl包含四大标签库：" class="headerlink" title="Jspl包含四大标签库："></a>Jspl包含四大标签库：</h3><p><img src="/index_files/1480423331474_u6807_u9898.png">导入jspl标签库（动态标签是在服务器中执行）</p>
<p><code>&lt;%@taglib prefix=”前缀” url=””%&gt;</code></p>
<p><b>1. 核心标签库：Core</b></p>
<p><b>Out</b></p>
<p><code>&lt;c:out value=”” escapeXml=”true”/转移”&lt;&gt;“&gt;</code>可以输出${}中的内容</p>
<p><b>Set</b></p>
<p>创建域的属性</p>
<p><code>&lt;c:set var=””,value=”” scope=”设置在指定域”&gt;</code>默认设置的是在page中</p>
<p>Var：变量名 value:变量值,scope&#x3D;”设置在指定域”</p>
<p><b>Remove</b></p>
<p><code>&lt;remove&gt;</code>:删除域变量</p>
<p>Var:变量名 scope：删除指定域的内容，否咋就删除了所有域中的内容</p>
<p><b>Url</b></p>
<p>Value:指定一个路径，会直接在给定的值前面加上项目名</p>
<p>&lt;c:url value&#x3D;”&#x2F;a.jsp”&gt;</p>
<p><code>&lt;c:param name=””,value=””&gt;</code>输出为项目名&#x2F;a.jsp?名称的URL编码，子标签</p>
<p></c:url></p>
<p><b>If</b></p>
<p><code>&lt;c:if text=””&gt;&lt;/c:if&gt;</code>必须要有一个bool类型的值，当text为真得时候执行标签体类容</p>
<p><b>Choose</b></p>
<p>对应java中的if else</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:when</span> <span class="attr">text</span>=<span class="string">””</span>&gt;</span><span class="tag">&lt;/<span class="name">c:when</span>&gt;</span> if</span><br><span class="line"></span><br><span class="line">&lt;c:whentext=””&gt;<span class="tag">&lt;/<span class="name">c:when</span>&gt;</span>只有当第一个为假的之后才会执行这个</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:otherwise</span>&gt;</span><span class="tag">&lt;/<span class="name">c:otherwise</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:choose</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b>forEach</b></p>
<p>循环遍历数组集合，技术方式来循环</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">”i”</span> <span class="attr">begin</span>=<span class="string">”1”</span> <span class="attr">end</span>=<span class="string">”10”</span> <span class="attr">step</span>=<span class="string">””</span>&gt;</span>从一到十 包含十</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">””</span> <span class="attr">var</span>=<span class="string">””</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>循环变量<br><img src="/index_files/19566bd5-3bb0-4e67-bd65-611373f3970c.jpg"></p>
<p><b>Fmt</b></p>
<p>格式化输出库</p>
<p>&lt;fmt:frmatDate value&#x3D;”” pattern&#x3D;””&gt;</p>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p>1. 自定义一个类</p>
<p>2. 写一个tld文件，相当于xml文件</p>
<p>3. 在jsp中调用tld文件</p>
<hr>
<p><b>标签处理类：</b></p>
<p><b>SimpleTag</b>接口</p>
<p><b>Void doTag():</b>每次执行都会调用这个方法</p>
<p><b>Void setParent(JspTag):</b>设置父标签（不是生命周期方法）</p>
<p><b>JspTag getParent():</b>返回父标签</p>
<p><b>**Void setJspBody(JspFragment):</b>设置标签体</p>
<p><b>**Void setJspContext(JspContext):</b>设置jsp上下文对象</p>
<p><b>doTag()</b>这个方法最后使用</p>
<hr>
<p><b>创建tld文件</b></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tag-class</span>&gt;</span><span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span><span class="comment">&lt;!--标签处理类，加包名称 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span><span class="comment">&lt;!--标签内容 empty空标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b>标签内容：</b></p>
<p><b>scriptless:</b>只能是el表达式，也可以是其他的标签</p>
<p><b>this.getJspContext().getOut()</b>获得输出流</p>
<p><b>this.getJspBody().invoke(‘输出流’)</b>&#x2F;&#x2F;执行标签体</p>
<p><b>this.getJspBody.invoke(null)</b>&#x2F;&#x2F;执行标签体</p>
<hr>
<p><b>在页面中调用这个tld文件</b></p>
<p>&lt;@%taglib prefix&#x3D;”短名称” url&#x3D;”标签所在的位置路径”%&gt;</p>
<p>&lt;”短名称”,在tld定义的名称&gt;</p>
<p>Throw new SkippageException抛出这个异常之后，本jsp页面下面的内容不再显示</p>
<p><b>标签属性：</b></p>
<p>在标签处理类里面添加属性</p>
<p>设置boolean text的属性，设置get，set方法，也是在doTag之前，值是有tomcat传入</p>
<p>If(text){this.getJspBody.invoke(null)}执行标签体</p>
<p><b>在tld中添加属性</b></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>:属性名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">requirde</span>&gt;</span>//指定属性是否为必须的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span>//能否使用EL语句</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-Mvc"><a href="#12-Mvc" class="headerlink" title="12.Mvc"></a>12.Mvc</h2><ul>
<li><p>M–model 模型(自己写的代码) 统一调度</p>
</li>
<li><p>V-view 视图(jsp) 显示</p>
</li>
<li><p>C-Controller 控制器（servlet） 处理</p>
</li>
</ul>
<p>javaWab三层框架</p>
<ul>
<li><p>Wab层 与wab相关的内容</p>
</li>
<li><p>业务层 业务对象</p>
</li>
<li><p>数据层 操作数据库</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax基本用法</title>
    <url>/2016/11/30/09-Ajax%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AJAX-异步处理"><a href="#AJAX-异步处理" class="headerlink" title="AJAX(异步处理)"></a>AJAX(异步处理)</h1><hr>
<h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1.Ajax"></a><font color="#03a9f4">1.Ajax</font></h2><p>异步的js和xml</p>
<h2 id="2-同步交互和异步交互"><a href="#2-同步交互和异步交互" class="headerlink" title="2.同步交互和异步交互"></a><font color="#03a9f4">2.同步交互和异步交互</font></h2><span id="more"></span>

<p><strong>1.同步</strong></p>
<p>发送一个请求要等待服务器响应结束才可以进行下一个请求</p>
<p>刷新的是整个界面</p>
<p><strong>2.异步</strong></p>
<p>发送一个请求，无需等待服务器请求直接进行下一个请求</p>
<p>可以使用js接受服务器的响应，使用js局部刷新</p>
<h2 id="3-ajax请求"><a href="#3-ajax请求" class="headerlink" title="3.ajax请求"></a><font color="#03a9f4">3.ajax请求</font></h2><p><strong>第一步:(得到XMlHttpRequest）</strong></p>
<p>ajax只需要一个对象XMlHttpRequest，</p>
<p>Var xmlHtml &#x3D; new XMlHttpRequest();</p>
<p>少数浏览器</p>
<p>Var xmlHtml&#x3D; new ActiveXObject(“Msxml12.XMLHTTP”);</p>
<p>Var xmlHtml&#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<p><strong>第二步：（得到和服务器的链接）</strong></p>
<p>xmlHttp.open():三个参数</p>
<p>—&gt;请求方式，post，get</p>
<p>—&gt;请求的URL，指定是想服务器的那个servlet发送请求</p>
<p>—&gt;请求是否为异步 true-是</p>
<p><strong>第三步：(发送请求)</strong></p>
<p>Xmlhttp.send(null):必须要给参数</p>
<p>参数：就是请求体类容，get的时候必须为null。</p>
<p><strong>第四步：(得到响应）</strong></p>
<p>在xmlHttp对象的上面注册监听器onreadystatechange</p>
<p><strong>第五步：(得到状态)</strong></p>
<p>状态码：</p>
<ul>
<li><p>0:刚创建，还没有调用open（）方法；</p>
</li>
<li><p>1:请求开始，调用了open（）方法,但是没有调用send（）方法；</p>
</li>
<li><p>2:调用完了send（）方法；</p>
</li>
<li><p>3:服务器开始响应，但不表示响应结束</p>
</li>
<li><p>4:服务器响应结束（通常只关心这个状态）</p>
</li>
</ul>
<p><strong>得到状态码：</strong></p>
<p>Var state &#x3D; xmlHttp.readyState();可能是01234；</p>
<p><strong>得到服务器的响应状态码</strong></p>
<p>Var status &#x3D;xmlHttp.status ; 可能是202 404</p>
<p><strong>得到服务器响应内容</strong></p>
<p>Var content &#x3D;xmlHttp.responseText;得到的为文本可是</p>
<p>Var content &#x3D;xmlHttp.responseXML;得到的是xml响应内容</p>
<p>当xmlHttp.readyState()&#x3D;4 并且xmlHttp.status&#x3D;200的时候证明成功，可以获得服务器响应文件</p>
<h2 id="4-post请求-发送请求需要带参数"><a href="#4-post请求-发送请求需要带参数" class="headerlink" title="4.post请求(发送请求需要带参数)"></a><font color="#03a9f4">4.post请求(发送请求需要带参数)</font></h2><p>xmlHttp.open(“POST”..);</p>
<p>需要添加一步</p>
<pre><code>xmlHttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);

xmlHttp.send(“username=”xx”,password=”x”);//发送的内容

        
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>SwipeRefreshLayout使用</title>
    <url>/2016/12/06/10-SwipeRefreshLayout%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="SwipeRefreshLayout-使用"><a href="#SwipeRefreshLayout-使用" class="headerlink" title="SwipeRefreshLayout 使用"></a><font color =#03A9F4>SwipeRefreshLayout 使用</font></h1><blockquote>
<p>写在前面:最近在研究下拉刷新，虽然自己也实践写出来了一个Demo，<br>      但是还是在github上找到了一个刷新的框架<br>  框架地址:<a href="%22https://github.com/yanzhenjie/SwipeRecyclerView%22">SwipeRefreshLayout</a></p>
</blockquote>
<span id="more"></span>
<h2 id="布局文件："><a href="#布局文件：" class="headerlink" title=" 布局文件："></a><font color =#03A9F4> 布局文件：</font></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/id_swipe&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/id_listView&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">       &lt;/ListView&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/android.support.v4.widget.SwipeReuhLayot&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a><font color =#03A9F4>主要方法</font></h2><ul>
<li><p>setOnRefreshListener()</p>
</li>
<li><p>Set the listener to be notified when a refresh is triggered via the swipe</p>
</li>
<li><p>当滑动的时候调用这个监听</p>
</li>
<li><p>setColorScheme()</p>
</li>
<li><p>Set the color resources used in the progress animation from color resources</p>
</li>
<li><p>设置滑动动作发生的时候的颜色源。</p>
</li>
<li><p>isRefreshing()</p>
</li>
<li><p>Whether the SwipeRefreshWidget is actively showing refresh  progress.</p>
</li>
<li><p>显示是否刷新进度条</p>
</li>
</ul>
<p>##<font color =#03A9F4>实现过程</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                   <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> (String) msg.obj;</span><br><span class="line">                   mDatas.add(test+i++);</span><br><span class="line">                   mAdapter.notifyDataSetChanged();</span><br><span class="line">                   swipeRefreshLayout.setRefreshing(<span class="literal">false</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>这里使用Handler机制是因为子线程不能刷新UI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">OnCreate</span><span class="params">()</span>&#123;</span><br><span class="line">     swipeRefreshLayout =(SwipeRefreshLayout) findViewById(R.id.id_swipe);</span><br><span class="line">         listView =(ListView) findViewById(R.id.id_listView);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新监听事件</span></span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        mAdapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;String&gt;(<span class="built_in">this</span>,android.R.layout.simple_list_item_1,mDatas);</span><br><span class="line">        listView.setAdapter(mAdapter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行刷新动作</span></span><br><span class="line"><span class="meta">@overrid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefreshListener</span><span class="params">()</span>&#123;</span><br><span class="line">      Message msg= <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        msg.what = <span class="number">1</span>;</span><br><span class="line">        msg.obj  = <span class="string">&quot;TEST&quot;</span>;</span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是一个刷新动作的监听，然后具体实现刷新的动作</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>短暂总结</title>
    <url>/2016/11/30/10-%E7%9F%AD%E6%9A%82%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="时间：2016年11月30日21-22-3"><a href="#时间：2016年11月30日21-22-3" class="headerlink" title="时间：2016年11月30日21:22:3"></a>时间：2016年11月30日21:22:3</h1><p><font size="3"></font></p>
<h2 id="开学到现在所学类容："><a href="#开学到现在所学类容：" class="headerlink" title="开学到现在所学类容："></a>开学到现在所学类容：</h2><ul>
<li>JavaEE三大框架</li>
<li>大量Android开源项目</li>
<li>Xutils3开源库</li>
<li>Nohttp开源库</li>
<li>&amp;nbsp;Annotatios开源库</li>
<li>课本知识狗屁不通<span id="more"></span></li>
</ul>
<h2 id="近期感想"><a href="#近期感想" class="headerlink" title="近期感想"></a>近期感想</h2><p>&amp;nbsp;&amp;nbsp; 一进大三，就觉得就业的形式越来越严峻。虽然选择的是Android方面，但是感觉自己的基础知识非常的不好,虽然学习的是Java方面，但是感觉自己一点Java基础都没有。对一些基本的东西都不清楚，理不清，记不清楚。看到周围的人一个个都准备去考研，我一点都不为所动。因为我觉得我决定的事情一般都很难去改变。还没有进大学的时候我就决定了不去考研。感觉自己每天在教室上课都是在混吃等死。。。。。（怎么能这样评价自己呢。。。。）虽然我们这个不出名的二本院校毕业没有学校优势。但是搞技术的技术才是养活自己的本事。今天完了一款小游戏，很有意思。哇哈哈。大神的书出第二本了，等下个月又生活费了就入手一本。毕竟是大神带进门的！！！</p>
<h2 id="预期打算"><a href="#预期打算" class="headerlink" title="预期打算"></a>预期打算</h2><ul>
<li>好好学习一下C语言和C++</li>
<li>准备好期末复习，争取少挂科</li>
<li>班主任智能助手还要继续。</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>生活</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结（上）</title>
    <url>/2017/03/01/11-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="排序算法总结（上）"><a href="#排序算法总结（上）" class="headerlink" title="排序算法总结（上）"></a>排序算法总结（上）</h2><blockquote>
<ul>
<li>首先先给自己大三下学期定下一个小目标:找到暑假实习公司。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>因为看了很多学长学姐写的面试经验，觉得数据结构和算法是必问的内容。想想自己对这方面的脑容量为零。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>所以在正式面试之前好好恶补一下！！！</li>
</ul>
</blockquote>
<span id="more"></span>

<h3 id="1-直接插入算法"><a href="#1-直接插入算法" class="headerlink" title="1.直接插入算法"></a>1.直接插入算法</h3><ul>
<li><p>思路： 默认前面的数据全部都是<b>已经排好</b>的，然后依次将后面的数据插入到合适的位置</p>
</li>
<li><p>时间复杂度:O(n^2)</p>
</li>
<li><p>最佳复杂度：O(n)&#x2F;已经全部排好</p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="http://img.blog.csdn.net/20170301123823950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;<span class="comment">// 注意[0,i-1]都是有序的。如果待插入元素比a[i-1]还大则无需再与[i-1]前面的元素进行比较了，反之则进入if语句</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j--) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];<span class="comment">// 把比temp大或相等的元素全部往后移动一个位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;<span class="comment">// 把待排序的元素temp插入腾出位置的(j+1)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****1.直接排序之后****:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h3><ul>
<li><p>思路：希尔排序就是将<b>插入排序</b>基础上的将原来的间隔由1变为：(n&#x2F;2),(n&#x2F;4),(n&#x2F;8)…直到n&#x3D;1;n为数组的长度</p>
</li>
<li><p>时间复杂度:O(n^1.3)</p>
</li>
</ul>
<h4 id="图片解释"><a href="#图片解释" class="headerlink" title="图片解释"></a>图片解释</h4><p><img src="http://img.blog.csdn.net/20170301123849295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellInsertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> dk)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dk; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - dk] &gt; a[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j -= dk) &#123;</span><br><span class="line">                    a[j + dk] = a[j];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + dk] = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dk</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (dk &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            shellInsertSort(a, n, dk);</span><br><span class="line">            dk /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****2.希尔排序之后****:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><ul>
<li><p>思路：每次都选择一个最大值放在最后面，选择一个最小值放在前面,(就是将当前的数和后面所有的数比较，找到一个最小的数进行交换)</p>
</li>
<li><p>时间复杂度：O(n^2)</p>
</li>
</ul>
<h4 id="图片解释-1"><a href="#图片解释-1" class="headerlink" title="图片解释"></a>图片解释</h4><p><img src="http://img.blog.csdn.net/20170301123902045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 将当前的和后面的进行对比,找出一个比当前还要小的然后和当前的进行互换位置</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[min];</span><br><span class="line">                a[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****3.选择排序之后:****&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结-下</title>
    <url>/2017/03/01/12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h2><ul>
<li><p>思路：堆就是一个完全二叉树（小顶堆），</p>
</li>
<li><p>主要解决两个问题:</p>
<ul>
<li><p>如何将n个待排序的数构建成堆</p>
<ul>
<li>输出堆顶元素之后如何调整剩下的n-1个元素，使之成为新的堆</li>
</ul>
</li>
</ul>
</li>
<li><p>时间复杂度:O(nlogn)</p>
<span id="more"></span>
<h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3></li>
</ul>
<p><img src="http://img.blog.csdn.net/20170301143400796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<p><img src="http://img.blog.csdn.net/20170301143445485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            buildMaxHeapify(a);</span><br><span class="line">            heapSort(a);</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;****4.堆排序之后:****&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建初始最大堆</span></span><br><span class="line">        <span class="comment">// 假设长度为8 那么</span></span><br><span class="line">        <span class="comment">// 第一个父节点就是a[3] 左结点为:a[7]</span></span><br><span class="line">        <span class="comment">// 第二个父节点为:a[1] 左节点为:a[3] 右结点为:a[4]</span></span><br><span class="line">        <span class="comment">// 第三份父节点为:a[2] 左节点为:a[5] 右结点为:a[6]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeapify</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;字符串的长度为:&quot;</span> + a.length);</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> getParentIndex(a.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                maxHeapify(a, a.length, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         *            数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">         *            数据长度</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">         *            当前的父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> length, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="comment">// 与当前左右结点进行比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getChildLeftIndex(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getChildRightIndex(index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行左右节点值的对比</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; length &amp;&amp; a[left] &gt; a[index]) &#123;</span><br><span class="line">                largest = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; length &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">                largest = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">                a[index] = a[largest];</span><br><span class="line">                a[largest] = temp;</span><br><span class="line">                <span class="comment">// 整理节点</span></span><br><span class="line">                maxHeapify(a, length, largest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左孩子的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildLeftIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右孩子的位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildRightIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个函数的含义就是： 将排好的最大堆的堆顶和最后一个交换再进行最大堆排序 排序：最大值放在末尾，再次进行排序</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">                a[<span class="number">0</span>] = a[i];</span><br><span class="line">                a[i] = temp;</span><br><span class="line">                maxHeapify(a, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5.冒泡排序"></a>5.冒泡排序</h2><ul>
<li><p>思路：就是不断的两两比较</p>
</li>
<li><p>时间复杂度:O(n^2)</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="http://img.blog.csdn.net/20170301143536765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的冒泡排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort_A</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-i- <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        Swap(a, j, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//改进的冒泡，添加了标记</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort_B</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        pos = i;</span><br><span class="line">                        Swap(a, i, i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                n = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><ul>
<li><p>思路：</p>
<ul>
<li>选择一个基准元素</li>
<li>通过一次快排序将待排序数分为两个部分，一部分比基准数小，一部分比基准数大</li>
<li>然后接着对这两部分进行相同的操作，直到序列有序</li>
</ul>
</li>
<li><p>时间复杂度：O(nlogn)</p>
</li>
<li><p>空间复杂度: O(nlogn)</p>
<h3 id="图解：-1"><a href="#图解：-1" class="headerlink" title="图解："></a>图解：</h3><p><img src="http://img.blog.csdn.net/20170301143550828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">privotLoc</span> <span class="operator">=</span> partition(a,low,high);</span><br><span class="line">                quickSort(a, low, privotLoc-<span class="number">1</span>);</span><br><span class="line">                quickSort(a, privotLoc+<span class="number">1</span>, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">privotKey</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=privotKey)--high;<span class="comment">//从后半部分向前扫描</span></span><br><span class="line">                a[low] = a[high];</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=privotKey)++low; <span class="comment">//从前部分扫描</span></span><br><span class="line">                a[high] = a[low];</span><br><span class="line">            &#125;</span><br><span class="line">            a[high] = privotKey;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开源框架总结</title>
    <url>/2017/03/14/13-Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Andorid开源框架总结"><a href="#Andorid开源框架总结" class="headerlink" title="Andorid开源框架总结"></a>Andorid开源框架总结</h1><blockquote>
<p>本文章转载自:<a href="http://www.jianshu.com/p/e94007f59e8d">zhuozhou810</a>，然后结合自己日常学习中用到的一些框架总结，谢谢！！！         </p>
</blockquote>
<ul>
<li><b>写在前面:</b><br> 最近通过Hexo+github终于弄成了一个自己像模像样的<a href="http://www.simoncode.top/">Blog</a>网站了。虽然都是跟着教程弄的，但是还是遇到了不少坑啊!四天的时间帮老师完成了一个很小的Demo，做完的时候其实内心还是很激动的。突然想到要不是写这个Demo我应该开学到现在还没有撸过代码。<br> <b>总结一下：</b>使用阿里云解析的时候记录值为:@+www，在github.io中添加CNAME指定xx域名<span id="more"></span>
<h2 id="图片总结"><a href="#图片总结" class="headerlink" title="图片总结"></a>图片总结</h2><img src="/images/%E5%AE%89%E5%8D%93%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.png"></li>
</ul>
<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul>
<li><a href="#%E7%BD%91%E7%BB%9C">网络</a>  </li>
<li><a href="#%E5%BD%B1%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86">影视频处理</a></li>
<li><a href="#View+Layout">View+Layout</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库操作</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%B1%82">系统层</a></li>
</ul>
<h2 id="网络">网络</h2>
* <b>[OkHttp](https://github.com/square/okhttp):比较全面的网络框架</b>
* <b>[retrofit](https://github.com/square/retrofit):okhttp注解封装框架</b>
* <b>[xutils3](https://github.com/wyouflf/xUtils3)：我使用最多的网络请求框架</b>
* <b>[nohttp](https://github.com/yanzhenjie/NoHttp):请求日志很好的开源框架</b>

<h2 id="影视频处理">影视频处理</h2>
* <h3>视频播放</h3>
   * <b>[JieCaoVideoPlayer ](https://github.com/lipangit/JieCaoVideoPlayer)</b>
* <h3>图片选择</h3>
   * <b>[GalleryFinal ](https://github.com/pengjianbo/GalleryFinal)</b>
* <h3>图片裁剪</h3>
   * <b>[cropper ](https://github.com/edmodo/cropper):图片裁剪</b>
   * <b>[PhotoView](https://github.com/bm-x/PhotoView):图片缩放</b>
* <h3>图片加载</h3>
   * <b>[picasso](https://github.com/square/picasso)</b>
   * <b>[smartimageview](https://github.com/JackCho/SmartImageView)</b>
* <h3>动画效果</h3><b>
   * [SmoothCheckBox](https://github.com/andyxialm/SmoothCheckBox):CheckBox
   * [MaterialEditText](https://github.com/rengwuxian/MaterialEditText):EditText
   * [SmoothProgressBar](https://github.com/castorflex/SmoothProgressBar):ProgressBar
   * [ExplosionField](https://github.com/tyrantgit/ExplosionField):视图爆炸效果</b>

<h2 id="View+Layout">View Layout</h2>
* <h3>屏幕适配</h3>
  * <b>[AndroidAutoLayout](https://github.com/hongyangAndroid/AndroidAutoLayout):Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配</b>
  * <b>[android-percent-support-lib-sample](https://github.com/JulienGenoud/android-percent-support-lib-sample):一个简单的Android适配库</b>
* <h3>图表控件</h3>
  * <b>[hellocharts-android](https://github.com/lecho/hellocharts-android):图表支持滚动，缩放和动画</b>
  * <b>[MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):一个流行的Android图标表</b>
* <h3>ViewPager相关</h3>
  * <b>[InfiniteCycleViewPager](https://github.com/Devlight/InfiniteCycleViewPager):viewpage双向取向和互动效果</b>
* <h3>ViewPager指示器</h3> <b>
  * <b>[MagicIndicator](https://github.com/hackware1993/MagicIndicator):强大，可定制，易拓展的ViewPager指示器</b>
  * <b>[NavigationTabBar](https://github.com/Devlight/NavigationTabBar):导航标签栏和丰富多彩的交互 </b>
* <h3>列表拖动排序、滑动删除、侧滑菜单等</h3> 
   * <b>[SwipeRecyclerView](https://github.com/yanzhenjie/SwipeRecyclerView):下拉刷新框架 </b>
   * <b>[DragRecyclerView](https://github.com/AleBarreto/DragRecyclerView):ListView支持拖 </b>
* <h3>Android布局</h3> 
   * <b>[FlowLayout](https://github.com/hongyangAndroid/FlowLayout):Android流式布局，支持单选、多选等，适合用于产品标签等。  </b>
* <h3>Fragment使用简化</h3> 
   * <b>[Fragmentation](https://github.com/YoKeyword/Fragmentation):一个管理Android Fragment的框架</b>
* <h3>字母导航栏</h3> 
   * <b>[ZzLettersSideBar](https://github.com/zhouzhuo810/ZzLettersSideBar):字母导航栏</b>
   * <b>[IndexableRecyclerView](https://github.com/YoKeyword/IndexableRecyclerView):提供城市选择和联系人选择等索引功能</b>
* <h3>角标</h3> 
   * <b>[android-viewbadger](https://github.com/jgilfelt/android-viewbadger):类似QQ消息通知时候的角标</b>
* <h3>二维码扫描</h3> 
   * <b>[barcodescanner](https://github.com/dm77/barcodescanner)：二维码扫描的库</b>
* <h3>侧滑菜单</h3>
   *  <b>[AndroidResideMenu](https://github.com/SpecialCyCi/AndroidResideMenu):侧滑菜单栏</b>

<h2 id="数据库">数据库操作</h2>
   * <b> [xutils3](https://github.com/wyouflf/xUtils3):强大的Android开源框架</b>

<h2 id="系统层">系统层</h2>
* <h3>内存管理</h3>
   * <b>[leakcanary](https://github.com/square/leakcanary):Android和Java内存管理的开源库</b>

<ul>
<li><h3>6.0权限管理</h3>
 * <b>[AndPermission](https://github.com/yanzhenjie/AndPermission):Android 6.0运行时权限管理</b></li>
<li><h3>线程间通信、组件间通信</h3> 
 * <b>[EventBus](https://github.com/greenrobot/EventBus)</b></li>
<li><h3>蓝牙、摄像头相关</h3>
 * <b>[FastBle](https://github.com/Jasonchenlijian/FastBle):蓝牙快速开发框架</b></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>详细了解哈夫曼树和背包问题</title>
    <url>/2017/04/12/14-%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="详细了解哈夫曼树和背包问题"><a href="#详细了解哈夫曼树和背包问题" class="headerlink" title="详细了解哈夫曼树和背包问题"></a>详细了解哈夫曼树和背包问题</h1><p><B>写在前面</b>：</p>
<ul>
<li>最近在疯狂复习数据结构和算法，虽然看完了一部完整的视频。但是转眼看看自己手中的《剑指Offer》里面还是不是很清楚。。。而且最近也突然觉得自己知识和别人比起来就是一个渣渣。各种被人家吊打。。。</li>
<li><b>这两个算法一个（哈夫曼树）是看最近视频动手实践的，一个(背包问题)是前段时间一个面试里面的题目，当时不知道这是一个系类的问题，昨天和大神聊完天之后才明白。所以乘着短暂的热情还在就记录下来</b>先从哈夫曼树开始！！ <span id="more"></span></li>
</ul>
<h3 id="1-哈夫曼树（实现基本的编码解码）"><a href="#1-哈夫曼树（实现基本的编码解码）" class="headerlink" title="1.哈夫曼树（实现基本的编码解码）"></a>1.哈夫曼树（实现基本的编码解码）</h3><ul>
<li><p>简单定义：<br>   给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<p>  复杂的文字定义我觉得以后肯定不会看。。所以直接来一张哈夫曼树的构造过程简单明了。。<br>  <img src="/images/17.4.11/huffmanTree.jpg"></p>
</li>
</ul>
<h4 id="1-模型构造"><a href="#1-模型构造" class="headerlink" title="1.模型构造"></a>1.模型构造</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">		String data;</span><br><span class="line">		<span class="type">double</span> weight;</span><br><span class="line">		Node leftChild;</span><br><span class="line">		Node rightChild;</span><br><span class="line">		Node parent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.leftChild;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String data, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.data = data;</span><br><span class="line">			<span class="built_in">this</span>.weight = weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;Node [data=&quot;</span> + data + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//队列排序依据</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">int</span>) (weight - o.weight);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> data.length() == <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>包含属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>定义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>数据</td>
<td>String</td>
</tr>
<tr>
<td>weight</td>
<td>权值</td>
<td>double</td>
</tr>
<tr>
<td>leftChild</td>
<td>左节点</td>
<td>Node</td>
</tr>
<tr>
<td>rightChild</td>
<td>右节点</td>
<td>Node</td>
</tr>
<tr>
<td>parent</td>
<td>父节点</td>
<td>Node</td>
</tr>
</tbody></table>
<h4 id="2-统计字符出现的次数，用出现的次数作为权值"><a href="#2-统计字符出现的次数，用出现的次数作为权值" class="headerlink" title="2.统计字符出现的次数，用出现的次数作为权值"></a>2.统计字符出现的次数，用出现的次数作为权值</h4><ul>
<li>这里实现的思路是：将出现的字符串(C)和次数(count)保存为一个Map&lt;字符，次数&gt;对象,然后再保存为List集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">statistics</span><span class="params">(<span class="type">char</span>[] charArray)</span> &#123;</span><br><span class="line">	Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> c : charArray) &#123;</span><br><span class="line">		<span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(character)) &#123;</span><br><span class="line">			map.put(character, map.get(character) + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			map.put(character, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">statisticsProbability</span><span class="params">(Map&lt;Character, Integer&gt; maps)</span> &#123;</span><br><span class="line">	List&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TestHuffmanTree_Encode_Decode.Node&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; map : maps.entrySet()) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(map.getKey().toString(), map.getValue());</span><br><span class="line">		list.add(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-根据统计的List进行哈夫曼树的构造"><a href="#3-根据统计的List进行哈夫曼树的构造" class="headerlink" title="3.根据统计的List进行哈夫曼树的构造"></a>3.根据统计的List进行哈夫曼树的构造</h4><p>首先List中保存的就是Node集合，其中Node的data就是字符串，Node的weight就是出现的次数也就是权值<br><B>哈夫曼树的构造:</B>   </p>
<ul>
<li>首先利用Java中的priorityQueue<E>方法进行模拟队列<br> priorityQueue<E>的用法 <!-- 插入图片--> 
 其中主要的方法：<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>将指定元素插入到次优先级队列</td>
</tr>
<tr>
<td>poll</td>
<td>获取并且移除队列头</td>
</tr>
<tr>
<td>peek</td>
<td>获取但是不移出队列</td>
</tr>
</tbody></table>
</li>
<li>将List中的数据保存到队列里面去</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  PriorityQueue&lt;Node&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">	priorityQueue.add(nodes.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><b>然后利用poll方法获取队列头节点</b>,这里可能就由疑问了，哈夫曼树不是要求按照权值最小的两个开始组成树嘛。这里为什么随便从队列里面弄两个出来就可以。<br>其实是这样的;在Node定义的时候实现了Comparable<Node>接口并且实现了compareTo（E e）方法，这里其实就已经实现了队列里面的排序<!--插入图片--></li>
<li>然后构建两个子节点的父节点，并且声明三者之间的关系(父子，左右)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">         <span class="comment">// 构建父节点</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">sumNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node1.data + node2.data, node1.weight</span><br><span class="line">		+ node2.weight);</span><br><span class="line"></span><br><span class="line">sumNode.leftChild = node1;</span><br><span class="line">sumNode.rightChild = node2;</span><br><span class="line"></span><br><span class="line">node1.parent = sumNode;</span><br><span class="line">node2.parent = sumNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后再将父节点保存到队列中去:这样做的目的是为了得到根节点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">priorityQueue.add(sumNode);</span><br></pre></td></tr></table></figure></li>
<li>最后返回根节点 priorityQueue.poll();</li>
</ul>
<p><B>这样，到这里哈夫曼树的构建就完成了，但是既然学习了就深入一点，<br>哈夫曼树的最长用途就是用来文件压缩，因为我们知道发送一句话的时候并不是每个字母出现的频率都是一样的，有的出现的多有的出现的少，但是如果还是使用一样额编码那样会有很大的消耗，所以这里我们就用哈夫曼树实现对字符串的编码和解码</b></p>
]]></content>
  </entry>
  <entry>
    <title>最近的总结</title>
    <url>/2017/05/08/15-%E6%9C%80%E8%BF%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>先来一张我最喜欢的照片</strong><br><img src="/images/17.5.8/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%85%AB%E5%B2%81.jpg"></p>
<blockquote>
<p>写在前面:晚上解决一个算法问题，解决了一晚上但是并没有解决^_^，所以趁着现在还没有回去的时间对自己最近的生活学习状况进行一个总结。</p>
</blockquote>
<span id="more"></span>

<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h3><p>  说到上课，愈发的觉得自己成为老油条了。大一的时候上课带书又带笔有时候还带草稿本，大二带书带笔，大三沦落到要考试了都不知道带笔去上课。。好在这个学期的考试课很少，大部分的考察课都是可以蒙混过关的。其实说道上课，我就不得不说一下我们BT的学校，上课收手机，院长动不动就冲进来这种事情真的没想到在读大学的我身上发生了，真的无语。讲道理，院里面这样抓我们的学习，应该是很放心我们的就业的，但是动不动就以名曰“就业指导”的口号叫我们去各种培训机构的宣讲会。看来对赚钱的事情果然每个人都是很上心的。说实话虽然在我的心目中是很抵触培训机构的，因为要是去培训结构的话什么不直接不读大学就去呢？非要在大学耽误那么长时间。但是我也不否认培训结构对一些大学没学习(讲道理我也啥都没学到)什么的是一条路子。但是为什么我觉得是屎的东西院里面还要用力往每个人嘴里面喂。。搞不懂搞不懂。。</p>
<h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><ul>
<li><p>看完了小甲鱼关于数据结构的视频</p>
</li>
<li><p>看完了《剑指Offer》</p>
</li>
<li><p>参加了春招的笔试(心痛自己)</p>
</li>
<li><p>参与了实验室的一点小项目</p>
</li>
<li><p>复习了Java的很多小基础知识</p>
<p>一本《剑指Offer》开学的时候买的，到今天才算是真真的搞完了(虽然保存到了github,因为都是一些平常学习的代码，所以将仓库私有了，主要还是怕丑^_^)。说实话虽然是看完了，只能说自己以后看到这种编程题目的时候不会再那么畏惧，但是好多思路还是不知道从哪里来。虽然有时候看的也不是很认真，但是毕竟是过了一遍的。发自内心的觉得算法这个东西很强大。关于看完数据结构的C语言版视频虽然也花了很长时间，但是只能说是是加深了其中的某些印象，比如树的结构，二叉树的便利，链表,队列…看过的还是知道一点的。再说说关于春招，觉得还是自己的态度没有摆端正，算法问题一点都不知道，所以做每个公司的编程题目的时候都不知道从何下手，很多问题都是没有听说过，其中关于哈夫曼树和背包问题我花了一下午的时候进行了详细的总结。觉得也算是自己的一点成就吧。既然春招没有用心准备，那就把所有的心思都放在秋招上面咯。只有祝自己好运咯。</p>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="/images/17.5.8/graduation_photo_1.jpg"><br><img src="/images/17.5.8/graduation_photo_2.jpg"><br>  上个星期四拍完的毕业照，我们院有着个让人不能理解的传统，每届都是在大三的时候拍毕业照。可惜我那天并没有把头发梳成大人模样，哈哈… 现在还记得我们上一届拍毕业照的时候，那天我刚好在实验室，他们抱着一大堆学士服，没想到一转眼就轮到我穿上了。。(话说那天还被他们草柱子了)<strong>现在这里立一个flag：大四毕业的时候一定要喝醉。。</strong>感觉之前的日子有点想不起来了。。(尴尬)<br>    最后再说说和纯纯的事情吧(感觉很少把这种事情写成文字发出来):纯纯现在下定目标准备出国读研了，这就意味着她也是要面临这毕业就就业的问题了。我内心从大一的时候就有这种打算所以对我来说还好，我就怕纯纯到时候有点不能接受。好了这个事情就不扯了。虽说我们两个这个学期也是有点小问题不断，而且我都总结出规律来了(都是星期五的！！！),但是还是坚持下来了，对我来说，在一起之前我都不知道什么叫做”异地恋”,感觉稀里糊涂的就开始了这段恋情。而且稀里糊涂得一起过了这么久，有时候自己想想都觉得有点不可思议。。感觉这个学期结束之前应该没有机会去她哪里了。说起来惭愧大学到现在三年了，去过他们学校的次数真的可以用手指头数出来。。<br>    最后的最后就来说一下去郑州的过程吧。虽然去之前我们还闹着矛盾，原本准备星期五见面的我冲动的买了当天的票，火车上坐了一晚上都是想着见面时候的喜悦。越想越激动，想着待会纯纯见到我的时候的喜悦，坐公交的时候感觉自己都想一到就冲下去的那种。果然所有异地恋都一样，一见面什么问题多解决了。哈哈，还来了一个少林寺一日游。开心。！！<strong>我不知道未来怎么样，我只想好好的过好现在的每一天</strong><br>  最后的最后来几张照片吧。。 哈哈<br><img src="/images/17.5.8/chunchun1.jpg"><br><img src="/images/17.5.8/chunchun2.jpg"><br><img src="/images/17.5.8/chunchun3.jpg"><br><img src="/images/17.5.8/chunchun4.jpg"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>技术小计</title>
    <url>/2017/09/02/16-%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="技术小计"><a href="#技术小计" class="headerlink" title="技术小计"></a>技术小计</h2><blockquote>
<p> 写在前面，这篇博客的目的主要是总结我在公司实习的这两个月里面所接触的一些新技术栈，因为时间的关系今天就只能跟新我自己弄的ELK监控平台，以后肯定会慢慢把我这两个月学习的补充上去。</p>
</blockquote>
<span id="more"></span>

<h3 id="ELK-日志监控平台"><a href="#ELK-日志监控平台" class="headerlink" title="ELK 日志监控平台"></a>ELK 日志监控平台</h3><blockquote>
<p> 缘起: 因为实习公司的主要业务就是爬虫,所以所有的服务都是以分布式的方式存在。所以公司就使用ELK搭建了一个日志监控平台。</p>
</blockquote>
<p>首先ELK看似是存在三个服务的，就我简单理解。分别为:</p>
<ul>
<li>Elasticsearch 处理格式化日志</li>
<li>Logstash 收集日志</li>
<li>Kinaba 前台展示</li>
</ul>
<p>那我现在就一一讲一下我搭建这个平台的时候碰到的坑。首先这三个服务的所有下载包都可以到Elk下载。</p>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ul>
<li><p>下载安装包<br><code>wget https://artifacts.elasticco/downloads/elasticsearch/elasticsearch-5.5.2.zip</code></p>
<ul>
<li>使用非root用户登陆</li>
<li>因为Elasticsearch的安全策略，禁止root用户启动，所以需要创建一个非root用户来运行Elasticsearch程序。<code>useradd simon</code></li>
<li>更换Elasticsearh的工作目录的所有者和组都为<code>simon</code>所有。</li>
</ul>
</li>
<li><p>修改配置文件</p>
<ul>
<li>开启服务之前还会遇到一个坑，就是Elasticsearch默认的内存为2g而一般的服务器都不会得到那么大的内存，所以需要到<code>/config/log4j2.properties</code> 修改内存为能顾接受的范围。</li>
</ul>
</li>
<li><p>运行<br>好了到这里Elasticsearch的配置就差不多了,只需要让它默默的跑在后台给我们处理日志就可以了。<code>nohup ./bin/elasticsearch &gt;&amp; nohup.out &amp;</code></p>
</li>
<li><p>验证<br>如何看自己的Elasticsearch是否真的运行在后台呢？<br>只需要访问Elasticsearch的服务测试一下就可以<code>curl localhost:9200</code></p>
</li>
</ul>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><ul>
<li><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/logstash/logstash-5.5.2.tar.gz  tar -zxvf</code></p>
</li>
<li><p>创建输入输出模板<br>前面说过我的浅显理解Logstas就是用来对日志的收集，所以必定存在对日志输入和输出设定。我这里使用的log4j的日志输入，而且Logstash存在log4j的模板，所以我的日志设置为(需要自建文件):<br><code> Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html input &#123; For detail config for log4j as input, See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html log4j &#123;   mode =&gt; &quot;server&quot;   host =&gt; &quot;0.0.0.0&quot;   port =&gt; 4500 &#125; &#125; filter &#123; Only matched data are send to output. &#125; output &#123; For detail config for elasticsearch as output, See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html elasticsearch &#123;   action =&gt; &quot;index&quot;          #The operation on ES   hosts  =&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.   index  =&gt; &quot;applog&quot;         #The index to write data to. &#125; &#125;</code></p>
</li>
</ul>
<p>其中各个参数的含义如下:</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mode</td>
<td align="center">server&#x2F;client</td>
<td align="center">服务器&#x2F;客户端</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">string</td>
<td align="center">服务地址</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">int</td>
<td align="center">服务端口</td>
</tr>
<tr>
<td align="center">antion</td>
<td align="center">index</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">hosts</td>
<td align="center">string</td>
<td align="center">服务的地址</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">Stirng</td>
<td align="center">parent 的名称</td>
</tr>
</tbody></table>
<p>其中，加入你是把你的ELK放在服务器端的话，就需要把hosy设置成为允许访问的ip即 0.0.0.0</p>
<ul>
<li>SpringBoot日志输送</li>
</ul>
<p>由于SpringBoot的成熟，所以已经集成了Logstash的日志传输服务，只需要在application.properties中添加:</p>
<p><code>log4j.appender.logstash=org.apache.log4j.net.SocketAppender log4j.appender.logstash.RemoteHost=your_server_host log4j.appender.logstash.port=4500 log4j.appender.logstash.ReconnectionDelay=60000 log4j.appender.logstash.LocationInfo=true</code></p>
<p>当然你事先得导入log4j的maven依赖库</p>
<p><code>&lt;dependency&gt;   &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt;</code></p>
<ul>
<li>运行</li>
</ul>
<p>当一切准备结束之后，我们就可以让Logstash也默默热运行在后台了<br><code>nohup ./bin/logstash -f log4j.conf *&amp; nohup.out &amp;</code></p>
<h3 id="Kinaba"><a href="#Kinaba" class="headerlink" title="Kinaba"></a>Kinaba</h3><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/kibana/kibana-5.5.2-linux-x86_64.tar.gz tar -zxvf</code></p>
<ul>
<li>配置Kinaba允许外网访问</li>
</ul>
<p>进入Kinaba的<code>config/</code>目录下vi Kinaba.yml<br>其中将:</p>
<ul>
<li>server.port ：port</li>
<li>server.host :0.0.0.0</li>
<li>elasticsearch.url: “<a href="http://localhost:9200“">http://localhost:9200“</a></li>
</ul>
<p>设置完毕，看起来Kinaba的设置相比前面起来简单很多。</p>
<ul>
<li>运行</li>
</ul>
<p>啦啦啦，只需要简单的配置Kinaba的服务可以运行起来了。<br><code>nohup Kinaba &gt;&amp; nohup.out &amp;</code></p>
<ul>
<li>测试</li>
</ul>
<p>我们可以打开浏览器输入: localhost:port，等一会，我们就可以看到Kinaba的界面了。<br>然后在中我们在配置Logstash设置的index属性：applog，然后我们就可以看到我们的日志文件了。</p>
<p><strong>最后说一下，三个的服务启动时存在先后顺序的，处理日志的Elasticsearch必须第一个启动，原因是Logstash中设置了文件输出的位置，假设Elasticsearch的服务没有启动的话，就会存在找不到输出文件的错误。同理在Knaba中也设置了读取日志文件的位置。</strong></p>
<p>好了，到这里一个简单的日志监控平台就搭建完毕了，因为我写的这篇博客完全都是出于个人的理解，所以其中个肯定存在很多问题。仅供参考。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>实习总结</title>
    <url>/2017/09/03/17-%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>17.7.3-17.9.3 刚好两个月的时间，我觉得我有必要对我的第一次实习做一次总结了。</p>
<span id="more"></span>
<h2 id="从第一天说起"><a href="#从第一天说起" class="headerlink" title="从第一天说起"></a>从第一天说起</h2><p>6.30号，因为前天晚上我和室友们一起开放打麻将，早上起来的一场大雨真的是一点面子也没给，我们四个冒着大雨从宾馆冲回了宿舍，因为所有的东西都基本收拾差不多了，我们拿到行李箱之后便向接我们的大巴走去。四个人，三个人去一个地方，而另外一个去其他地方的就是我。庆幸的是我们乘坐的是同一辆车，伴随这忽大忽小的雨我们到达了武汉，一到武汉我感觉我整个人呢愈发的抗拒起来，我抗拒的并不是这座城市，而是马上要去的培训机构。我讨厌去哪里学习一些我丝毫不感兴趣的东西，我讨厌学校的领导把我们当作他们的赚钱工具。好在，我是幸运的，我能够逃离那个地方去另外一个地方继续学习我喜欢的知识。然而那天也发生了很多插曲，比如我害怕纯纯等的太久就自己离开了集合的地方而被班主任简单的批评了一顿。因为不得不面对，和社会上的人商量租房。拖着巨大的行李箱住进了这座我陌生的城市。</p>
<h2 id="两个月中"><a href="#两个月中" class="headerlink" title="两个月中"></a>两个月中</h2><p>当第一天在公司上完班之后，觉得之前心里的恐惧少了几分。取而代之的是对这座城市的适应，物价和咸宁的区别，生活方式和学校的区别，这些都在慢慢的适应。觉得那些干吧的话我也不知道怎么说了，下面我就从技术方面对自己总结一下。<br>掌握&#x2F;了解到新的技术栈:</p>
<ul>
<li>SpringBoot</li>
<li>Redis</li>
<li>Hbase</li>
<li>Vue</li>
<li>前端</li>
<li>ELK</li>
<li>分布式服务</li>
<li>Nginx</li>
<li>Maven<br>上面这些我所列举都是我在学校没有听过或者听过从来没有实践过的，但是在这两个月里，我每天都是和这些技术一起。给我最直观的区别就是学校学习的东西和外面用到的东西区别是真的大。我们学校还是在用三大框架，各种xml配置，而学习了SPringBoot之后我觉得这个框架真的大大的减轻了开发的成本。而因为boss的要求，我一个前端小白，也硬着头皮把一个前端项目迁移成为Vue项目。迁移过程中我了解到不少前端的知识，包括WebPack 和jQuery BootStapt 。。。 附上一个我准备详细整理我学习的技术栈的链接戳我<h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2>这次去了之后，打算好好的整理整理自己的简历，秋招我来了！！！</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>生活</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器迁移小计</title>
    <url>/2018/06/03/18-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>哇.一晃一年过去了,看自己上篇博客还是去年九月份的时候更新了，唉！回想起自己秋招之后的这半年,感觉真的是可以用命运多舛来形容了,好在日子会越过越好,现在的工作虽然没有武汉时那么清闲,偶尔会加班到十一二点,但是年轻人嘛,或者就是折腾得。刚好撑着这个周末其它的一些事情都处理结束了,查看自己的阿里云也马上到期了,(😔 毕业就薅不到这些羊毛了)。但是服务器上还部署着很多服务,所以想着刚好写写自己最近的状态和把服务器上的东西备份一下。</p>
</blockquote>
<span id="more"></span>
<h2 id="服务器迁移"><a href="#服务器迁移" class="headerlink" title="服务器迁移"></a>服务器迁移</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li><p>1.去Java官网下载相关的Jdk开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>1.编辑相关环境变量<code>vim /etc/profile</code></li>
<li>2.添加环境变量  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   export JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=./:$JAVA_HOME/lib:$JAVA_HOM/jre/lib</span><br></pre></td></tr></table></figure></li>
<li>3.执行<code>source /etc/profile</code></li>
<li>4.验证<code>java -version</code></li>
</ul>
<p>  到这里Java的开发环境就安装好了,很简单有木有。</p>
</li>
</ul>
<h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><p>作为一个Java开发者,怎么可能少的了Mysql呢,但是现在由于云技术的发展,安装mysql可以采用两种方式,下面具体介绍</p>
<ul>
<li><p>普通安装方式(不推荐)</p>
<p>1.可以去Mysql的官网下载相关依赖库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>2.使用仓库安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>

<p>3.mysql的一些基本命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld #启动MySQL</span><br><span class="line">systemctl stop mysqld #关闭MySQL</span><br><span class="line">systemctl restart mysqld #重启MySQL</span><br><span class="line">systemctl status mysqld #查看MySQL运行状态</span><br><span class="line">systemctl enable mysqld #设置开机启动</span><br><span class="line">systemctl disable mysqld #关闭开机启动</span><br></pre></td></tr></table></figure>

<p>4.找到临时密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>5.删除密码安全限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNINSTALL PLUGIN validate_password;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>到这里普通的Mysql安装方式也结束了,那么来看看Doker是如何安装的把</strong></p>
</blockquote>
<ul>
<li><p>采用Docker安装</p>
<ul>
<li><p>1.首先得安装Docker</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install docker-io</span><br></pre></td></tr></table></figure></li>
<li><p>2.找到一个可靠的源(这里推荐DaoCloud的源)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://hub.daocloud.io/</span><br></pre></td></tr></table></figure></li>
<li><p>3.配置Mysql的镜像</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=xxx -p 3306:3306 -d daocloud.io/mysql:tag</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>MYSQL_ROOT_PASSWORD</code>后加mysql的密码</li>
<li><code>-p</code>后加需要映射的端口</li>
</ul>
</li>
<li><p>4.安装进行后<br>  我们就存在一个默认的容器,使用<code>docker ps</code>就可以看到列表</p>
</li>
<li><p>5.如何进入容器<br>  <code>docker exec -it xxx /bash/bin</code></p>
</li>
</ul>
<p>  <strong>到这里Mysql Docker的安装方式也结束了</strong></p>
</li>
</ul>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx是现在比较主流的一款web服务器,但是在Linux上，nginx的安装方式还是很麻烦的,所以有Docker的情况下,我们没比较再去花时间在安装上面，我们可以直接去镜像中心下载nginx的镜像</p>
<ul>
<li>编写自己的Dockerfile<ul>
<li>1.创建相关的文件夹<br>  <code>mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</code>三个文件夹的含义分别为:<ul>
<li>www目录将映射为nginx容器配置的虚拟目录</li>
<li>logs目录将映射为nginx容器的日志目录</li>
<li>conf目录里的配置文件将映射为nginx容器的配置文件</li>
</ul>
</li>
<li>2.拉取Nginx镜像  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li>
<li>3.运行镜像  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>-p 80:80：将容器的80端口映射到主机的80端口</p>
</li>
<li><p>–name mynginx：将容器命名为mynginx</p>
</li>
<li><p>-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</p>
</li>
<li><p>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
</li>
<li><p>-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</p>
</li>
</ul>
</li>
</ul>
<h3 id="服务程序"><a href="#服务程序" class="headerlink" title="服务程序"></a>服务程序</h3><blockquote>
<p>现在在服务器上还存在的程序有:<a href="http://simoncode.top/movie">80s的电影爬虫</a>,<a href="http://simoncode.top/">个人主页</a>;</p>
</blockquote>
<h4 id="电影爬虫"><a href="#电影爬虫" class="headerlink" title="电影爬虫"></a>电影爬虫</h4><p>这个项目是采用SpringBoot+Redis实现的,其实编写的时间还算挺早的,早在17年九月份在武汉实习的时候花了不到一个星期就完成了,之后就一直部署在自己的服务器上，期间还自己重构过几次,但是由于天生并不是编写前端的料子,所及虽然重构过几次,页面依然是非常的丑.这个爬虫采用SpringBoot编写,所以只需要有Java环境就可以运行,但是里面相关依赖了Redis、Mysql等组件,所以运行的话需要先将这个组件安装.</p>
<ul>
<li><p>自动化更新脚本:</p>
<p>  凭借自己对Linux的一知半解,编写了一个脚本,用来自动化从Git上拉取代码和更新打包运行。脚本主要分三部分:</p>
<p> 运行脚本(run.sh):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java  -jar  -Dserver.port=8089  xxx-1.0-SNAPSHOT.jar   &amp;&gt;nohup.out &amp;</span><br></pre></td></tr></table></figure>
<p> 停止脚本(stop.sh):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   for PID in `ps aux | grep &#x27;java&#x27; | grep &#x27;movie&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`; do</span><br><span class="line">        kill -9 $PID</span><br><span class="line">done</span><br><span class="line">echo &quot;[kill Simon service]&quot;</span><br></pre></td></tr></table></figure>
<p> 更新脚本(update.sh):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/source/Zhihu #源码路径</span><br><span class="line">git pull #更新代码</span><br><span class="line">mvn package -Dmaven.test.skip=true #maven打包</span><br><span class="line">cd ~/zhihu	#进入项目目录</span><br><span class="line">sh stop.sh </span><br><span class="line">rm -f web-1.0.0-SNAPSHOT.jar</span><br><span class="line">mv ~/source/Zhihu/web/target/web-1.0-SNAPSHOT.jar ~/zhihu</span><br><span class="line">echo Project Update Finish </span><br><span class="line">sh run.sh</span><br><span class="line">echo Project Running</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>使用上部分自动化脚本的前提是你得配置了github的相关ssh key<br>其实配置github的相关key 也是很简单的,只需要在bash中输入<code>ssh-keygen -t rsa -C &quot;email&quot;</code>就可以了</p>
</blockquote>
<h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><ul>
<li>其中程序的主要代码都托管在github上了,需要备份的主要是sql数据。sql数据中有两部分:1.就是爬取的电影的sql 2.就是毕业设计做的爬取知乎的sql。</li>
</ul>
<h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p>😔,今天都已经是六月3号了,2018年都已经过半了,这个月中旬,我的身份也要从大学生变成了一名社会人了,虽然当初在学校的时候，由于各种原因,自己一直迫切着想要去工作,但是当想想自己马上就要离开校园,再也回不去的时候,还是有一点点感伤的。再想想自己的2017年后半年,一点新鲜的技术都没有学习到,用的东西和了解的东西也都过于局限。</p>
<h2 id="New-Life"><a href="#New-Life" class="headerlink" title="New Life"></a>New Life</h2><blockquote>
<p>既然是自己的博客,那么久可以畅所欲言和记录自己琐碎的事情.</p>
</blockquote>
<p>4.16日,毕业答辩。虽然距离现在马上要到两个月了,但是那天或者说那个星期的事情我都依然清楚的记得。那天早上六点多我就醒来,收拾收拾后便和邹恒一起打的前往火车站,我们是九点半的车但是我们七点多就到了火车站,等了两个多小时,当我们提着行李到铁轨旁后车时。我俩都感觉自己度过了滑稽可笑的三个月,三个月里面知识没长、见识没长、钱包没长。我俩商量着接下来的打算,他准备去深证我准备…经过一天的“长途跋涉”，终于到了学校,哇 看到同学回到宿舍的那一刻真的好幸福,顿时感觉自己还是一个学生,什么压力都没有。五点多到宿舍,和同学交流了一会,便去和张鹏赴约,感觉和张鹏总是有聊不完的话题,可能都是对技术的喜欢,就像我和邹恒一样,总是有聊不完的技术和问题,[虽然大部分时间都是他在和我讲着我从来都没有听说过的技术]。见到老哥的那一刻依然是那么的情切,还没来得及聊聊最近的状况他便去见他的导师了。唉约好的去一次上海都没有实现。</p>
<p>第二天,也就是答辩的那天,七点多我本来还在床上睡觉呢,室友便说他程序有bug🤣叫我去帮忙修bug，带着困意和疲惫。我去了。没想到的是我尽然在哪里呆了一天😂也就是我帮他们修了一天的bug。和同学们聊天感觉真的很开心！但是由于自身的原因，第二天晚上便离开了学校。后面的事情就让它过去吧。</p>
<p><strong>讲讲现在吧</strong><br>也不知道是命运还是啥,本来信心满满的小杨并没有考上自己准备一年的志愿者。带着失落的她也投身到了找工作的行列,有时候命运就是那么意想不到,从大一开始就准备工作的我到上个月才能说是真正的开始工作,而一直以为会继续读书的她既然也开始了工作，好在彼此都比较勤奋和努力,虽然比不上那些大佬,但是和暂时的自己比起来还是算不差的。</p>
<p>她在南京找到了一份还不错的工作，福利待遇行业都比较符合她的口味,就这样我们寄去年七月份后又再一次的在一起了,也算结束了四年的异地恋.每天下班早或者周末的时候都可以做一顿好吃的一起品尝。[话说现在的我做饭手艺确实不赖啊!]</p>
<p>最后分享一点最近的照片吧.</p>
<p><img src="/images/18.6.3/01.JPG" alt="酷酷的小杨"></p>
<center><font color=grey>**酷酷的小杨**</font></center>
![安静的小杨](/images/18.6.3/02.JPG)
<br>
![安静的小杨](/images/18.6.3/03.JPG)
<br>
![酷酷的小杨](/images/18.6.3/04.JPG)
<br>
![酷酷的小杨](/images/18.6.3/05.JPG)
<br>
![酷酷的小杨](/images/18.6.3/06.JPG)
<br>
![酷酷的小杨](/images/18.6.3/07.JPG)
<br>
![酷酷的小杨](/images/18.6.3/08.JPG)
<center><font color=grey>**安静的小杨**</font></center>
![快要死掉的多肉](/images/18.6.3/09.JPG)
<center><font color=grey>**快要死掉的多肉**</font></center>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Linux</tag>
        <tag>云服务</tag>
        <tag>Docker</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>记ETH智能合约小计</title>
    <url>/2018/06/24/19-ETH%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章是因为上个星期处理了一个ETH中智能合约的业务,所以趁着自己还记得,梳理一下.</p>
</blockquote>
<!---more--->
<h2 id="ETH智能合约"><a href="#ETH智能合约" class="headerlink" title="ETH智能合约"></a>ETH智能合约</h2><blockquote>
<p>下面的这些理解都是我片面的理解,并没有得到书面的证实.</p>
</blockquote>
<p>这里要说的ETH中的智能合约是EIEC币(电能链)</p>
<ul>
<li><p>智能合约的理解</p>
<p>  智能合约可以看做是部署在以太坊上的一个程序。但是这个程序是透明的代码是开源可见的.而发行的代币可以看做是这个程序里面的一个积分.</p>
</li>
<li><p>处理的业务</p>
<ul>
<li>1.查询余额</li>
</ul>
<p>  智能合约的查询余额方法需要调取一个<code>call</code>的方法,而该方法可以看做是一笔转账，通过ETH的<a href="!https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call">wiki</a>我们可以查到该方法所需要的一些参数.</p>
<ul>
<li>2.进行数据签名和广播</li>
</ul>
<p>  这里就不深入的进行讲解了,智能合约和ETH的签名数据区别在于存在一个ABI编码后的data数据。</p>
<ul>
<li>3.交易查询</li>
</ul>
<p>  由于智能合约的所有交易的toaddr都是指向了智能合约的主地址(MasterAddr,一个智能合约在主网上的地址是唯一的)。所以并不能更具一笔交易的toaddr查到该交易的具体细节。以太坊提供了另一个方法<code>eth_getTransactionReceipt</code><a href="!https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt">wiki</a>来查询改合约的具体结果.</p>
</li>
</ul>
<p> 这里只是很简单的编写了一下。具体的细节可以等下次有时间把具体的流程和数据结构一起带上。</p>
]]></content>
  </entry>
  <entry>
    <title>EOS 同步相关</title>
    <url>/2019/01/17/20-EOS%20%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>最近一直都在处理 EOS 同步相关的事情,刚好今天有空,就将最近整理的资料发布出来。</p>
<span id="more"></span>

<h1 id="使用-nodeos-快速做一个-EOS-RPC-节点"><a href="#使用-nodeos-快速做一个-EOS-RPC-节点" class="headerlink" title="使用 nodeos 快速做一个 EOS RPC 节点"></a>使用 nodeos 快速做一个 EOS RPC 节点</h1><h2 id="1-下载-nodeos"><a href="#1-下载-nodeos" class="headerlink" title="1.下载 nodeos"></a>1.下载 nodeos</h2><ul>
<li><p>EOS 提供 Release 下载,下载地址 <a href="https://github.com/EOSIO/eos/releases">https://github.com/EOSIO/eos/releases</a>;选择适当的版本下载。</p>
</li>
<li><p>下载:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/EOSIO/eos/releases/download/v1.5.3/eosio_1.5.3-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>安装:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ./eosio_1.5.3-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>验证</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeos -v</span><br></pre></td></tr></table></figure>
<p>查看当前 nodeos 版本</p>
<h2 id="2-下载logs文件"><a href="#2-下载logs文件" class="headerlink" title="2.下载logs文件"></a>2.下载logs文件</h2><ul>
<li>地址:<br>日志备份地址:<a href="https://eosnode.tools/blocks">BLOCKS ARCHIVE</a>;</li>
<li>下载:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget $(wget --quiet &quot;https://eosnode.tools/api/blocks?limit=1&quot; -O- | jq -r &#x27;.data[0].s3&#x27;) -O blocks_backup.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>解压</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvzf blocks_backup.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h2><ul>
<li>config.ini</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">agent-name = EOSNODE</span><br><span class="line"></span><br><span class="line">chain-state-db-size-mb = 10240</span><br><span class="line">reversible-blocks-db-size-mb = 340</span><br><span class="line"></span><br><span class="line">http-server-address = 0.0.0.0:8870</span><br><span class="line"></span><br><span class="line">http-validate-host = false</span><br><span class="line">verbose-http-errors = true</span><br><span class="line">abi-serializer-max-time-ms = 2000</span><br><span class="line"></span><br><span class="line">access-control-allow-origin = *</span><br><span class="line">allowed-connection = any</span><br><span class="line"></span><br><span class="line">max-clients = 2</span><br><span class="line">connection-cleanup-period = 30</span><br><span class="line">network-version-match = 1</span><br><span class="line">sync-fetch-span = 2000</span><br><span class="line">enable-stale-production = true</span><br><span class="line"></span><br><span class="line">max-implicit-request = 1500</span><br><span class="line">pause-on-startup = false</span><br><span class="line">max-transaction-time = 30</span><br><span class="line">max-irreversible-block-age = -1</span><br><span class="line">txn-reference-block-lag = 0</span><br><span class="line"></span><br><span class="line">plugin = eosio::chain_api_plugin</span><br><span class="line">plugin = eosio::chain_plugin</span><br></pre></td></tr></table></figure>

<ul>
<li>p2p 地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p2p-peer-address = 185.253.188.1:19876</span><br><span class="line">p2p-peer-address = bp.cryptolions.io:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eospace.io:88</span><br><span class="line">p2p-peer-address = eu-west-nl.eosamsterdam.net:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eosgermany.online:9876</span><br><span class="line">p2p-peer-address = 35.197.190.234:19878</span><br><span class="line">p2p-peer-address = mainnet.genereos.io:9876</span><br><span class="line">p2p-peer-address = mainnet.eospay.host:19876</span><br><span class="line">p2p-peer-address = 130.211.59.178:9876</span><br><span class="line">p2p-peer-address = 54.153.59.31:9999</span><br><span class="line">p2p-peer-address = 94.130.250.22:9806</span><br><span class="line">p2p-peer-address = peer.main.alohaeos.com:9876</span><br><span class="line">p2p-peer-address = peer.eosn.io:9876</span><br><span class="line">p2p-peer-address = prod.mainnet.eos.cybex.io:9888</span><br><span class="line">p2p-peer-address = p2p-1.eosnetwork.io:9876</span><br><span class="line">p2p-peer-address = p.jeda.one:3322</span><br><span class="line">p2p-peer-address = eosbattles.com:9877</span><br><span class="line">p2p-peer-address = 34.226.76.22:9876</span><br><span class="line">p2p-peer-address = mainnet.eosoasis.io:9876</span><br><span class="line">p2p-peer-address = node.eosflare.io:1883</span><br><span class="line">p2p-peer-address = mainnet.eoscalgary.io:5222</span><br><span class="line">p2p-peer-address = eos-p2p.worbli.io:33981</span><br><span class="line">p2p-peer-address = 18.188.38.175:9876</span><br><span class="line">p2p-peer-address = 18.221.255.38:9876</span><br><span class="line">p2p-peer-address = eos.staked.us:9870</span><br><span class="line">p2p-peer-address = peering.dutcheos.io:9876</span><br><span class="line">p2p-peer-address = 18.188.4.97:9876</span><br><span class="line">p2p-peer-address = 18.191.125.105:9876</span><br><span class="line">p2p-peer-address = boot.eostitan.com:9876</span><br><span class="line">p2p-peer-address = eosboot.chainrift.com:9876</span><br><span class="line">p2p-peer-address = dc1.eosemerge.io:9876</span><br><span class="line">p2p-peer-address = m.eosvibes.io:9876</span><br><span class="line">p2p-peer-address = node1.eosphere.io:9876</span><br><span class="line">p2p-peer-address = node2.eosphere.io:9876</span><br><span class="line">p2p-peer-address = 45.33.60.65:9820</span><br><span class="line">p2p-peer-address = peering.eosio.cr:1976</span><br><span class="line">p2p-peer-address = peering.eosio.cr:5418</span><br><span class="line">p2p-peer-address = 54.203.121.17:19866</span><br><span class="line">p2p-peer-address = eosnode.fi:9888</span><br><span class="line">p2p-peer-address = api.eosuk.io:12000</span><br><span class="line">p2p-peer-address = fullnode.eoslaomao.com:443</span><br><span class="line">p2p-peer-address = new.eoshenzhen.io:10034</span><br><span class="line">p2p-peer-address = peer.eosio.sg:9876</span><br><span class="line">p2p-peer-address = eos.nodepacific.com:9876</span><br><span class="line">p2p-peer-address = 18.234.6.119:80</span><br><span class="line">p2p-peer-address = eu1.eosdac.io:49876</span><br><span class="line">p2p-peer-address = br.eosrio.io:9876</span><br><span class="line">p2p-peer-address = p2p-public.hkeos.com:19875</span><br><span class="line">p2p-peer-address = node.eosmeso.io:9876</span><br><span class="line">p2p-peer-address = pub1.eostheworld.io:9876</span><br><span class="line">p2p-peer-address = 807534da.eosnodeone.io:19872</span><br><span class="line">p2p-peer-address = mainnet.eoseco.com:10010</span><br></pre></td></tr></table></figure>

<h2 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h2><p>执行以下命令,进行 EOS 同步:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeos --data-dir /blockData/blocks --config-dir /blockData --hard-replay --wasm-runtime wabt</span><br></pre></td></tr></table></figure>

<p>执行完命令后,数据将进行replay。replay 结束后,节点将正常进行同步。</p>
<p>后期启动节点时,只需要执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeos --data-dir /blockData/blocks --config-dir /blockData </span><br></pre></td></tr></table></figure>

<h1 id="EOS-使用快照快速启动"><a href="#EOS-使用快照快速启动" class="headerlink" title="EOS 使用快照快速启动"></a>EOS 使用快照快速启动</h1><h2 id="1-下载快照文件"><a href="#1-下载快照文件" class="headerlink" title="1. 下载快照文件:"></a>1. 下载快照文件:</h2><p><a href="https://eosnode.tools/snapshots">快照备份地址</a></p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><p>.<br>├── config.ini<br>├── node-data<br>│   ├── blocks<br>│   ├── snapshots<br>│   └── state<br>└── snapshot.sh</p>
<ul>
<li>注意:使用快照备份的方式启动时,需要删除 blocks&#x2F;state 这两个文件夹</li>
</ul>
<h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件:"></a>2. 配置文件:</h2><p><code>vim config.ini</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">agent-name = EOSNODEOS</span><br><span class="line"></span><br><span class="line">chain-state-db-size-mb = 10240</span><br><span class="line">reversible-blocks-db-size-mb = 1024</span><br><span class="line"></span><br><span class="line">http-server-address = 0.0.0.0:8870</span><br><span class="line"></span><br><span class="line">http-validate-host = false</span><br><span class="line">verbose-http-errors = true</span><br><span class="line">abi-serializer-max-time-ms = 2000</span><br><span class="line"></span><br><span class="line">access-control-allow-origin = *</span><br><span class="line">allowed-connection = any</span><br><span class="line"></span><br><span class="line">max-clients = 2</span><br><span class="line">sync-fetch-span = 3000</span><br><span class="line">connection-cleanup-period = 30</span><br><span class="line">enable-stale-production = false</span><br><span class="line"></span><br><span class="line">plugin = eosio::chain_api_plugin</span><br><span class="line">plugin = eosio::chain_plugin</span><br><span class="line"></span><br><span class="line">p2p-peer-address = bp.cryptolions.io:9876</span><br><span class="line">p2p-peer-address = p2p.mainnet.eosgermany.online:9876</span><br><span class="line">p2p-peer-address = mainnet.eospay.host:19876</span><br><span class="line">p2p-peer-address = 94.130.250.22:9806</span><br><span class="line">p2p-peer-address = peer.main.alohaeos.com:9876</span><br><span class="line">p2p-peer-address = peer.eosn.io:9876</span><br><span class="line">p2p-peer-address = p.jeda.one:3322</span><br><span class="line">p2p-peer-address = peering.eosio.cr:1976</span><br><span class="line">p2p-peer-address = eos.nodepacific.com:9876</span><br><span class="line">p2p-peer-address = eu1.eosdac.io:49876</span><br><span class="line">p2p-peer-address = pub1.eostheworld.io:9876</span><br><span class="line">p2p-peer-address = 807534da.eosnodeone.io:19872</span><br><span class="line">p2p-peer-address = mainnet.eoseco.com:10010 </span><br></pre></td></tr></table></figure>

<h2 id="3-初次启动脚本"><a href="#3-初次启动脚本" class="headerlink" title="3. 初次启动脚本:"></a>3. 初次启动脚本:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeos --config-dir ./ --data-dir ./node-data --snapshot ./node-data/snapshots/snapshot-023e5e8813f687c6c5ffcf6eae853eb24f78d90b475dac4fb94face8c8308e4f.bin</span><br></pre></td></tr></table></figure>

<h2 id="4-再次启动"><a href="#4-再次启动" class="headerlink" title="4. 再次启动:"></a>4. 再次启动:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeos --config-dir ./ --data-dir ./node-data</span><br></pre></td></tr></table></figure>

<h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证:"></a>5. 验证:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const FIBOS = require(&quot;fibos.js&quot;);</span><br><span class="line">const fibos = FIBOS(&#123;</span><br><span class="line">    chainId: &quot;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&quot;,</span><br><span class="line">    httpEndpoint: &quot;http://127.0.0.1:8871&quot;,</span><br><span class="line">    keyProvider: &quot;&quot;,</span><br><span class="line">    logger: &#123;</span><br><span class="line">        log: null,</span><br><span class="line">        error: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let r =  fibos.getBlockSync(&quot;最新快高度&quot;);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure>

<ul>
<li>需要依赖于 <a href="https://dev.fo/zh-cn/api/fibosjs/index.html#getBlock">fibos.js</a></li>
</ul>
<h2 id="6-生成快照"><a href="#6-生成快照" class="headerlink" title="6.生成快照"></a>6.生成快照</h2><h3 id="1-添加插件"><a href="#1-添加插件" class="headerlink" title="1. 添加插件"></a>1. 添加插件</h3><p>在 config.ini 中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugin = eosio::producer_api﻿_plugin</span><br></pre></td></tr></table></figure>

<ul>
<li>注意: 开启该插件后,请确保你的节点放置在内网无法被其他地方访问到。</li>
</ul>
<h3 id="2-设置备份目录"><a href="#2-设置备份目录" class="headerlink" title="2. 设置备份目录"></a>2. 设置备份目录</h3><p>启动时添加参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--snapshots﻿﻿-dir ../snapshots-backups</span><br></pre></td></tr></table></figure>

<h3 id="3-创建快照"><a href="#3-创建快照" class="headerlink" title="3. 创建快照"></a>3. 创建快照</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://curl http://127.0.0.1:8870/v1/producer/create_sn﻿apshot</span><br></pre></td></tr></table></figure>
<p>按照目前EOS的大小,这一步大约需要耗时 10~15 分钟。快照创建结束后,在 <code>snapshots-backups</code> 目录下,便生成相应的快照文件。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结:"></a>7. 总结:</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>使用快照方式能够快速启动节点同时保证和主网同步。</li>
<li>使用快照的方式能够节省磁盘空间。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>使用快照启动的节点,快照高度之前的区块数据无法获取。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>EOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自旋锁</title>
    <url>/2020/03/19/21-Java-%E8%87%AA%E6%97%8B%E9%94%81/</url>
    <content><![CDATA[<p>最近看视频刚好看到关于 Java 自旋锁相关内容，结合实例代码做一个记录</p>
<span id="more"></span>

<blockquote>
<p>本文参考地址：<a href="https://segmentfault.com/a/1190000015795906">面试必备之深入理解自旋锁</a></p>
</blockquote>
<h2 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h2><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<h2 id="如何实现自旋锁"><a href="#如何实现自旋锁" class="headerlink" title="如何实现自旋锁"></a>如何实现自旋锁</h2><h3 id="简单例子-🌰"><a href="#简单例子-🌰" class="headerlink" title="简单例子 🌰"></a>简单例子 🌰</h3><p>下面代码是一个简单的自旋锁例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// 等待获取线程锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题：<br>1、某个线程持有锁时间过长时，会导致其他线程一直处于等到状态，导致徒增 CPU 消耗<br>2、存在不公平情况，即等待时间长的线程不一定能优先获得锁</p>
<h3 id="可重入锁🔐-和-不可重入锁🔐"><a href="#可重入锁🔐-和-不可重入锁🔐" class="headerlink" title="可重入锁🔐 和 不可重入锁🔐"></a>可重入锁🔐 和 不可重入锁🔐</h3><p>上述代码存在的问题：当线程 A 持有锁时，在线程 A 释放锁之前不可再次获得锁。而可重入锁需要保证线程 A 再次获取锁时，也有机会获得锁对象。</p>
<p>优化代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cas</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == cas.get()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cas.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 等待获取线程锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == cas.get() &amp;&amp; count &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//当前线程重入数量为0，释放锁资源</span></span><br><span class="line">            cas.compareAndSet(currentThread, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了一个线程「锁」计数器，当 A 线程的重入数量为0时，释放当前锁资源。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>Io流</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 的两种引擎</title>
    <url>/2020/03/23/22-Mysql-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote>
<p>mysql 的数据存储主要存在两种引擎，即：MyISAM 和 InnoDb,我们常用的为 InnoDb,那么两种存在哪些差异和优缺点呢？</p>
</blockquote>
<span id="more"></span>

<h2 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h2><p>1、不支持事务，每次查询操作都是原子级别的</p>
<p>2、支持表级锁，即每次操作都是对整个表进行加锁操作</p>
<p>3、存储表的总行数</p>
<p>4、一张表包含三个文件:索引文件、表结构文件、表数据文件</p>
<p>5、索引文件的数据域存储指向数据文件的指针</p>
<h3 id="InnoDb-存储引擎"><a href="#InnoDb-存储引擎" class="headerlink" title="InnoDb 存储引擎"></a>InnoDb 存储引擎</h3><p>1、支持ACID的事务，支持食物的四种隔离级别</p>
<ul>
<li>Read uncommitted 读未提交：即一个事务可以读取另一个未提交事务的数据</li>
<li>Read committed 读提交：即一个事务要等另一个事务提交后才能读取数据</li>
<li>Repeatable read 重复度：即事务开启时，不再允许修改操作(但允许插入操作)</li>
<li>Serializable 序列化：最高级别的事务隔离，事务串行操作，但是效率底下</li>
</ul>
<p>2、支持行级锁以及外键约束，支持写并发</p>
<p>3、不存储表的总行数</p>
<p>4、一个InnoDb引擎存储在一个文件空间</p>
<p>5、主键索引采用聚集索引，</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql 生产环境用到的技术</title>
    <url>/2020/03/28/23-Mysql-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>现在是 03-28 早上四点，刚刚结束了一波线上环境的数据库迁移，趁着热乎，把用到的技术做一个总结</p>
<span id="more"></span>

<h2 id="设置-Mysql-数据目录"><a href="#设置-Mysql-数据目录" class="headerlink" title="设置 Mysql 数据目录"></a>设置 Mysql 数据目录</h2><p>前言：<br>由于之前服务都是采用 AWS 的 RDS 服务，RDS 好是好，但是服务的成本过于的高，大概 1c1g 的机器一个月需要 500~1000 人民币，公司为了削减成本所以将 RDS 数据迁移到本地服务器。但是由于存储的数据有30多G，机器的 <code>/root</code> 目录不足以存储这么大的数据，所以需要进行 mysql 的 data 数据目录更改。</p>
<p>条件：<br>服务器：ubuntu 16.04<br>mysql：5.7.1</p>
<p>迁移步骤：<br>1、查看 data 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">select @@datadir;</span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+-----------------+</span><br><span class="line">| @@datadir       |</span><br><span class="line">+-----------------+</span><br><span class="line">| /var/lib/mysql/ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>2、迁移现有数据</p>
<p>停掉当前 mysql 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>

<p>复制 mysql data 数据(实例中，将数据复制到 &#x2F;root&#x2F;.mysql 目录下)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av /var/lib/mysql /root/.mysql</span><br></pre></td></tr></table></figure>

<p>备份原有数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /var/lib/mysql /var/lib/mysql.bak</span><br></pre></td></tr></table></figure>

<p>3、修改 mysql 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<p>将 <code>datadir</code> 修改为目标地址 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">datadir=/root/.mysql/mysql</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>4、修改别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apparmor.d/tunables/alias</span><br></pre></td></tr></table></figure>

<p>修改为如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias /var/lib/mysql/ -&gt; /root/.mysql/mysql/,</span><br></pre></td></tr></table></figure>

<p>重启服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart apparmor</span><br></pre></td></tr></table></figure>

<p>5、重置 data 目录&amp;重启服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/lib/mysql/mysql -p</span><br><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<p>至上，我们就完成了 mysql data 数据的目录迁移，再也不会因为 <code>/root</code> 磁盘空间而担心了。</p>
<h2 id="设置-Mysql-主从"><a href="#设置-Mysql-主从" class="headerlink" title="设置 Mysql 主从"></a>设置 Mysql 主从</h2><p>前言：<br>为了方便演示，咱们这里采用 docker 为 mysql 环境</p>
<p>1、安装 mysql </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker run --name master-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:latest //主mysql</span><br><span class="line">docker run --name slave-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3308:3306 -d mysql:latest //从mysql</span><br></pre></td></tr></table></figure>

<p>为了方便本机演示，我们使用 3307 端口表示主服务器，3308 端口表示从服务器</p>
<p>2、设置主服务器</p>
<blockquote>
<p>由于 docker 里没有vim，所以需要安装 vim <code>apt update;apt install vim -y</code></p>
</blockquote>
<p>2、1 设置服务 id 和开启日志<br>进入 docker 容器内 <code>docker exec -it xxx /bin/bash</code></p>
<p>vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=100  # server 的id</span><br><span class="line">log-bin=mysql-bin # log 文件名</span><br></pre></td></tr></table></figure>

<p>修改完成后重启 mysql 服务，docker 容器可以直接重启容器服务即可 <code>docker restart master-mysql</code></p>
<p>2、2 配置同步账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>上述命令中，新建了一个 slave 账号，同时允许所有ip访问</p>
<p>2、设置从服务器</p>
<p>2、1 设置从服务器配置</p>
<p>vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=101  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=mysql-slave-bin   </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin </span><br></pre></td></tr></table></figure>

<p>上述配置中还可以设置需要同步的数据库、表，或忽略的数据库、表。</p>
<p>2、2 设置从数据账号</p>
<p>master-mysql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>

<p>返回值中有 <code>Position</code> 需要将该值记下</p>
<p>获取 master 的ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master-mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">172.17.0.2</span></span><br></pre></td></tr></table></figure>

<p>slave-mysql：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;123456&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos= <span class="string">&quot;此处填写在 master 中的 Position 值&quot;</span>, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>

<p>2、3 开启同步&amp;查看同步状态</p>
<p>开启同步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">start slave;</span></span><br></pre></td></tr></table></figure>

<p>查看同步状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">show slave status \G;</span></span><br></pre></td></tr></table></figure>

<p>主要看：<code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code>，当出现问题时，可看 <code>Slave_SQL_Running_State</code> 具体错误解决</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">slave stop;</span></span><br></pre></td></tr></table></figure>

<p>参考地址：<br><a href="https://www.cnblogs.com/songwenjie/p/9371422.html">基于Docker的Mysql主从复制搭建</a><br><a href="https://www.jianshu.com/p/bfca0cdfb169">mysql设置主从同步</a></p>
<p>可能遇到问题：<br><a href="https://www.cnblogs.com/huligong1234/p/7998514.html">MySQL主从同步异常问题解决Client requested master to start replication from position &gt; file size</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/31/24-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>常用开发设计模式：单例模式、工厂模式、观察者模式、装饰者模式，列举</p>
<span id="more"></span>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类只有一个实例，提供一个全局访问的点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonClass singletonClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass  <span class="title function_">newInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonClass==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonClass.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonClass==<span class="literal">null</span>)&#123;</span><br><span class="line">                    singletonClass = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>不会对客户端暴露创建对象的逻辑，并且通过同一个接口来指定新创建的对象</p>
<p>图解:</p>
<p><img src="https://github.com/aalansehaiyang/technology-talk/raw/master/basic-knowledge/img/10.jpg"></p>
<p>1、创建一个公共接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 定义具体的对象</p>
<p>画圆形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Circle <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画矩形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建工厂，生成基于给定信息的实体类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、调用具体的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式-发布订阅模式"><a href="#观察者模式-发布订阅模式" class="headerlink" title="观察者模式(发布订阅模式)"></a>观察者模式(发布订阅模式)</h2><p>观察者模式又名发布订阅模式，通俗点可以理解为如下图：</p>
<p><img src="http://static.simoncode.top/15856472742874.jpg"></p>
<p>实例代码：</p>
<p><strong>抽象观察者(用户)</strong></p>
<p>&#x2F;&#x2F;定义一个更新方法，即发布文章之后的通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体观察者(关注公众号用户)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被观察者(公众号)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的别观察者(公众号具体方法)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户1&quot;</span>);</span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户2&quot;</span>);</span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;用户3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;文章更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态的给对象添加一些额外的属性或行为。</p>
<p>举例子：<br>存在一个蛋糕，我们需要计算蛋糕装饰上蜡烛和水果之后的价格</p>
<p>1、定义组件类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;Sweet&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义被装饰者「蛋糕」类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cake</span> <span class="keyword">extends</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一个蛋糕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定义装饰器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Sweet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、定义装饰者水果和蜡烛类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//水果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    Sweet sweet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FruitDecorator</span><span class="params">(Sweet sweet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sweet = sweet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.getDescription() + <span class="string">&quot;，水果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.cost() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//蜡烛</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CandleDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    Sweet sweet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CandleDecorator</span><span class="params">(Sweet sweet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sweet = sweet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.getDescription() + <span class="string">&quot;，蜡烛&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sweet.cost() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Cake</span> <span class="variable">cake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cake</span>();</span><br><span class="line">    System.out.println(cake.getDescription() + <span class="string">&quot;总共花费&quot;</span> + cake.cost());</span><br><span class="line"></span><br><span class="line">    <span class="type">FruitDecorator</span> <span class="variable">fruitDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDecorator</span>(cake);</span><br><span class="line">    System.out.println(fruitDecorator.getDescription() + <span class="string">&quot;总共花费&quot;</span> + fruitDecorator.cost());</span><br><span class="line"></span><br><span class="line">    <span class="type">CandleDecorator</span> <span class="variable">candleDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CandleDecorator</span>(fruitDecorator);</span><br><span class="line">    System.out.println(candleDecorator.getDescription() + <span class="string">&quot;总共花费&quot;</span> + candleDecorator.cost());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个蛋糕，总共花费66.0</span><br><span class="line">一个蛋糕，水果，总共花费76.0</span><br><span class="line">一个蛋糕，水果，一根蜡烛，总共花费86.0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 GitHub 的 Actions 实现项目的 CI/CD</title>
    <url>/2020/06/21/25-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-GitHub-%E7%9A%84-Actions-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84-CI-CD/</url>
    <content><![CDATA[<h1 id="如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD"><a href="#如何使用-GitHub-的-Actions-实现项目的-CI-x2F-CD" class="headerlink" title="如何使用 GitHub 的 Actions 实现项目的 CI&#x2F;CD"></a>如何使用 GitHub 的 Actions 实现项目的 CI&#x2F;CD</h1><p>GitHub 的 actions，提供了一整套的任务流，能够帮助我们实现项目的自动自动测试和自动部署。本篇主要是将我使用 github 的 actions 实现项目的自动部署，其中项目主要是 java + vue</p>
<span id="more"></span>

<h2 id="Java-项目部署"><a href="#Java-项目部署" class="headerlink" title="Java 项目部署"></a>Java 项目部署</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>1、jdk<br>2、maven<br>3、ssh</p>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="1-创建项目-省略"><a href="#1-创建项目-省略" class="headerlink" title="1 创建项目(省略)"></a>1 创建项目(省略)</h4><h4 id="2-添加-workflow-文件"><a href="#2-添加-workflow-文件" class="headerlink" title="2 添加 workflow 文件"></a>2 添加 workflow 文件</h4><p>在项目的根目录下，创建 .github&#x2F;workflows 文件夹<br>新建 build.yml 文件</p>
<h4 id="3、编写服务流程"><a href="#3、编写服务流程" class="headerlink" title="3、编写服务流程"></a>3、编写服务流程</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This workflow will build a Java project with Maven</span></span><br><span class="line"><span class="comment"># For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">Ci</span> <span class="comment"># 流名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ] <span class="comment"># 目标分支</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span>  <span class="comment"># JDK 环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">1.8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">Maven</span> <span class="string">packages</span> <span class="comment"># maven 缓存</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">~/.m2</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-m2-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/pom.xml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-m2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Maven</span> <span class="string">Build</span> <span class="comment"># build 打包</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">package</span>   <span class="string">-DskipTests</span> <span class="string">--file</span> <span class="string">pom.xml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">server</span> <span class="comment"># 发布到服务器上</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.1.2</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&quot;-avz --delete&quot;</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">target/wkserver-0.0.1-SNAPSHOT.jar</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">/home/yiliaofeiwu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">server</span>  <span class="comment"># 执行部署后的命令</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">nohup</span> <span class="string">sh</span> <span class="string">/home/yiliaofeiwu/reload.sh</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>REMOTE_HOST</code>、<code>REMOTE_USER</code>、<code>SSH_PRIVATE_KEY</code> 为服务器相关配置，使用 github 的secrets 配置。[项目]-&gt;[setting]-&gt;[secrets] 进行配置</p>
<h2 id="Vue-项目部署"><a href="#Vue-项目部署" class="headerlink" title="Vue 项目部署"></a>Vue 项目部署</h2><h3 id="环境依赖-1"><a href="#环境依赖-1" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>1、nodejs<br>2、ssh</p>
<h3 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="1-创建项目-省略-1"><a href="#1-创建项目-省略-1" class="headerlink" title="1 创建项目(省略)"></a>1 创建项目(省略)</h4><h4 id="2-添加-workflow-文件-1"><a href="#2-添加-workflow-文件-1" class="headerlink" title="2 添加 workflow 文件"></a>2 添加 workflow 文件</h4><p>在项目的根目录下，创建 .github&#x2F;workflows 文件夹<br>新建 build.yml 文件</p>
<h4 id="3、编写服务流程-1"><a href="#3、编写服务流程-1" class="headerlink" title="3、编写服务流程"></a>3、编写服务流程</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span> <span class="string">web</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span> </span><br><span class="line">  <span class="attr">build:</span> </span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">Node.js</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">10</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 部署到腾讯云服务器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.0.7</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">            <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">ARGS:</span> <span class="string">&quot;-avz --delete&quot;</span></span><br><span class="line">            <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEV_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">SOURCE:</span> <span class="string">dist/</span></span><br><span class="line">            <span class="attr">TARGET:</span> <span class="string">/home/wuyuan</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>2021总结</title>
    <url>/2022/02/07/26-2021%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p> 今天是 2022 年的第一个工作日，趁着上班的时间，总结一下过去的一年。</p>
 <span id="more"></span>

<p> 2021 年总体来说是比较顺利的一年，这年间我也完成了人生中的一件大事-买房，也算是给kiko和自己在南京有了个交代。其实就我个人来说对于买房的欲望没有那么强烈，我觉得在武汉买房可能是一个更好的选择，但是生活就是妥协的艺术，既然选择了后面在南京发展，在南京买房也不是一个坏事。能够在南京买房也只能说是机缘凑巧，三月份的时候朋友推荐了一个数字货币，东拼西凑买了5k试试，没想到人生第一次中这么大的运气，后面这个数字货币涨了很多倍，这部分赚的钱也作为了买房的启动资金。</p>
<p> <img src="https://static.simoncode.top/static/20220207/IMG_1681.jpg"></p>
<p> 年中的时候，疫情好像还没有那么严重，感觉那时候只要想出去旅游就都可以去，所以和kiko约着五一乘着回家的功夫去一趟长沙，其实说起长沙我也是一直都想去的，大学的时候就想着去一趟，但时候那时候经济条件有限没去成。这次的长沙之旅也是比较圆满的，大部分有名的景点都去过了，也拍了不少照片，当然茶颜悦色也是每天一杯（甚至两倍），唯一比较遗憾的可能就会没怎么吃到湘菜(五一的人实在是太多了)。</p>
<p> <img src="https://static.simoncode.top/static/20220207/IMG_1107.jpg"><br> <img src="https://static.simoncode.top/static/20220207/IMG_1017.jpg"></p>
<p> 2021年的后半段就比较中规中矩了，安安静静的上班，当然这中间也接了两个私活，总体感觉也不错，都是我之前未曾涉及的领域，挣钱的同时也学习了很多新的知识。</p>
<p>总的来说，这一年还是好的事情比坏的事情要多，和kiko的关系还是感觉和热恋一样，芙芙也是越吃越肥(当然我也是)。</p>
<p><img src="https://static.simoncode.top/static/20220207/IMG_0455.jpg"><br><img src="https://static.simoncode.top/static/20220207/IMG_2428.jpg"></p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发一个自己的 RPC 框架 (一)</title>
    <url>/2023/12/11/27-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="如何开发一个自己的-RPC-框架-一"><a href="#如何开发一个自己的-RPC-框架-一" class="headerlink" title="如何开发一个自己的 RPC 框架 (一)"></a>如何开发一个自己的 RPC 框架 (一)</h1><p>写在前面：本文参考了开源项目 <a href="https://github.com/MIracleCczs/simple-rpc%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%A4%A7%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E4%BA%86%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BA%E5%8F%91%EF%BC%8C%E8%AE%B2%E8%AE%B2%E4%B8%80%E4%B8%AA">https://github.com/MIracleCczs/simple-rpc，其中大部分代码参考了该项目，本章主要从客户端的调用出发，讲讲一个</a> RPC 框架的实现在客户端测需要实现那些功能</p>
<span id="more"></span>

<h2 id="RPC-的定义"><a href="#RPC-的定义" class="headerlink" title="RPC 的定义"></a>RPC 的定义</h2><p>可以参考 wiki: <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">https://zh.wikipedia.org/wiki/遠程過程調用</a></p>
<h2 id="一个简单的-RPC-框架是如何组成的"><a href="#一个简单的-RPC-框架是如何组成的" class="headerlink" title="一个简单的 RPC 框架是如何组成的?"></a>一个简单的 RPC 框架是如何组成的?</h2><p>一个基础的 RPC 框架，需要包含三大部分：1. 注册中心 2.服务提供方 3.服务消费方</p>
<pre class="mermaid">graph LR
注册中心 --> 服务提供方
注册中心 --> 服务消费方</pre>

<p>从上图可以看出，服务提供方和消费方都需要和注册中心通信</p>
<h2 id="一个远程方法的调用是如何实现的？"><a href="#一个远程方法的调用是如何实现的？" class="headerlink" title="一个远程方法的调用是如何实现的？"></a>一个远程方法的调用是如何实现的？</h2><pre class="mermaid">stateDiagram-v2
    [*] --> 客户端发起服务调用
    客户端发起服务调用 --> 根据类名+方法名查询服务节点(Producer)
    根据类名+方法名查询服务节点(Producer) --> 根据节点获取本地Netty连接(channel)
    根据节点获取本地Netty连接(channel) --> 向服务方发送调用请求(NettyRequest)
    向服务方发送调用请求(NettyRequest) --> 服务方接收请求根据类名进行反射调用
    服务方接收请求根据类名进行反射调用 --> 根据方法返回值构造返回结果(NettyResponse)
    根据方法返回值构造返回结果(NettyResponse) --> 客户端获取返回结果(调用结束)
    客户端获取返回结果(调用结束) --> [*]</pre>

<p>下面，我们将根据上面流程图，一步步进行讲解。为了方便更加清楚的讲清整个逻辑，我们从实际的业务需求出发。</p>
<p><strong>需求：</strong></p>
<p>存在服务提供方 Producer(后面统称服务端)，提供方法 <code>get</code>   </p>
<p>存在服务消费方 Consumer(后面统称客户端),需要调用 Producer 中的 <code>get</code> 方法</p>
<pre class="mermaid">sequenceDiagram
    客户端 ->>服务端: get 方法调用
    服务端 ->>客户端: 返回 get 方法执行结果</pre>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p><code>pom.xml</code> 依赖</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--spring--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.2</span><span class="number">.9</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- zookeeper --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.7</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- zkclient --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">0.11</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.18</span><span class="number">.18</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--guava--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">24.1</span><span class="number">.1</span>-jre&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- common --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.2</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>zookeeper</code> 安装 <code>Docker</code> 安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -d -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -p <span class="number">2181</span>:<span class="number">2181</span> -v $PWD/data:/data --name zookeeper  zookeeper</span><br></pre></td></tr></table></figure>

<h2 id="基础接口定义"><a href="#基础接口定义" class="headerlink" title="基础接口定义"></a>基础接口定义</h2><p>定义 <code>UserService</code> 接口，接口内包含 <code>get</code>  方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    String <span class="title function_">get</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端发起服务调用"><a href="#客户端发起服务调用" class="headerlink" title="客户端发起服务调用"></a>客户端发起服务调用</h2><h3 id="客户端注解定义"><a href="#客户端注解定义" class="headerlink" title="客户端注解定义"></a>客户端注解定义</h3><p>客户端如何才能够像调用本地方法一样调用远程服务呢？RPC 框架就是用来解决这个问题。我们一般本地方法的调用都是采用 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>

<p>通过 <code>Spring</code> 依赖注入的方式，将需要用到的方法注入到调用对象中，那么我们 RPC 调用能不能也采用这种形式呢？答案当然是可以的。那么为了实现上面的需求，我们最简单的办法就是自定义一个注解 <code>RpcClient</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcClient &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解定义完成后，我们就应该考虑注解中需要设置那些属性呢？</p>
<p>那么冒出来的第一个问题就是：客户端如何知道是调用的那个远程服务呢？这时我们就需要设置第一个属性 <code>remoteAppKey</code> 服务的唯一标识，通过 <code>remoteAppKey</code> 客户端可以轻松地在注册中心找到目标服务。</p>
<p>这个时候又会有第二个疑问，如果一个服务多个版本如何处理呢？比如进行灰度升级等操作的时，那么这个时候就需要第二个参数 <code>groupName</code> 找到具体服务下的具体分组</p>
<p>剩余的参数就比较简单了，完成的参数配置如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务接口:匹配从注册中心获取到本地的服务提供者，得到服务提供者列表，再根据负载均衡策略选取一个发起服务调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Class&lt;?&gt; targetItf() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 超时时间：服务调用超时时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">long</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3000</span> * <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 调用者线程数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">consumeThreads</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务提供者唯一标识</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> String <span class="title function_">remoteAppKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务分组组名</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> String <span class="title function_">groupName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h3><p>为了实现类似 <code>@Autowired</code> 的功能，框架需要在 <code>Bean</code> 初始化之时，将所有被 <code>RpcClient</code> 注解的对象进行依赖注入，那么如何实现这个功能呢？ <code>Spring</code> 的 <strong><code>InstantiationAwareBeanPostProcessor</code></strong> 接口，可以在 Bean 的实例化的各个阶段执行自定义逻辑。定义一个 <code>ConsumerAnnotaionBean</code> 方法，实现 <code>InstantiationAwareBeanPostProcessor</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAnnotaionBean</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line">		...其他方法省略</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要实现接口的 <code>postProcessProperties</code> 方法，设置 Bean 对象的属性值</p>
<p>进行具体代码编写之前，我们需要先理清楚这里需要实现那些目的：</p>
<ol>
<li>客户端服务注册(监控目的)</li>
<li>对象依赖的注入</li>
<li>查询服务节点，预创建 Netty 连接</li>
</ol>
<p>好了，理清楚完需求之后，我们便开始对应的逻辑编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">        <span class="comment">// 依赖注入的服务</span></span><br><span class="line">        Field[] fields = beanClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="type">RpcClient</span> <span class="variable">rpcClient</span> <span class="operator">=</span> field.getAnnotation(RpcClient.class);</span><br><span class="line">            <span class="keyword">if</span> (rpcClient == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 根据初始化的 <code>bean</code> 获取对象中的所有参数，然后使用 <code>getAnnotation(RpcClient.class);</code> 判断参数是否被 <code>RpcClient</code> 所注解</p>
<h3 id="客户端服务注册"><a href="#客户端服务注册" class="headerlink" title="客户端服务注册"></a>客户端服务注册</h3><p>这一步的目的是为了在注册中心中记录消费者信息，方便后续监控，所以这一步相对来说非常简单，只需要构造客户端信息然后提交到注册中心即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造消费者对象</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> Consumer</span><br><span class="line">                    .builder()</span><br><span class="line">                    .groupName(rpcClient.groupName())</span><br><span class="line">                    .remoteAppKey(rpcClient.remoteAppKey())</span><br><span class="line">                    .targetItf(targetItf)</span><br><span class="line">                    .build();</span><br><span class="line"><span class="comment">// 注册中心注册消费者</span></span><br><span class="line">registerCenter.registerConsumer(consumer);</span><br></pre></td></tr></table></figure>

<h3 id="对象依赖的注入"><a href="#对象依赖的注入" class="headerlink" title="对象依赖的注入"></a>对象依赖的注入</h3><p>同样的，我们先梳理一下这里的需求。我们需要实现一个动态代理，在方法调用时，根据方法调用名+类名获取远程服务提供方的节点信息，然后构造一个 <code>NettyRequest</code> 信息，发送到服务方，最后需要接收服务放返回的 <code>NettyResponse</code> 解析成方法的返回值进行返回</p>
<pre class="mermaid">stateDiagram-v2
    [*] --> 根据类名+方法名获取节点_涉及节点负载均衡
    根据类名+方法名获取节点_涉及节点负载均衡 --> 根据节点Ip和端口获取Netty的Channel
    根据节点Ip和端口获取Netty的Channel --> 发送NettyRequest请求携带方法参数
    发送NettyRequest请求携带方法参数 --> 获取服务端详情结果(NettyResponse)
    获取服务端详情结果(NettyResponse) --> 反序列化成方法的出参
    反序列化成方法的出参 --> 方法反射/远程调用完成
    方法反射/远程调用完成 --> [*]</pre>

<p>好了，我们已经理清楚了上面整体流程，那么就开始具体的代码编写吧</p>
<p>首先，定义一个对象 <code>ClientProxyBeanFactory</code> 实现 <code>InvocationHandler</code> 接口</p>
<p>主要是实现接口的 <code>invoke</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke</code> 方法中，需要根据类名+方法名从注册中心中获取可用的节点，那么具体代理的类这个时候就需要从对象实例化中传入，所以我们在定义 <code>ClientProxyBeanFactory</code> 时，需要定义几个成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientProxyBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用连接池(Netty 请求)</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标代理类</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetItf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> consumeThreads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象初始化的时候，需要设置成员变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ClientProxyBeanFactory instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientProxyBeanFactory</span><span class="params">(Class&lt;?&gt; targetItf, <span class="type">long</span> timeout, <span class="type">int</span> consumeThreads)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(consumeThreads, consumeThreads,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;simple-rpc-%d&quot;</span>).build(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.targetItf = targetItf;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.consumeThreads = consumeThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;targetItf&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientProxyBeanFactory <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; targetItf, <span class="type">long</span> timeout, <span class="type">int</span> consumeThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ClientProxyBeanFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">ClientProxyBeanFactory</span>(targetItf, timeout, consumeThreads);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完成上述成员变量赋值后，便可以开始从注册中心中获取服务节点了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsumerAnnotaionBean.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">				<span class="comment">// 代理 className</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> targetItf.getName();</span><br><span class="line">				<span class="comment">// 注册中心服务</span></span><br><span class="line">        <span class="type">IRegisterCenter</span> <span class="variable">registerCenter</span> <span class="operator">=</span> IRegisterCenterZkImpl.getInstance();</span><br><span class="line">				<span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">        List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">				...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到服务节点后，这里可以根据设置的负载均衡策略获取本次使用的节点信息，假设这里采用随机获取的方法获取得到节点 <code>Producer</code></p>
<p><strong>开启 Netty 连接，进行消息收发送</strong></p>
<p>拿到了 <code>Producer</code> 就意味着我们可以获取到远程服务 Netty 的 ip + port 信息了，这个时候就可以建立远程服务连接了。但是这里存在一个优化逻辑，就是如果我们每次都是方法调用时再去建立链接，那么建立连接将会是一个非常耗时的操作，但是如果我们提前根据 ip + port 建立一个 <code>Channel</code> 池，方法调用时只需要从连接池中获取 <code>Channel</code> ，那么服务的效率是不是会大大提高了？</p>
<pre class="mermaid">flowchart TD
    A[(Ip+port获取本地缓存Channel)] --> B{是否存在 Channel?}
    B -->|存在缓存信息| C[队列获取 Channel]
    B ---->|不存在缓存信息| D[建立连接缓存到本地]
    D --> B
    C --> E[消息发送结束后将 Channel 返回到队列]</pre>

<p>基于上面的逻辑，我们需要实现一个 <code>NettyChannelPoolFactory</code> 用来缓存客户端的 <code>Netty</code> 的请求缓存，同时对外提供两个方法: <code>acquire</code> 获取 Channel 信息 <code>release</code> 释放 Channel 信息</p>
<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyChannelPoolFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NettyChannelPoolFactory</span> <span class="variable">CHANNEL_POOL_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyChannelPoolFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池缓存 key 为服务提供者地址，value为Netty Channel阻塞队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;InetSocketAddress, ArrayBlockingQueue&lt;Channel&gt;&gt; CHANNEL_POOL_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Netty Channel阻塞队列的长度，该值为可配置信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">CHANNEL_CONNECT_SIZE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyChannelPoolFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNEL_POOL_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 netty 连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannelFactory</span><span class="params">(List&lt;Producer&gt; producerNodeList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Producer producer : producerNodeList) &#123;</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(producer.getIp(), producer.getPort());</span><br><span class="line">            <span class="keyword">while</span> (CHANNEL_POOL_MAP.get(address) == <span class="literal">null</span> || CHANNEL_POOL_MAP.get(address).size() &lt; CHANNEL_CONNECT_SIZE) &#123;</span><br><span class="line">                ArrayBlockingQueue&lt;Channel&gt; channels = CHANNEL_POOL_MAP.get(address);</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="literal">null</span> || channels.size() &lt; CHANNEL_CONNECT_SIZE) &#123;</span><br><span class="line">                    <span class="comment">// 初始化 Netty Channel 阻塞队列</span></span><br><span class="line">                    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                        channel = registerChannel(address);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (channels == <span class="literal">null</span>) &#123;</span><br><span class="line">                        channels = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(CHANNEL_CONNECT_SIZE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">offer</span> <span class="operator">=</span> channels.offer(channel);</span><br><span class="line">                    <span class="keyword">if</span> (!offer) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;channelArrayBlockingQueue fail&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        CHANNEL_POOL_MAP.put(address, channels);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 address 获取客户端队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayBlockingQueue&lt;Channel&gt; <span class="title function_">acquire</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNEL_POOL_MAP.get(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用完成之后，将 channel 放回到 阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(ArrayBlockingQueue&lt;Channel&gt; queue, Channel channel, InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收之前判断channel 是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span> || !channel.isOpen() || !channel.isActive() || !channel.isWritable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">                channel.deregister().syncUninterruptibly().awaitUninterruptibly();</span><br><span class="line">                channel.closeFuture().syncUninterruptibly().awaitUninterruptibly();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                    channel = registerChannel(address);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.offer(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 netty 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">registerChannel</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.remoteAddress(address);</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 注册Netty编码器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>());</span><br><span class="line">                            <span class="comment">// 注册Netty解码器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(NettyResponse.class));</span><br><span class="line">                            <span class="comment">// 注册客户端业务处理逻辑Handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyHandlerClient</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect().sync();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> List&lt;Boolean&gt; isSuccessHolder = Lists.newArrayListWithCapacity(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 监听channel是否建立成功</span></span><br><span class="line">            channelFuture.addListener(future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    isSuccessHolder.add(Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果建立失败，保存建立失败标记</span></span><br><span class="line">                    log.error(<span class="string">&quot;registerChannel fail , &#123;&#125;&quot;</span>, future.cause().getMessage());</span><br><span class="line">                    isSuccessHolder.add(Boolean.FALSE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 如果Channel建立成功，返回新建的Channel</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(isSuccessHolder.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;registerChannel fail&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NettyChannelPoolFactory</code> 对象中还定义了一个方法 <code>registerChannel</code> 接收 <code>InetSocketAddress</code> 的入参，返回值为 <code>Channel</code> 。方法中主要根据传入的 <code>address</code> 信息，创建了 <code>Netty</code> 连接，设置了序列化和反序列化的编解码器，然后增加了一个 <code>NettyHandlerClient</code> 的客户端消息处理器。最后将初始化好的 <code>Channel</code> 连接进行返回</p>
<p>有了上面的 <code>NettyChannelPoolFactory</code> ，便可以将从注册中心获得到的 <code>Producer</code> 信息，根据 ip + port 获取 <code>Channel</code> ，从而进行 <code>NettyRequest</code> 消息的发送</p>
<p><code>**NettyRequest</code> 消息的构造**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">    <span class="comment">// 直接取第0 个，这里可以采用负载均衡策略进行获取</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">providerCopy</span> <span class="operator">=</span>producerList.get(<span class="number">0</span>) ;</span><br><span class="line">		<span class="comment">// NettyRequest 构造</span></span><br><span class="line"><span class="type">NettyRequest</span> <span class="variable">request</span> <span class="operator">=</span> NettyRequest.builder()</span><br><span class="line">								<span class="comment">// 服务节点信息</span></span><br><span class="line">                .producer(providerCopy)</span><br><span class="line">							<span class="comment">// 本次请求的唯一编号</span></span><br><span class="line">                .uniqueKey(UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId())</span><br><span class="line">							<span class="comment">// 请求超时时间</span></span><br><span class="line">                .invokeTimeout(timeout)</span><br><span class="line">							<span class="comment">// 请求方法名称</span></span><br><span class="line">                .invokeMethodName(method.getName())</span><br><span class="line">							<span class="comment">// 请求参数</span></span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在 <code>NettyRequest</code>  和发送消息的 <code>Channel</code> 都已经有了，只需要将消息发送出去，然后接收消息然后序列成方法的出参即可。</p>
<p>这里可以采用线程池的方式，进行 <code>Netty</code> 消息的发送和返回值的解码</p>
<p>定义一个 <code>ClientServiceCallable</code> 集成自 <code>Callable&lt;NettyResponse&gt;</code> 带返回值的任务的接口</p>
<p><code>Callable</code> 只有一个需要实现的方法 <code>call()</code> ,在该方法中，需要完成 1. 获取 <code>Channel</code> 对象 2. 发送请求 3. 结果值返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientServiceCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;NettyResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 通信管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NettyRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientServiceCallable <span class="title function_">of</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientServiceCallable</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientServiceCallable</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> NettyResponse <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(request.getProducer().getIp(), request.getProducer().getPort());</span><br><span class="line">    <span class="comment">// 获取本地缓存 Channel 队列</span></span><br><span class="line">    ArrayBlockingQueue&lt;Channel&gt; blockingQueue = NettyChannelPoolFactory.getInstance().acquire(inetSocketAddress);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从队列中获取 Channel</span></span><br><span class="line">            channel = blockingQueue.take();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can&#x27;t find channel to resolve this request&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;client send request error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 请求结束，队列归还 Channel</span></span><br><span class="line">        NettyChannelPoolFactory.getInstance().release(blockingQueue, channel, inetSocketAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的 <code>call</code> 方法中，首先从本地缓存中获取到了 <code>Channel</code> 队列，然后在 <code>finally</code> 中将 <code>Channel</code> 归还到队列中。那么方法中剩下的逻辑就是发送 <code>NettyRequest</code> 请求，然后返回结果了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                channel = blockingQueue.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can&#x27;t find channel to resolve this request&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="number">1</span>️⃣ ClientResponseHolder.initResponseData(request.getUniqueKey());</span><br><span class="line"></span><br><span class="line">                <span class="number">2</span>️⃣<span class="keyword">while</span> (!channel.isOpen() || !channel.isActive() || !channel.isWritable()) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;retry get new channel&quot;</span>);</span><br><span class="line">                    channel = blockingQueue.poll(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 若队列中没有可用的Channel，则重新注册一个Channel</span></span><br><span class="line">                        channel = NettyChannelPoolFactory.getInstance().registerChannel(inetSocketAddress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将本次调用的信息写入Netty通道，发起异步调用</span></span><br><span class="line">                <span class="number">3</span>️⃣ <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> channel.writeAndFlush(request);</span><br><span class="line">                channelFuture.syncUninterruptibly();</span><br><span class="line">                <span class="comment">// 从返回结果容器中获取返回结果，同时设置等待超时时间为invokeTimeout</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">invokeTimeout</span> <span class="operator">=</span> request.getInvokeTimeout();</span><br><span class="line">                <span class="number">4</span>️⃣ <span class="keyword">return</span> ClientResponseHolder.getValue(request.getUniqueKey(), invokeTimeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client send request error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannelPoolFactory.getInstance().release(blockingQueue, channel, inetSocketAddress);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣ <strong>ClientResponseHolder 类</strong></p>
<p><code>ClientResponseHolder.initResponseData(request.getUniqueKey());</code> 这里又增加了一个新的类<code>ClientResponseHolder</code>,那么这个类是干嘛的呢？</p>
<p>由于消息的发送都是异步的形式，这里使用了 <code>Map&lt;String,NettyResponseWrapper&gt;</code> 进行本地数据缓存, <code>Map</code> 的 KEY 是 <code>NeettyRequest</code> 的 <code>uniqueKey</code> ，而 <code>Value</code> 就是 <code>Netty</code> 的返回结果，即是服务端执行之后的返回值</p>
<p><code>ClientResponseHolder</code> 的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientResponseHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, NettyResponseWrapper&gt; RESPONSE_WRAPPER_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">RemoveExpireThreadFactory</span>(<span class="string">&quot;simple-rpc&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 删除过期的数据</span></span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, NettyResponseWrapper&gt; entry : RESPONSE_WRAPPER_MAP.entrySet()) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">expire</span> <span class="operator">=</span> entry.getValue().isExpire();</span><br><span class="line">                <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">                    RESPONSE_WRAPPER_MAP.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">20</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化返回结果容器，requestUniqueKey唯一标识本次调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initResponseData</span><span class="params">(String requestUniqueKey)</span> &#123;</span><br><span class="line">        RESPONSE_WRAPPER_MAP.put(requestUniqueKey, NettyResponseWrapper.of());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Netty调用异步返回结果放入阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putResultValue</span><span class="params">(NettyResponse response)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">NettyResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> RESPONSE_WRAPPER_MAP.get(response.getUniqueKey());</span><br><span class="line">        responseWrapper.setResponseTime(currentTimeMillis);</span><br><span class="line">        responseWrapper.getResponseBlockingQueue().add(response);</span><br><span class="line">        RESPONSE_WRAPPER_MAP.put(response.getUniqueKey(), responseWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从阻塞队列中获取异步返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyResponse <span class="title function_">getValue</span><span class="params">(String requestUniqueKey, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">NettyResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> RESPONSE_WRAPPER_MAP.get(requestUniqueKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> responseWrapper.getResponseBlockingQueue().poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;get value error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RESPONSE_WRAPPER_MAP.remove(requestUniqueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>initResponseData: 根据 <code>uniqueKey</code> 初始化 <code>Map</code></li>
<li>putResultValue: 插入 <code>NettyResponse</code> 返回结果</li>
<li>getValue: 根据 <code>uniqueKey</code> 获取结果</li>
</ul>
<p>同时定义了一个定时执行的队列，队列中根据 <code>responseTime</code> 判断消息是否过期进行内存数据清洗</p>
<p>2️⃣ Channel 状态判断</p>
<p>判断当前 <code>Netty</code> 通道状态，如果当前 <code>Channel</code> 不可用，则需要重新申请通道</p>
<p>3️⃣ Netty 消息发送</p>
<p>4️⃣ 从本地缓存中获取 Netty 返回结果</p>
<p><strong>异步调用 Netty 服务，使用 <code>Future</code> 获取返回结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">    <span class="comment">// 直接取第0 个，这里可以采用负载均衡策略进行获取</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">providerCopy</span> <span class="operator">=</span>producerList.get(<span class="number">0</span>) ;</span><br><span class="line">		<span class="comment">// NettyRequest 构造</span></span><br><span class="line"><span class="type">NettyRequest</span> <span class="variable">request</span> <span class="operator">=</span> NettyRequest.builder()</span><br><span class="line">								<span class="comment">// 服务节点信息</span></span><br><span class="line">                .producer(providerCopy)</span><br><span class="line">							<span class="comment">// 本次请求的唯一编号</span></span><br><span class="line">                .uniqueKey(UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId())</span><br><span class="line">							<span class="comment">// 请求超时时间</span></span><br><span class="line">                .invokeTimeout(timeout)</span><br><span class="line">							<span class="comment">// 请求方法名称</span></span><br><span class="line">                .invokeMethodName(method.getName())</span><br><span class="line">							<span class="comment">// 请求参数</span></span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 发起异步调用,通过 NettyClient 发送请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;NettyResponse&gt; responseFuture = executorService.submit(ClientServiceCallable.of(request));</span><br><span class="line">            <span class="type">NettyResponse</span> <span class="variable">response</span> <span class="operator">=</span> responseFuture.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.getResult();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;send request error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们就完成了 <code>ClientProxyBeanFactory</code> 代理对象的完整编写，现在就需要将初始化好的代理对象进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsumerAnnotaionBean.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">				<span class="comment">// 代理 className</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> targetItf.getName();</span><br><span class="line">				<span class="comment">// 注册中心服务</span></span><br><span class="line">        <span class="type">IRegisterCenter</span> <span class="variable">registerCenter</span> <span class="operator">=</span> IRegisterCenterZkImpl.getInstance();</span><br><span class="line">				<span class="comment">// 根据 serviceName + methodName 获取可以使用的节点</span></span><br><span class="line">        List&lt;Producer&gt; producerList = registerCenter.getServiceProducer(serviceName, method.getName());</span><br><span class="line">				<span class="comment">// 3.获取服务代理对象</span></span><br><span class="line">            Class&lt;?&gt; targetItf = rpcClient.targetItf();</span><br><span class="line">            <span class="keyword">if</span> (targetItf == Object.class) &#123;</span><br><span class="line">                targetItf = field.getType();</span><br><span class="line">           &#125;</span><br><span class="line">				<span class="comment">// 初始化代理对象</span></span><br><span class="line">				<span class="type">ClientProxyBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> ClientProxyBeanFactory.getInstance(targetItf, rpcClient.timeout(), rpcClient.consumeThreads());</span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置代理对象</span></span><br><span class="line">                field.set(bean, factory.getProxy());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;ReferenceBeanPostProcessor post process properties error, beanName=&#123;&#125;&quot;</span>, beanName, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ReferenceBeanPostProcessor post process properties error, beanName=&quot;</span> + beanName, e);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ClientProxyBeanFactory.getInstance</code> 获取到代理对象后，使用 <code>field.set</code> 方法进行执行赋值</p>
<p>完成上述操作之后，当客户端执行 <code>get</code> 方法时，便会 <code>invoke</code> 到 <code>ClientProxyBeanFactory</code> 的 <code>invoke</code> 方法上，随后执行 <strong>开启 Netty 连接，进行消息收发送</strong> 内容，随后将服务方结果进行返回</p>
<h3 id="查询服务节点，预创建-Netty-连接"><a href="#查询服务节点，预创建-Netty-连接" class="headerlink" title="查询服务节点，预创建 Netty 连接"></a>查询服务节点，预创建 Netty 连接</h3><p>这部分内容和第二步有所重叠，其核心逻辑如下：</p>
<pre class="mermaid">sequenceDiagram
    客户端->>注册中心: 1️⃣查询所有用到的服务
    客户端->>服务提供方: 2️⃣预建立 Netty 请求，建立通道池</pre>

<p>到这里，客户端的所有流程就都编写完成了。但是为了理清楚主要思路，文章中对负载均衡策略、序列化和反序列化等都只是一笔带过。这些也是一个 RPC 框架非常很重要的一部分。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发一个自己的 RPC 框架 (二)</title>
    <url>/2023/12/12/28-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="如何开发一个自己的-RPC-框架-二"><a href="#如何开发一个自己的-RPC-框架-二" class="headerlink" title="如何开发一个自己的 RPC 框架 (二)"></a>如何开发一个自己的 RPC 框架 (二)</h1><p>上篇文章中，从客户端的调用流程，详细的了解了各个环节的数据是如何串联起来的。那么本章内容，将主要从注册中心的角度出发，看看注册中心是如何维护客户端和服务端各自上报的信息。</p>
<span id="more"></span>

<p>能够作为注册中心的中间件非常多，常见的比如 <a href="https://zookeeper.apache.org/">ZooKeeper</a>、<a href="https://www.consul.io/">Consul</a>、<a href="https://nacos.io/en-us/">Nacos</a> 等，本项目中采用的是  Zookeeper 作为注册中心中间件</p>
<h2 id="功能梳理"><a href="#功能梳理" class="headerlink" title="功能梳理"></a>功能梳理</h2><p>同样，开始之前我们先来理一下注册中心主要实现那些功能</p>
<pre class="mermaid">flowchart TD
    注册中心 --> 维护服务提供方节点信息
    注册中心 --> 维护服务消费方节点信息
    注册中心 --> 服务消费方服务信息订阅</pre>

<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>定义一个名为 <code>IRegisterCenter</code> 的接口，其中接口主要实现如下功能：</p>
<ol>
<li>服务提供方的节点上报</li>
<li>服务提供方节点信息更新</li>
<li>服务提供方的本地数据缓存和节点信息订阅</li>
<li>服务消费方根据服务名获取节点地址</li>
<li>服务消费方订阅服务节点信息</li>
<li>服务消费方信息注册</li>
</ol>
<p>有了上面 6 大需求，就可以知道接口接口中主要包含的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IRegisterCenter.class</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRegisterCenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方节点注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(List&lt;Producer&gt; producerList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方获取节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, List&lt;Producer&gt;&gt; <span class="title function_">getProducersMap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供方服务销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方初始化服务节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAppKey 服务提供者唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName    服务组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initProviderMap</span><span class="params">(String remoteAppKey, String groupName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方获取所有节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Producer&gt; <span class="title function_">getServiceNode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费方获取节点信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName  服务方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Producer&gt; <span class="title function_">getServiceProducer</span><span class="params">(String serviceName, String methodName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务消费者信息 用于监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerConsumer</span><span class="params">(Consumer consumer)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h2><p>注册中心的接口定义完成之后，就需要使用 zookeeper 进行接口实现。但是在接口实现之前，需要实现一个帮助方法读取 RPC 框架的相关配置项。</p>
<p>根据前面的设计，可以大概罗列一下需要用到的配置参数</p>
<ol>
<li>appkey: 服务的唯一标识</li>
<li>groupName: 服务的分组名称</li>
<li>zookServer: zk 中间件服务地址</li>
<li>nettyIp: 服务提供方调用地址</li>
<li>nettyPort: 服务提供方调用端口</li>
</ol>
<p>当然还包含一些其他参数，比如服务调用超时时间、服务会话超时时间等</p>
<p>完成上面需求整理之后，就可以开始 <code>RpcPropertiesUtil</code> 方法的编写了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcPropertiesUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROPERTIES_FILE_NAME</span> <span class="operator">=</span> <span class="string">&quot;rpc.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PRODUCER_MAP = Maps.newConcurrentMap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadAllProperties(PROPERTIES_FILE_NAME);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                PRODUCER_MAP.put(entry.getKey().toString(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;读取配置文件异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Producer Load Properties Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先从环境变量读取</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Map&lt;String, Object&gt; map, String key, String defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">envKey</span> <span class="operator">=</span> System.getenv().get(key.toUpperCase());</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> envKey != <span class="literal">null</span> ? envKey : MapUtils.getString(map, key);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.isEmpty(result) ? defaultValue : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Map&lt;String, Object&gt; map, String key, Integer defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">envKey</span> <span class="operator">=</span> System.getenv().get(key.toUpperCase());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> envKey != <span class="literal">null</span> ? Integer.parseInt(envKey) : MapUtils.getInteger(map, key);</span><br><span class="line">        <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span>= <span class="literal">null</span> ? defaultValue : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个 <code>PRODUCER_MAP</code> 用来做配置文件缓存</li>
<li>static 静态方法中，读取 <code>[rpc.properties](http://rpc.properties)</code> 配置文件，转换成 Map</li>
<li>定义了两个 <code>getString</code> 和 <code>getInteger</code> 的方法，表示先从环境变量中读取配置，不存在时从配置文件中读取</li>
</ol>
<p>完成上述基础编写之后，实例一个 <code>rpc_app_key</code> 的读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAppKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getString(PRODUCER_MAP, <span class="string">&quot;rpc_app_key&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="zookeeper-接口实现"><a href="#zookeeper-接口实现" class="headerlink" title="zookeeper 接口实现"></a>zookeeper 接口实现</h2><p>由于接口的方法都已经定义完成，只需要根据接口的方法含义，进行对应的实现即可</p>
<p>定义一个类 <code>IRegisterCenterZkImpl</code> 实现 <code>IRegisterCenter</code> 接口</p>
<h3 id="成员变量介绍"><a href="#成员变量介绍" class="headerlink" title="成员变量介绍"></a>成员变量介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IRegisterCenterZkImpl</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IRegisterCenterZkImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ZkClient</span> <span class="variable">zkClient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK 相关信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ADDRESS</span> <span class="operator">=</span> RpcPropertiesUtil.getZkServers();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ZK_SESSION_TIMEOUT</span> <span class="operator">=</span> RpcPropertiesUtil.getSessionTimeout();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ZK_CONNECTION_TIMEOUT</span> <span class="operator">=</span> RpcPropertiesUtil.getConnectionTimeout();</span><br><span class="line">    <span class="comment">// 本地服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCAL_IP</span> <span class="operator">=</span> RpcPropertiesUtil.getServerIp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务缓存(服务端缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; PROVIDER_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 服务缓存(客户端缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; SERVICE_METADATA = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK 的服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/config_register&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROVIDER_TYPE</span> <span class="operator">=</span> <span class="string">&quot;/provider&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSUMER_TYPE</span> <span class="operator">=</span> <span class="string">&quot;/consumer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name to bean map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_BEAN_MAP = Maps.newConcurrentMap();</span><br></pre></td></tr></table></figure>

<h3 id="register-方法实现"><a href="#register-方法实现" class="headerlink" title="register 方法实现"></a>register 方法实现</h3><p><code>register</code> 应该是整个注册中心最重要的方法了，他主要目的是接收服务提供方的节点信息上报</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(List&lt;Producer&gt; producerList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(producerList)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;RegisterCenterImpl registerProvider providers is empty, ignore it, providers=&#123;&#125;&quot;</span>, producerList);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (IRegisterCenterZkImpl.class) &#123;</span><br><span class="line">            <span class="comment">// 初始化 zk 客户端</span></span><br><span class="line">            <span class="number">1</span>️⃣ <span class="built_in">this</span>.initZkClient();</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 本地缓存</span></span><br><span class="line">            <span class="number">2</span>️⃣ <span class="built_in">this</span>.setLocalCache(producerList);							</span><br><span class="line">            <span class="number">3</span>️⃣ <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Producer&gt;&gt; entry : PROVIDER_MAP.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                List&lt;Producer&gt; producers = entry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                <span class="type">Producer</span> <span class="variable">firstProducer</span> <span class="operator">=</span> producers.get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">appKey</span> <span class="operator">=</span> firstProducer.getAppKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">rootNode</span> <span class="operator">=</span> getRootPath(appKey);</span><br><span class="line">               <span class="number">4</span>️⃣ <span class="built_in">this</span>.createRootNode(rootNode);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务组名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> firstProducer.getGroupName();</span><br><span class="line">                <span class="comment">// 创建服务提供者节点</span></span><br><span class="line">              <span class="number">5</span>️⃣  <span class="type">String</span> <span class="variable">servicePath</span> <span class="operator">=</span> getProducerServicePath(appKey, groupName, serviceName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Producer producer : producers) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.createServiceNode(servicePath);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">producerMathodPath</span> <span class="operator">=</span> producerToPath(servicePath, producer);</span><br><span class="line">                <span class="number">6</span>️⃣  <span class="built_in">this</span>.createCurrentServiceIpNode(producerMathodPath);</span><br><span class="line">                    log.debug(<span class="string">&quot;create current service node success, node path = &#123;&#125; ,method path = &#123;&#125;&quot;</span>, servicePath, producerMathodPath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本地监听</span></span><br><span class="line">                <span class="number">7</span>️⃣ subscribeChildChanges(serviceName, servicePath, PROVIDER_MAP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣：本地初始化 zk 的请求客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initZkClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zkClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            zkClient = <span class="keyword">new</span> <span class="title class_">ZkClient</span>(ZK_ADDRESS, ZK_SESSION_TIMEOUT, ZK_CONNECTION_TIMEOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对象定义成员变量 <code>zkClient</code></p>
<p>2️⃣：设置本地节点缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IRegisterCenterZkImpl.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setLocalCache</span><span class="params">(List&lt;Producer&gt; producerList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Producer producer : producerList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> producer.getServiceItf().getName();</span><br><span class="line">            List&lt;Producer&gt; producerListCache = PROVIDER_MAP.get(name);</span><br><span class="line">            <span class="keyword">if</span> (producerListCache == <span class="literal">null</span>) &#123;</span><br><span class="line">                producerListCache = Lists.newArrayList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producerListCache.add(producer);</span><br><span class="line">            PROVIDER_MAP.put(name, producerListCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>存在本地成员变量 <code>PROVIDER_MAP</code>，其中 Map 的 Key 为服务接口的类名</p>
<p>3️⃣：根据类名遍历节点信息</p>
<p>4️⃣：创建根节点信息，根节点地址为 <code>/config_register/&#123;appKey&#125;</code></p>
<p>5️⃣：根据服务名称创建服务节点信息，服务节点地址为: <code>/config_register/&#123;appKey&#125;/&#123;groupName&#125;/&#123;serviceName&#125;</code> 其中 <code>serviceName</code> 就是服务接口的类名</p>
<p>6️⃣：根据接口类名创建具体的方法节点信息,其中 <code>producerToPath</code> 方法，主要目的是将 <code>Producer</code> 对象转换成 Zk 的路径信息，其中主要实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">producerToPath</span><span class="params">(String servicePath, Producer producer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servicePath + <span class="string">&quot;/&quot;</span> + producer.getIp() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getPort() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getWeight() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getWorkerThreads() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getMethod().getName() + <span class="string">&quot;|&quot;</span></span><br><span class="line">                + producer.getGroupName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 返回的地址信息示例如下: <code>/config_register/&#123;appKey&#125;/&#123;groupName&#125;/&#123;serviceName&#125;/127.0.0.1|9999|1|10|get|defaut</code> </p>
<p><code>127.0.0.1|9999|1|10|get|defaut</code> 这段参数的含义就是：服务地址 + 服务端口 + 权重 + 工作线程数量 + 方法名称 + 服务组名称</p>
<p><code>createCurrentServiceIpNode</code> 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createCurrentServiceIpNode</span><span class="params">(String currentServiceIpNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(currentServiceIpNode)) &#123;</span><br><span class="line">            <span class="comment">// 临时节点</span></span><br><span class="line">            zkClient.createEphemeral(currentServiceIpNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7️⃣：服务地址监听</p>
<p><code>subscribeChildChanges</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribeChildChanges</span><span class="params">(String serviceName, String servicePath, Map&lt;String, List&lt;Producer&gt;&gt; dataMap)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从 zk 中读取路径</span></span><br><span class="line">        <span class="comment">// 2. 根据路径值 反序列化成 producer 对象</span></span><br><span class="line">        <span class="comment">// 3. 将 producer 对象放入 dataMap 中</span></span><br><span class="line">        zkClient.subscribeChildChanges(servicePath, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentChilds == <span class="literal">null</span>) &#123;</span><br><span class="line">                currentChilds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Producer&gt; producers = currentChilds.stream().map(currentChild -&gt; pathToProducer(serviceName, currentChild)).collect(Collectors.toList());</span><br><span class="line">            dataMap.put(serviceName, producers);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="initProviderMap-服务消费方节点获取"><a href="#initProviderMap-服务消费方节点获取" class="headerlink" title="initProviderMap 服务消费方节点获取"></a>initProviderMap 服务消费方节点获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initProviderMap</span><span class="params">(String remoteAppKey, String groupName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(SERVICE_METADATA)) &#123;</span><br><span class="line">            SERVICE_METADATA.putAll(<span class="built_in">this</span>.fetchOrUpdateServiceMetaData(remoteAppKey, groupName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Producer&gt;&gt; <span class="title function_">fetchOrUpdateServiceMetaData</span><span class="params">(String remoteAppKey, String groupName)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, List&lt;Producer&gt;&gt; providerServiceMap = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.initZkClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据分组获取服务提供方的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">providerNode</span> <span class="operator">=</span> getRootPath(remoteAppKey) + UrlConstants.SLASH + groupName;</span><br><span class="line">        <span class="comment">// 获取所有 serverName 地址</span></span><br><span class="line">       <span class="number">1</span>️⃣ List&lt;String&gt; producerServices = zkClient.getChildren(providerNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String serviceName : producerServices) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">servicePath</span> <span class="operator">=</span> getProducerServicePath(remoteAppKey, groupName, serviceName);</span><br><span class="line">            <span class="number">2</span>️⃣ List&lt;String&gt; producerPaths = zkClient.getChildren(servicePath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取所有 producer 地址(method)</span></span><br><span class="line">            <span class="keyword">for</span> (String producerPath : producerPaths) &#123;</span><br><span class="line">              <span class="number">3</span>️⃣  <span class="type">Producer</span> <span class="variable">pathToProducer</span> <span class="operator">=</span> pathToProducer(serviceName, producerPath);</span><br><span class="line">                List&lt;Producer&gt; providerList = providerServiceMap.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (providerList == <span class="literal">null</span>) &#123;</span><br><span class="line">                    providerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                providerList.add(pathToProducer);</span><br><span class="line">            <span class="number">4</span>️⃣     providerServiceMap.put(serviceName, providerList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="number">5</span>️⃣ subscribeChildChanges(serviceName, servicePath, SERVICE_METADATA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> providerServiceMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣：根据 <code>appKey</code> 和 <code>groupName</code> 从 zk 中查询注册的所有服务节点</p>
<p>2️⃣：根据 <code>serviceName</code> 获取该服务下的所有节点信息</p>
<p>3️⃣：使用 <code>pathToProducer</code> 将 zk 的 path 信息，转换成 <code>Producer</code> 对象</p>
<p>4️⃣：将节点信息缓存到本地</p>
<p>5️⃣：和服务提供方注册类似，订阅服务下方节点变化，然后刷新本地 <code>Map</code></p>
<h3 id="getServiceProducer-服务消费方获取服务节点"><a href="#getServiceProducer-服务消费方获取服务节点" class="headerlink" title="getServiceProducer 服务消费方获取服务节点"></a>getServiceProducer 服务消费方获取服务节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Producer&gt; <span class="title function_">getServiceProducer</span><span class="params">(String serviceName, String methodName)</span> &#123;</span><br><span class="line">        List&lt;Producer&gt; producers = SERVICE_METADATA.get(serviceName);</span><br><span class="line">        <span class="type">return</span> <span class="variable">producers</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="literal">null</span> :</span><br><span class="line">                producers.stream().filter(producer -&gt;</span><br><span class="line">                        producer.getMethod() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                producer.getMethod().getName().equals(methodName)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现代码就非常简单了，只需要遍历本地缓存的 SERVICE_METADATA 对象即可</p>
<p>由于其他方法的操作都是对本地缓存 <code>Map</code> 的操作，所以这里就不再详细展开了</p>
<p>到这里，已经完成了注册中心最重要方法编写，处理服务提供方的服务注册，和服务消费放的服务节点订阅。</p>
<p>下一章我们将完成服务提供方节点信息的注册和 <code>Netty</code> 消息的处理。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发一个自己的 RPC 框架（三）</title>
    <url>/2023/12/13/29-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20RPC%20%E6%A1%86%E6%9E%B6%20(%E4%B8%89)/</url>
    <content><![CDATA[<h1 id="如何开发一个自己的-RPC-框架（三）"><a href="#如何开发一个自己的-RPC-框架（三）" class="headerlink" title="如何开发一个自己的 RPC 框架（三）"></a>如何开发一个自己的 RPC 框架（三）</h1><p>之前的两篇文章中，已经介绍了实现一个 RPC 框架所需要的客户端和注册中心逻辑，那么这一章，将主要介绍如何实现 RPC 框架中的服务端(服务提供方) 和完善框架的其他补充逻辑。</p>
<span id="more"></span>

<h2 id="RPC-服务端实现"><a href="#RPC-服务端实现" class="headerlink" title="RPC 服务端实现"></a>RPC 服务端实现</h2><h3 id="服务注解-RpcProducer"><a href="#服务注解-RpcProducer" class="headerlink" title="服务注解(RpcProducer)"></a>服务注解(RpcProducer)</h3><p>和客户端调用标识类似，服务提供方也需要设置服务标识，用来服务的注册和相关配置信息拓展</p>
<p><code>@RpcProducer</code> 服务提供方注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcProducer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口:用于注册在服务注册中心，服务调用端获取后缓存再本地用于发起服务调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; serviceItf() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务分组组名：可用于分组灰度发布，配置不同分组，可以让调用都路由到配置了相同分组的路由上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">groupName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间：控制服务端超时时间 ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供者权重：配置该机器在集群中的权重，用于某些负载均衡算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">weight</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端线程数：限制服务端改服务线程数，服务端限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">workThreads</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务提供方节点注册"><a href="#服务提供方节点注册" class="headerlink" title="服务提供方节点注册"></a>服务提供方节点注册</h3><p>为了实现所有被 <code>@RpcProducer</code> 注解的实现类都可以被注册到注册中心，在 Spring 中，需要实现 </p>
<ul>
<li>ApplicationListener： <code>onApplicationEvent</code> 监听应用程序事件</li>
<li>ApplicationContextAware： <code>setApplicationContext</code> 设置当前上下文</li>
<li>DisposableBean：<code>destroy</code> 方法，bean 被销毁时执行</li>
</ul>
<p>这三个接口，通过 <code>setApplicationContext</code> 设置当前上下文，通过 <code>onApplicationEvent</code> 监听服务实现类然后提交到注册中心</p>
<p>理清楚上面流程后，便可以创建实现类 <code>ProducerAnnotationBean</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAnnotationBean</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationContextEvent&gt;, ApplicationContextAware, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 销毁 */</span></span><br><span class="line">        log.debug(<span class="string">&quot;AnnotationServicesPublisher bean destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="number">1</span>️⃣ <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> &#123;<span class="number">2</span>️⃣&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣：设置当前上下文</p>
<p>2️⃣：监听 Spring Bean 的动作</p>
<p><code>onApplicationEvent</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> &#123;</span><br><span class="line">        <span class="number">1</span>️⃣ <span class="keyword">if</span> (event.getApplicationContext() != applicationContext) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Received a event from another application context &#123;&#125;, ignoring it&quot;</span>, event.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新事件</span></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; annotation = applicationContext.getBeansWithAnnotation(RpcProducer.class);</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(annotation)) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;no simple rpc exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                annotation.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;simple rpc beanName: &#123;&#125;, bean: &#123;&#125;&quot;</span>, beanName, bean);</span><br><span class="line">                   <span class="number">2</span>️⃣ <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcProducer.class)) &#123;</span><br><span class="line">                        <span class="comment">// 获取对象</span></span><br><span class="line">                    <span class="number">3</span>️⃣    List&lt;Producer&gt; producerList = <span class="built_in">this</span>.buildProviderService(bean);</span><br><span class="line">                        <span class="comment">// 1. 启动服务</span></span><br><span class="line">                    <span class="number">4</span>️⃣    NettyService.getInstance().startService(RpcPropertiesUtil.getServerPort());</span><br><span class="line">                        <span class="comment">// 2. 服务注册</span></span><br><span class="line">                     <span class="number">5</span>️⃣   IRegisterCenterZkImpl.getInstance().register(producerList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 销毁所有的服务</span></span><br><span class="line">           <span class="number">6</span>️⃣ IRegisterCenterZkImpl.getInstance().destroy(<span class="literal">null</span>);</span><br><span class="line">            log.info(<span class="string">&quot;simple rpc closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣：判断上下文和当前 Spring 上下文是否一致</p>
<p>2️⃣：判断当前实例对象是否被 <code>RpcProducer</code> 注解</p>
<p>3️⃣：根据当前 <code>bean</code> 构造 <code>Producer</code> 对象</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ProducerAnnotationBean.class</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Producer&gt; <span class="title function_">buildProviderService</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="type">RpcProducer</span> <span class="variable">annotation</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcProducer.class);</span><br><span class="line">        Class&lt;?&gt; serviceItf = annotation.serviceItf();</span><br><span class="line">        <span class="keyword">if</span> (serviceItf == Object.class) &#123;</span><br><span class="line">            serviceItf = bean.getClass().getInterfaces()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">        NettyHandlerServer.PRODUCER_BEAN_MAP.put(serviceItf.getName(), bean);</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 获取注解信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> annotation.groupName();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> annotation.timeout();</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> annotation.weight();</span><br><span class="line">        <span class="type">int</span> <span class="variable">workThreads</span> <span class="operator">=</span> annotation.workThreads();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; finalServiceItf = serviceItf;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(bean.getClass().getDeclaredMethods())</span><br><span class="line">								<span class="comment">// 过滤掉 Object.class 的 equals、notify 等方法</span></span><br><span class="line">                .filter(method -&gt; !method.getDeclaringClass().equals(Object.class))</span><br><span class="line">                .map(method -&gt; &#123;</span><br><span class="line">                    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> Producer.builder()</span><br><span class="line">                            .serviceItf(finalServiceItf)</span><br><span class="line">                            .serviceObject(bean)</span><br><span class="line">                            .ip(IpUtil.getLocalIP())</span><br><span class="line">                            .port(RpcPropertiesUtil.getServerPort())</span><br><span class="line">                            .timeout(timeout)</span><br><span class="line">                            .appKey(RpcPropertiesUtil.getAppKey())</span><br><span class="line">                            .groupName(groupName)</span><br><span class="line">                            .weight(weight)</span><br><span class="line">                            .workerThreads(workThreads)</span><br><span class="line">                            .method(method)</span><br><span class="line">                            .build();</span><br><span class="line">                    <span class="keyword">return</span> producer;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4️⃣：启动 Netty Server 服务，这一段比较重要，稍后讲解</p>
<p>5️⃣：向注册中心注册服务提供方的节点信息</p>
<p>6️⃣：服务关闭时，清除所有的节点注册信息</p>
<p>完成上述步骤后，所有被 <code>RpcProducer</code> 注解的 <code>class</code> 就都将被注册到注册中心中。</p>
<h3 id="服务提供方启动-Netty-服务"><a href="#服务提供方启动-Netty-服务" class="headerlink" title="服务提供方启动 Netty 服务"></a>服务提供方启动 Netty 服务</h3><p>上一步的步骤4️⃣中，在向服务中心注册节点时，同时根据注解的端口启动了 <code>Netty</code> 服务，那么这个 <code>Netty</code> 服务是如何启动的，然后启动的目的是什么呢？</p>
<p>在第一章中我们有讲到，客户端的接口在执行反射操作时，会连接服务端的 <code>Netty</code> 服务，然后发送 <code>NettyRequest</code> 请求。那么服务端接收到 <code>NettyRequest</code> 请求后会做那么事情呢？服务端又是如何根据 <code>NettyRequest</code>映射到具体的方法上，同时将方法执行的结果进行返回的呢？这一节我们一起弄清楚这一点。</p>
<pre class="mermaid">sequenceDiagram
    客户端->>服务提供方: 1️⃣发送 NettyRequest 请求
    服务提供方->>接口实现: 2️⃣通过反射执行 method
    接口实现->>服务提供方: 3️⃣返回方法执行结果
    服务提供方 -> 客户端: 4️⃣返回 NettyResponse 结果</pre>

<p>新建一个 <code>NettyService.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NettyService.class</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NettyService</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NettyService <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startService</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NettyService.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bossGroup != <span class="literal">null</span> || workGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;netty server is already start&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bossGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">            workGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 解码器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(NettyRequest.class));</span><br><span class="line">                            <span class="comment">// 编码器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>());</span><br><span class="line">                            <span class="comment">// 服务处理</span></span><br><span class="line">                            <span class="number">1</span>️⃣ socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyHandlerServer</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverBootstrap.bind(port).sync().channel();</span><br><span class="line">                log.info(<span class="string">&quot;NettyServer start &#123;&#125; start now!!!&quot;</span>, IpUtil.getLocalIP() + UrlConstants.COLON + port);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;NettyServer startServer error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1️⃣：设置消息处理器</p>
<p>上述代码都比较常规，主要是使用 <code>Netty</code> 根据传入的端口进行了服务的启动，其中最主要的代码是</p>
<p><code>socketChannel.pipeline().addLast(new NettyHandlerServer());</code> 设置了消息的处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NettyHandlerServer.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyHandlerServer</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;NettyRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name to bean map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PRODUCER_BEAN_MAP = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, NettyRequest nettyRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isWritable()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;channel closed!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">localProducer</span> <span class="operator">=</span> <span class="built_in">this</span>.getLocalProducer(nettyRequest);</span><br><span class="line">        <span class="keyword">if</span> (localProducer == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;service not found, request=&#123;&#125;&quot;</span>, nettyRequest);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.invockMethod(localProducer, nettyRequest);</span><br><span class="line">        <span class="type">NettyResponse</span> <span class="variable">response</span> <span class="operator">=</span> NettyResponse.builder()</span><br><span class="line">                .uniqueKey(nettyRequest.getUniqueKey())</span><br><span class="line">                .result(result)</span><br><span class="line">                .build();</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 methodname 获取 Producer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Producer <span class="title function_">getLocalProducer</span><span class="params">(NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> request.getInvokeMethodName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getProducer().getServiceItf().getName();</span><br><span class="line">        List&lt;Producer&gt; producerList = IRegisterCenterZkImpl.getInstance().getProducersMap().get(name);</span><br><span class="line">        <span class="keyword">return</span> Collections2.filter(producerList, producer -&gt; &#123;</span><br><span class="line">            <span class="keyword">assert</span> producer != <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> producer.getMethod();</span><br><span class="line">            <span class="keyword">return</span> method != <span class="literal">null</span> &amp;&amp; method.getName().equals(methodName);</span><br><span class="line">        &#125;).iterator().next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法反射调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">invockMethod</span><span class="params">(Producer producer, NettyRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2023/12/8 增加超时检测</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">serviceObject</span> <span class="operator">=</span> producer.getServiceObject();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> producer.getMethod();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是最重要的，服务端反射调用方法</span></span><br><span class="line">            result = method.invoke(serviceObject, request.getArgs());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            result = e;</span><br><span class="line">            log.error(<span class="string">&quot;NettyServerBizHandler invokeMethod error, provider=&#123;&#125;, request=&#123;&#125;&quot;</span>, producer, request, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.error(<span class="string">&quot;NettyServerBizHandler error, now ctx closed&quot;</span>, cause);</span><br><span class="line">        <span class="comment">// 发生异常，关闭链路</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息处理器中，在 <code>invockMethod</code> 方法中，根据传入的 <code>request</code> 的 <code>method</code> 参数进行了方法的反射获取执行结果，然后进行返回。反射执行完成后，将结果组装成 <code>NettyResponse</code> 结果进行返回。</p>
<p>那么到这里就完成了整个远程服务的执行。 </p>
<h2 id="Spring-注解服务扫描"><a href="#Spring-注解服务扫描" class="headerlink" title="Spring 注解服务扫描"></a>Spring 注解服务扫描</h2><p>定义 <code>@EnableRpc</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(&#123;RpcImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRpc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中 <code>@Import</code> 了 <code>RpcImportSelector.class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.simon.spring.ProducerAnnotationBean&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.simon.spring.ConsumerAnnotaionBean&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RpcImportSelector</code> 对象实现了 <code>ImportSelector</code> 接口， <code>selectImports</code> 方法中返回了处理客户端和服务端注解的类。</p>
<p>客户端启动类 <code>ConsumerApplication.class</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务启动时，只需要加上 <code>@EnableRpc</code> 注解即可启动 RPC 服务</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><code>ConsumerApplication.class</code> 启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserController.class</code> 请求接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 需要远程调用的接口</span></span><br><span class="line">    <span class="meta">@RpcClient(remoteAppKey = &quot;test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<p><code>application.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8082</span></span><br></pre></td></tr></table></figure>

<p><code>rpc.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># netty 配置</span><br><span class="line">rpc_app_key=test</span><br><span class="line"># ZK 配置</span><br><span class="line">zk_server=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span></span><br><span class="line">rpc_session_timeout=<span class="number">3000</span></span><br><span class="line">rpc_connection_timeout=<span class="number">3000</span></span><br><span class="line">rpc_channel_connect_size=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>ProducerApplication.class</code> 启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableRpc</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserServiceImpl.class</code> 接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RpcProducer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;username &quot;</span> + username + <span class="string">&quot;服务信息: &quot;</span> + RpcPropertiesUtil.getServerPort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置信息</strong></p>
<p><code>application.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p><code>rpc.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># netty 配置</span><br><span class="line">rpc_app_key=test</span><br><span class="line">rpc_server_port=<span class="number">9999</span></span><br><span class="line"># ZK 配置</span><br><span class="line">zk_server=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span></span><br><span class="line">rpc_session_timeout=<span class="number">3000</span></span><br><span class="line">rpc_connection_timeout=<span class="number">3000</span></span><br><span class="line">rpc_channel_connect_size=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p>分别启动服务端和客户端，然后请求 <a href="http://127.0.0.1:8082/user/getUser/testdemo">http://127.0.0.1:8082/user/getUser/</a>simon, 可以查看结果</p>
<p><img src="/../images/23.12.13/1.png" alt="Untitled"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<strong>如何开发一个自己的 RPC 框架</strong>就全部完成了，框架的内容非常粗糙，距离真正商用版本还差很多距离。但是通过参考别人的源码，可以理解一个基础的 RPC 框架的大体结构和所需要用到的知识，包括 Netty、Spring 、序列化、负载均衡策略、 zookeeper、 Java 的反射等等。但不管怎么说，有进步就是一件很快乐的事情！</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 年出行总结</title>
    <url>/2024/01/19/30-2023%20%E5%B9%B4%E5%87%BA%E8%A1%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2023-年出行总结"><a href="#2023-年出行总结" class="headerlink" title="2023 年出行总结"></a>2023 年出行总结</h1><p>早上开车上班的时候，发现车子的总里程已经 2 万多公里了。马上也到提车一年了，就趁着这个时间点总结一下2023 年的出行。</p>
<p>因为提车之后就部署了 <a href="https://github.com/teslamate-org/teslamate">teslamate</a>，所以每次出行都可以通过后台查看到。</p>
<span id="more"></span>

<h2 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h2><p>去年提车 23.02 到现在 24.01 共行驶了 <strong><strong>23818km</strong></strong></p>
<p>去过浙江安吉、江苏常熟、苏州、扬州、高邮、湖北孝感、黄冈。当然大部份时间还是在南京</p>
<p><img src="http://static.simoncode.top/picgo/Untitled1.png"></p>
<p><img src="http://static.simoncode.top/picgo/Untitled.png"></p>
<p>总共充了 <strong><strong>3.39k</strong></strong> 度电，大致消费了 <strong><strong>1499.11</strong></strong> 元，换算下来每公里成本 0.06 元。当然这里面大部份是因为在家使用谷电补能，还有前期 Tesla 送的超充里程解决了外出的出行成本。</p>
<p><img src="http://static.simoncode.top/picgo/Untitled2.png"></p>
<p>总得来说，购车之后大大的扩大出行距离，之前觉得远麻烦去的地方自从有车之后也变得方便起来了。印象比较深的就是几年好像已经去过好多次义乌小商品市场了。</p>
<h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><h3 id="江宁提车"><a href="#江宁提车" class="headerlink" title="江宁提车"></a>江宁提车</h3><p>二月是提车的第一个月，做为驾驶证已经到期更换但从未上路的“老”司机来说，开车上路还是有很大难度的。所以提车那天，叫上了之前的同事一起。印象中提车那天还挺顺利的，由于我们去的比较早，接待大厅稍微坐了一会工作人员就帮我们把相关的手续办好了。然后就是简单的提车拍照环节。</p>
<p><img src="http://static.simoncode.top/picgo/Untitled3.png"></p>
<p>在这里也非常感谢朱哥那天能够赶过来帮忙，指导我这个新手踉踉跄跄地将车开回家。</p>
<h3 id="公司-第一天上路"><a href="#公司-第一天上路" class="headerlink" title="公司-第一天上路"></a>公司-第一天上路</h3><p>地狱开局的难度。周一那天由于第一次上路不放心，kiko 坐在副驾驶陪我一起开车去公司。出发之前我俩商量着可以早点到公司一起吃顿早饭，谁能想到我的第一次上路就遇到了地狱开局。那天简直 Debuff 拉满，大雨 + 周一 + 开学。上面三个条件单拉一个出来就得让早高峰堵死，谁能想到我第一天就将三者集齐了。路上我小心翼翼地变道，时不时得让 kiko 帮我观察观察右边的车距，就这样短短 20km 的路径我们硬是开了两个小时才到公司。这里不得不吐槽一下特斯拉没有 360 有时候确实不太方便。</p>
<h3 id="六合挖雨花石"><a href="#六合挖雨花石" class="headerlink" title="六合挖雨花石"></a>六合挖雨花石</h3><p>有了车之后就总想着出去玩耍，再加上虽然在南京待了那么多年，但是依然很多区没有去过。所以二月周六的一个下午，kiko 就约着一起去捡雨花石。我俩在小红书、大众点评上各种搜索，最后定下来去六合的小天池。</p>
<p>本来去的路就不太好走，由于六合那边到处都在修高架，导致路面全部都是坑坑洼洼，然后那天还下着小雨就更难走了。我俩开了开了一个多小时才到。</p>
<p>到了之后我俩就傻眼了，这是啥小天池啊，这不就纯纯的小山堆嘛。路两边全部都被铁皮围起来了，只有一个小破石堆。但就这 kiko 依然挖的不亦乐乎。哈哈哈</p>
<p><img src="http://static.simoncode.top/picgo/Untitled.jpeg"></p>
<h3 id="汤山矿坑公园"><a href="#汤山矿坑公园" class="headerlink" title="汤山矿坑公园"></a>汤山矿坑公园</h3><p>记得那天出发的时候就已经两三点了。那时候天气非常舒服，公园里面露营的人不少，还有不少银行在哪推销办信用卡呢</p>
<p><img src="http://static.simoncode.top/picgo/Untitled1.jpeg"></p>
<p>远处看还是挺壮观的</p>
<p><img src="http://static.simoncode.top/picgo/Untitled2.jpeg"></p>
<p>刚出生没几个月的小狗狗，刚刚洗完澡身上可香了</p>
<h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><h3 id="常熟"><a href="#常熟" class="headerlink" title="常熟"></a>常熟</h3><p>三月我们去了一趟卡酷桑哪里，从南京出发大概 250 多公里。我们早上八点半多发的，差不多中午十一点出头就到了。那也是我第一次上高速，说到这里就不得不夸一下特斯拉的辅助驾驶了，高速跑起来确实挺省心的。全程两个半小时，到达目的地之后几乎没有那种长途驾驶的疲惫感。</p>
<p><img src="http://static.simoncode.top/picgo/Untitled3.jpeg"></p>
<p>常熟的樱花</p>
<p><img src="http://static.simoncode.top/picgo/Untitled4.jpeg"></p>
<p>苏州“大裤衩”</p>
<h3 id="”撞车”啦"><a href="#”撞车”啦" class="headerlink" title="”撞车”啦"></a>”撞车”啦</h3><p>三月底的时候，我就引来了车子的“一血”。早上从出车库的时候，大概是还没睡醒的原因，上车就直接往右拐了，直接就剐蹭到了旁边的车。撞上去之后大脑是懵的，kiko 在车库出口等我，听到声音后立马赶了过来。这里也非常感谢 kiko，第一时间没有说任何指责我的话，而是开始想解决问题的办法。</p>
<p>由于是第一次出险，我俩都没有任何经验，便求助身边的朋友。打电话报警、联系保险公司、联系车主。</p>
<p>被剐蹭的车主也是一个小伙子，见面之后我们也连忙道歉。换位思考一下，他人躺床上睡觉，车好好地停在车库，被交警电话吵醒告知车被撞了，换谁心里都不舒服。</p>
<p>后面的流程就是交警定责然后各自修各自的车了。该说不说特斯拉修车是真他妈贵啊！</p>
<p><img src="http://static.simoncode.top/picgo/Untitled5.jpeg"></p>
<p>被我撞的车，私密马赛</p>
<h3 id="马鞍山"><a href="#马鞍山" class="headerlink" title="马鞍山"></a>马鞍山</h3><p>三月的结尾，kiko 开始了将近半年的考试征程。撞车的那个周末，本来准备我这边开车带上她朋友一起去马鞍山的。好巧不巧就在这周五撞上了。</p>
<h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>四月份开始，kiko 就为考试到处奔波了</p>
<h3 id="江宁"><a href="#江宁" class="headerlink" title="江宁"></a>江宁</h3><p>江宁的那个考试是宿迁的一个中学招聘。面试地点是在晓庄学院江宁校区，由于面试时间非常早 7:30,我们住的地方离江宁又非常远，所以那天早上起来的非常早。好在早起没有白费，kiko 也以第一名拿到了那个 offer。</p>
<p><img src="http://static.simoncode.top/picgo/20240119181612.png"></p>
<p>考试那天我也是在附近到处转悠，竟然偶然地当了一回马拉松的观众。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_3774.jpeg"></p>
<h3 id="长江潮音乐节"><a href="#长江潮音乐节" class="headerlink" title="长江潮音乐节"></a>长江潮音乐节</h3><p>整个四月份最期待的事情就是音乐节了。这个音乐节也是命途多舛，21 年开始因为疫情开票三次然后取消了三次。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_3784.jpeg"></p>
<p>第一次见到许嵩</p>
<h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><h3 id="黄冈-回家"><a href="#黄冈-回家" class="headerlink" title="黄冈-回家"></a>黄冈-回家</h3><p>准确点来讲应该放在四月份，因为今年的五一假期比较特殊，四月末就假期就开始了。</p>
<p>五一回家那几天特别忙，参加了 kiko 表哥的婚礼、见了几个老朋友</p>
<h3 id="高邮"><a href="#高邮" class="headerlink" title="高邮"></a>高邮</h3><p>高邮也是为了去考试，记得那天是周五下班了赶过去的。高邮离南京并不远，差不多 100 多 km ，所以开了差不多一个多小时就到了。</p>
<p>住的酒店楼下就有一个早餐店，所以我们早上出门的时候很方便地来了一碗当地的特色鱼汤。有一说一有点东西。</p>
<p>当然，在高邮也收到了第一份扣分违章</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4793.jpeg"></p>
<h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>六月的前部分时间，kiko 进行了一场毕业旅行。所以前半个月并没有出远门</p>
<h3 id="安吉"><a href="#安吉" class="headerlink" title="安吉"></a>安吉</h3><p>“大坑”的小杭坑。kiko 在小红书搜到的别人推荐，什么号称小伊犁。作为刚刚从真伊犁旅游回来的kiko，决定去好好看下做下对比。</p>
<p>非常不赶巧，当天是端午节。去小杭坑的路上有赛龙舟的比赛导致有一段路被封，好在高德地图非常给力，给我们导到了一个翻山的路。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_3978.jpeg"></p>
<p>翻山的路上风景</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4003.jpeg"></p>
<p>“小伊犁”</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4011.jpeg"></p>
<p>茶山</p>
<h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>七月份的生活就略显无聊了，好像都没有出南京市。</p>
<h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><h3 id="高淳"><a href="#高淳" class="headerlink" title="高淳"></a>高淳</h3><p>这是八月份的唯一一次远门，主要是陪 kiko 练车。从家出发到石臼湖，大概 100km。kiko 开过去的，一路上没有多少高速都是城市道路，大概开了两个多小时。</p>
<p>八月份的石臼湖景色一般，传说中的龙猫海也木有看到</p>
<h3 id="同事婚礼"><a href="#同事婚礼" class="headerlink" title="同事婚礼"></a>同事婚礼</h3><p>八月还有一件大事，就是之前我和 kiko 介绍的两位前同事终于结婚了。</p>
<p>说起这二位也是不容易，中间分分合合，不过好在最终走向了婚姻的殿堂</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4114.jpeg"></p>
<p>那天见到了很多之前的同事，也见证了他俩的爱情</p>
<h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p>这个月也是 kiko 开始工作的第一个月，月底 kiko 和我讲她发工资的时候，我有一种老父亲看到女儿长大的欣慰感</p>
<h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><h3 id="黄冈-回家-1"><a href="#黄冈-回家-1" class="headerlink" title="黄冈-回家"></a>黄冈-回家</h3><p>今年应该工作之后少有的回家那么勤的一年。本来五一已经回过家了，十一就该出去旅游的。但是我两个好朋友都定在今年十一婚礼，所以不管咋样都得回家。</p>
<p>这次国庆回家也是人在囧途</p>
<p><strong>堵车</strong></p>
<p>考虑到国庆期间高速路上拥堵。我俩商量着早上两点出门，出门前看了一眼导航，发现离我们最近的高速两点还是一片红。头铁的我俩出了门，上了高速之后才发现傻眼了，高速路上全是车。凌晨两点啊，全是车。路上经过的服务区也都是爆满，进去都需要排长队。最终黄天不负有心人啊，原本五个小时的车程，我们开了十一个小时。回家最后的一段路，感觉都是在闭眼睛开车了。</p>
<p><strong>充电</strong></p>
<p>这就是回家做的第二件傻逼事情。22 年家里新装了一面镜子，之前的全身镜就闲置下来了。kiko 就说这次回家不如把这面镜子带回家。鉴于镜子的长度，便把后排打倒放置。然后为了加强稳定性，好巧不巧车子的后备箱有一根多出来绳子，我们便将镜子缠绕几层后和车上的绳子固定。</p>
<p>路上我们停在第一个服务区的时候，就想着趁着上卫生间的功夫冲一下电，试了两三个充电桩都冲不进去电。想着是充电站的问题加上当时电量足够，我们便继续上路。</p>
<p>开了三百多公里后，车子必须充电了。我们便找了一个就近的服务区停下来充电，这个时候车子还是无法冲进去电。此时我们已经开始着急了，因为如果不充的话车子无法开回家。我们便立马开始联系充电站管理人员、特斯拉的官方客服，最终都无果。因为出问题的都是国家电网的充电桩，所以我决定下高速找一个第三方的充电桩试试。</p>
<p>下了高速，我们来到一个特来电的充电桩，扫码、付钱、充电。车辆任然提示无法充电，这个时候电量不足的焦虑加上旅途的疲惫和几次的失败交杂在一起。我们又拨通了特斯拉客服的电话，接电话的是一位小哥哥，非常耐心的知道我们做各种检查，当他说到：“麻烦将充电口的锁复位一下呢”，我问：“怎么复位呢？”，他说：“拉一下充电口附近的小绳”。听完他说的话，我立马道歉+挂断电话。是的，导致我们无法充进电的原因就是我们将充电口的锁绳常开了。</p>
<p><img src="http://static.simoncode.top/picgo/20240119182112.png"></p>
<h3 id="孝感-接亲第一弹"><a href="#孝感-接亲第一弹" class="headerlink" title="孝感-接亲第一弹"></a>孝感-接亲第一弹</h3><p>由于女方那边的要求，接亲出门仪式需要在10.2 号凌晨进行，所以需要在10.1 日晚上到达女方家里。</p>
<p>浠水到孝感，全程 170多公里。1 号晚上七点多出门，一路上还下了点小雨，好在一路上比较顺利。最终准时到达女方家里。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4279.jpeg"></p>
<p>凌晨到达，准备接亲</p>
<p><img src="http://static.simoncode.top/picgo/5370e4ac30eba86a841f9b17bdff0970.jpeg"></p>
<p>婚礼现场</p>
<h3 id="团陂-接亲第二弹"><a href="#团陂-接亲第二弹" class="headerlink" title="团陂-接亲第二弹"></a>团陂-接亲第二弹</h3><p>第二场接亲就比较简单了，因为都是在浠水县内，根本不需要那么着急。而且当天晚上我们就住在男方家对面，接亲的路上也是车头全程带队，队伍也很庞大。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4290.jpeg"></p>
<p>女方家那边都是太阳能发电</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4293.jpeg"></p>
<p>婚礼现场</p>
<h3 id="扬州"><a href="#扬州" class="headerlink" title="扬州"></a>扬州</h3><p>从年头就计划着去扬州，到十月末的时候，终于去到了。</p>
<p><strong>大运河博物馆</strong>，去扬州比较推荐的地方，重点是免费，而且停车场巨大。唯一的小插曲就是去的路上差点把车子的地盘剐蹭到。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4384.jpeg"></p>
<p>其他就是在关东街附近走走转转，喝了扬大的酸奶，早上起来去吃了扬州的早茶。整体感觉早茶和南京的早茶没啥区别。包子、馄饨、面条，作为一个湖北人没有很爱。</p>
<h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><h3 id="常熟-1"><a href="#常熟-1" class="headerlink" title="常熟"></a>常熟</h3><p>这次去常熟是为了参加卡酷桑的婚礼，同样我俩作为她和小吴的感情见证人，见证了他们的相识、相爱、离别和最终走向婚姻殿堂，结局是美好的。</p>
<p>小吴接亲时候的真情流露，确实感动到了当时在现场的我。</p>
<p>十一月剩下的日子就比较单调了，正常的上下班、周末打打乒乓球。</p>
<h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><h3 id="滁州"><a href="#滁州" class="headerlink" title="滁州"></a>滁州</h3><p>去滁州也是临时起意，家这边离滁州非常的近。周六下午就和kiko 简单商量之后就决定过去</p>
<p>到了之后才知道，原来欧阳修的《醉翁亭记》就是在滁州写的。</p>
<p><img src="http://static.simoncode.top/picgo/IMG_4650.jpeg"></p>
<p><img src="http://static.simoncode.top/picgo/IMG_4654.jpeg"></p>
<h3 id="马鞍山-1"><a href="#马鞍山-1" class="headerlink" title="马鞍山"></a>马鞍山</h3><p>和四月份去马鞍山的目的完全不同，这次去就纯粹是为了泡澡。</p>
<p>我们一行四人早上九点多便出了门，十点钟不到便到了马鞍山。</p>
<p>有一说一汤乐汇的那个现煮面条味道确实不错，小猫胃的 kiko 竟然都能吃得下一碗,amazing!!!</p>
<h3 id="新街口-跨年"><a href="#新街口-跨年" class="headerlink" title="新街口-跨年"></a>新街口-跨年</h3><p>作为从不凑热闹的我，竟然也跑到了新街口跨年。好在我们那天时间安排的都很巧妙。十一点四十多从珠江路地铁站出站，路上等了十几分钟就等到了倒计时。没有很拥挤也没有等很久，所以整体的体验还是非常好。</p>
<p><img src="https://static.simoncode.top/picgo/IMG_4678.jpeg"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>2023 年是疫情放开之后的第一年，也终于有机会能够出去走走看看。</p>
<p>2023 年也是 kiko 研究生毕业的一年，学生到教师，你小子适应的还可以嘛。</p>
<p>2023 年我好像只有球技提供了一点点，其他都没啥进步。</p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>出行</tag>
        <tag>特斯拉</tag>
      </tags>
  </entry>
</search>
